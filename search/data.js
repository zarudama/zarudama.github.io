


var data = [
{
url: "https://zarudama.github.io/post/",
title: "Posts",
date: "2019-11-08T20:38:00+09:00",
body: "Posts"
},
{
url: "https://zarudama.github.io/tags/",
title: "Tags",
date: "2019-11-08T20:38:00+09:00",
body: "Tags"
},
{
url: "https://zarudama.github.io/tags/ubuntu/",
title: "ubuntu",
date: "2019-11-08T20:38:00+09:00",
body: "ubuntu"
},
{
url: "https://zarudama.github.io/tags/xmonad/",
title: "xmonad",
date: "2019-11-08T20:38:00+09:00",
body: "xmonad"
},
{
url: "https://zarudama.github.io/post/2012/09/xmonad_use/",
title: "xmonadを試す",
date: "2019-11-08T20:38:00+09:00",
body: "xmonadを試す \u0026#30446;\u0026#27425; インストールメモ xinitrc 参考サイト CUIでtmuxを操作してるときの一覧できる快適さをGUIに求めた結果、自宅のUbuntuにXmonadをいれてみました。 http://gihyo.jp/admin/serial/01/ubuntu-recipe/0124 タイル型のウィンドウマネージャです。常にウィンドウ全てが一覧されるやつです。インストールしてみて実感しましたがタイル型はとーっても快適です。普段からemacsでキーボード操作メインのユーザだったらすぐに気にいるかと思います。とくにウィンドウ切り替えが Mod+j/k でできるのがイイ! (それに比べて WindowsのALT+tabは左手の手首が死ぬ。。。) 今回、Xmonadというのをインストールしましたが、老舗のawesomeというのも人気があるそうです。ただXmonadの方が後発である分いろいろブラッシュアップされてるような印象でした。問題は設定ファイルがHaskellってことですかね。できれば覚えたくないですよね。いやHaskellは勉強して動かしたことはありますが、今はLisp系言語を覚え中なので他の言語はできるだけ気にせず脳の負担を増やしたくないのです。そういう意味で気になるのは、設定フィアルがCommonLispであるstumpwm。そのうち試したいと思います。 しかしタイル型使ってると、UnityとかgnomuShellの動向がどうでもよくなりますな。 インストールメモ $ sudo apt-get install xmonad $ sudo apt-get install dmenu # キーボードランチャー $ sudo apt-get install xmobar # ステータスバー xmorbar用の設定ファイル( ~/.xmobarrc )を作成する。 -- -*- mode:haskell -*- Config { font = \u0026#34;xft:Sans-9:bold\u0026#34; , bgColor = \u0026#34;black\u0026#34; , fgColor = \u0026#34;grey\u0026#34; , position = Top , lowerOnStart = False , commands = [ Run Network \u0026#34;eth0\u0026#34; [\u0026#34;-L\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;-H\u0026#34;,\u0026#34;32\u0026#34;,\u0026#34;--normal\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;--high\u0026#34;,\u0026#34;red\u0026#34;] 10 , Run Cpu [\u0026#34;-L\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;-H\u0026#34;,\u0026#34;50\u0026#34;,\u0026#34;--normal\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;--high\u0026#34;,\u0026#34;red\u0026#34;] 10 , Run Memory [\u0026#34;-t\u0026#34;,\u0026#34;Mem: \u0026lt;usedratio\u0026gt;%\u0026#34;] 10 , Run Swap [] 10 , Run Battery [] 600 , Run Com \u0026#34;lsb_release\u0026#34; [\u0026#34;-s\u0026#34;,\u0026#34;-d\u0026#34;] \u0026#34;\u0026#34; 36000 , Run Date \u0026#34;%Y %b %_d(%a) %H:%M:%S\u0026#34; \u0026#34;date\u0026#34; 10 ] , sepChar = \u0026#34;%\u0026#34; , alignSep = \u0026#34;}{\u0026#34; , template = \u0026#34;\u0026lt;fc=#ee9a00\u0026gt;%lsb_release%\u0026lt;/fc\u0026gt; | %cpu% | %memory% %swap% | %eth0% | %battery% }{ %date%\u0026#34; } ~/.xmonad/xmonad.hs を作成する。 import XMonad import XMonad.Hooks.DynamicLog import XMonad.Hooks.ManageDocks import XMonad.Util.Run(spawnPipe) import XMonad.Util.EZConfig(additionalKeys) import System.IO main = do xmproc \u0026lt;- spawnPipe \u0026#34;/usr/bin/xmobar /home/mikio/.xmobarrc\u0026#34; -- .xmoabrrcのパスを記述しておく xmonad $ defaultConfig { manageHook = manageDocks \u0026lt;+\u0026gt; manageHook defaultConfig , layoutHook = avoidStruts $ layoutHook defaultConfig , logHook = dynamicLogWithPP $ xmobarPP { ppOutput = hPutStrLn xmproc , ppTitle = xmobarColor \u0026#34;green\u0026#34; \u0026#34;\u0026#34; . shorten 50 } , modMask = mod4Mask -- WindowsキーをModキーとしてバインドする } `additionalKeys` [ ((mod4Mask .|. shiftMask, xK_z), spawn \u0026#34;xscreensaver-command -lock\u0026#34;) , ((controlMask, xK_Print), spawn \u0026#34;sleep 0.2; scrot -s\u0026#34;) , ((0, xK_Print), spawn \u0026#34;scrot\u0026#34;) ] 最低限のコマンド Mod-S-q ログアウト Mod-S-c ウィンドウクローズ Mod-S-RET 端末起動 Mod-p キーワードランチャー起動 Mod-q 設定ファイルの再読込 xinitrc xmodmapの設定とdropboxの読み込みを設定しています。 (sleep 3; xmodmap ~/.xmodmap) \u0026amp; ~/.dropbox-dist/dropboxd \u0026amp; exec xmonad 参考サイト http://d.hatena.ne.jp/uhiaha888/20110113/1294885816"
},
{
url: "https://zarudama.github.io/",
title: "ざる魂",
date: "2019-11-08T20:38:00+09:00",
body: "ざる魂"
},
{
url: "https://zarudama.github.io/post/2011/04/windows_install/",
title: "(超個人的)Windowsインストール後にやることまとめ",
date: "2019-11-08T20:36:00+09:00",
body: "(超個人的)Windowsインストール後にやることまとめ \u0026#30446;\u0026#27425; ソフトのインストールポリシー コントロールキーの設定 - xp - win7 Usersディレクトリの作成(XPのみ) 一番最初にインストール 環境変数の設定 キーボードの入力速度を早める アンチエイリアスの設定 入れるソフト インストーラ系ソフトのインストール 解凍系 スタートアップの設定 MySQL php 別PCに移行する場合 ファイル共有の設定 ローカルPCのAdminユーザのパスワードを設定 設定ファイルのコピー 移行用ソフト Faithの自作マシンでのドライバインストール FathのBTOパソコン ソフトのインストールポリシー インストーラのないツールは基本的に%HOME%/apps下に展開する。 インストーラものはデフォルト値でインストール %HOME%/shortcutsにショートカットをおいてlauncyで管理 UNIX系(コマンドライン系)のミドルウェアでインストーラーがない場合は%HOME\u0026amp;/opt/下に展開する。 コントロールキーの設定 xp xkeyemacsをつかってcapsキーをctrsキーにする。 win7 Changekeyを使用する(右クリメニューで管理者として実行すること)。 chgkey.exe Dropboxに保存してある。 GUIのキーボードが表示されるので変更する Caps → Ctrl 無変換 → Ctrl 変換 → Ctrl ひらがな → Shift 再起動 Usersディレクトリの作成(XPのみ) 「Link Shell Extension」をインストールして「c:\\」に「C:\\Documents and Settings」のディレクトリジャンクションを作り名前を「Users」とする。これにより c:\\Users\\というディレクトリができ、Windows7/Vistaと同じような構成になる。 一番最初にインストール Launcy Firefox Emacs ExpLzh 環境変数の設定 HOME XPの場合:HOME=c:\\Users\\mikio Windows7の場合:HOME=%USERPROFILE% HOMEはダブルクォーテーションで囲んではいけない。emacsが起動しなくなる。 HOMEはcygwin,Emacs用、XYZZYHOMEはxyzzy用の環境変数。 ※cygwinでは、HOMEを設定すると、自動的に/home/mikiがc:\\mikiにマウントされる。 MAVEN_HOME %HOME%\\opt\\ XYZZYHOME XYZZYHOME=%HOME%\\aps\\xyzzy PATH c:\\cygwin\\bin; 下記は.bashrc側に置くので設定しなくて良い。 JAVA_HOME=%HOME%\\opt ANT_HOME= PATH %PATH%;%HOME%\\bin;%MAVEN_HOME%\\bin;%HOME%\\opt\\php-5.3.8-Win32-VC9-x86 TERM xternm(CYGWIN用) CYGWIN tty(screenのデタッチ用) キーボードの入力速度を早める (Win7) [コンパネ] -\u0026gt; [コンピュータの簡単操作] -\u0026gt; [キーボード動作の変更] -\u0026gt; [キーボードの設定] アンチエイリアスの設定 MacTypeをインストールする。 fontは「Mig 1M」を使用する。MigMix1M 行間が広いので注意。 入れるソフト インストーラ系ソフトのインストール Spybot Searcy \u0026amp; Directory Link Shell Extension http://schinagl.priv.at/nt/hardlinkshellext/hardlinkshellext.html AdujustClock WinSCP Jing Chrome Bullzip PDF Printer Java JRE MediaMonkey(音楽管理ソフト) Switcher(MacのExpose) JDK, JRE 解凍系 cygwinのインストール putty、ごった煮にさらに機能追加版 http://ice.hotmint.com/putty/ ※オリジナルのごった煮版は、コマンドラインからのplinkがうまく使えなかったので使用しない。 Jane sytle eclip Eclipse WinDeskWide(仮想デスクトップ) TClock Light (for Windows XP) tclocklight-kt100204(for WIndows7) タスクバーを左たてに表示する場合、tclock.iniを書きに書きかえる。 Format=\u0026ldquo;yy/mm/dd\\nddd\\nhh:nn:ss\u0026rdquo; AdjustClock windows7の場合、OSに自動同期機能があるのでいらない。 スタートアップの設定 タートアップフォルダの開き方 [スタート] -\u0026gt; [すべてのプログラム] -\u0026gt; [] スタートアップを右クリック - 開く 下記を登録する。 tclock eclip pagent MySQL MySQLのHPにてCommunityServerをインストールする。 HPの上の方にある大きなバナーのやつだと余計な製品がたくさん入ってわけわからんので注意。 php http://windows.php.net/download/#php-5.3-ts-VC9-x86 windows版のバイナリ(*.zip)をダウンロードして展開する。 展開場所の例 $HOME/opt/php 別PCに移行する場合 ファイル共有の設定 コンパネ　-　Windowsファイアウォール - 例外 「ファイルとプリンタの共有」をチェックする。 ローカルPCのAdminユーザのパスワードを設定 コントロールパネル - ユーザアカウント Administratorを選択し、[パスワードのリセット]をクリックし、新しいパスワードを入力する。 設定ファイルのコピー エクスプローラを立ち上げ、旧端末のCドライブに接続する。 \u0026ndash; \\\\旧端末のコンピュータ名\\C$ 旧端末の必要な情報をコピーする(FireCopyを使用する。)。 \u0026ndash; c:\\miki 移行用ソフト FireFile Copy :高速ファイルツール。上書き確認とかいろいろ。エクスプローラだときつい。 Faithの自作マシンでのドライバインストール windows7を入れた最初の状態では、ネットワークアダプタのドライバがないためネットにつながらない。そこで、ドライバをインストールする。ネットワークアダプター以外にもいくつかドライバがないものがあるのでついでにインストールしておく ユニバーサルシリアルバスや マザーボードのCD-ROMを用意する(P8Z68V-PRO)。 [コントロールパネル] - [ハードウェアとサウンド]-[デバイスマネージャ] ほかのデバイスを選択し、びっくりマークのついている機器を右クリック [ドライバーソフトウェアの更新]－[コンピュータを参照してドライバーソフトウェアを検索します] FathのBTOパソコン 電源PC GOURIKI3 700A 対応規格：ATX/EPS 電源容量：700W 80PLUS認証：Bronze サイズ：150x155x86mm 剛力3 GOURIKI3-700Aのスペック・仕様"
},
{
url: "https://zarudama.github.io/tags/windows/",
title: "windows",
date: "2019-11-08T20:36:00+09:00",
body: "windows"
},
{
url: "https://zarudama.github.io/post/2013/05/windows_misaki_stack/",
title: "Windowsでmisakiのデモが動かない",
date: "2019-11-08T20:34:00+09:00",
body: "Windowsでmisakiのデモが動かない \u0026#30446;\u0026#27425; 動作環境 Clojureで書かれたブログジェネレータの misaki ですが、そのままではWindows上ではサンプルが動作しません。 C:\\Users\\miki\\dev\\misaki\u0026gt;lein run samples/blog * Compiling \u001b[1mall templates\u001b[22m * Compiling \u001b[1matom.xml.clj\u001b[22m \u001b[4mjava.io.FileNotFoundException: samples\\blog\\public\\samples\\blog\\template\\ato m.xml (?w?????p?X?????????????B)\u001b[24m at misaki.util.file$write_file / \u001b[1minvoke\u001b[22m (\u001b[31mfile.clj\u001b[0m:\u001b[31m\u001b[1m 152\u001b[22m\u001b[0m) at misaki.compiler.default.core$compile_STAR_ / \u001b[1minvoke\u001b[22m (\u001b[31mcore.cl j\u001b[0m:\u001b[31m\u001b[1m237\u001b[22m\u001b[0m) at misaki.compiler.default.core$compile_template / \u001b[1minvoke\u001b[22m (\u001b[31mcore .clj\u001b[0m:\u001b[31m\u001b[1m256\u001b[22m\u001b[0m) at misaki.compiler.default.core$_compile$fn__1874 / \u001b[1minvoke\u001b[22m (\u001b[31mcor e.clj\u001b[0m:\u001b[31m\u001b[1m70\u001b[22m\u001b[0m) at misaki.compiler.default.core$_compile / \u001b[1minvoke\u001b[22m (\u001b[31mcore.clj\u001b[0m :\u001b[31m\u001b[1m58\u001b[22m\u001b[0m) at misaki.core$call_compiler_fn / \u001b[1mdoInvoke\u001b[22m (\u001b[31mcore.clj\u001b[0m:\u001b[31m\u001b [1m55\u001b[22m\u001b[0m) at misaki.core$compile_STAR_$fn__1112 / \u001b[1minvoke\u001b[22m (\u001b[31mcore.clj\u001b[0m:\u001b[ 31m\u001b[1m160\u001b[22m\u001b[0m) at misaki.util.sequence$some_with_default_value / \u001b[1minvoke\u001b[22m (\u001b[31mseque nce.clj\u001b[0m:\u001b[31m\u001b[1m44\u001b[22m\u001b[0m) at misaki.core$compile_STAR_ / \u001b[1minvoke\u001b[22m (\u001b[31mcore.clj\u001b[0m:\u001b[31m\u001b[1m16 7\u001b[22m\u001b[0m) at misaki.core$call_all_compile / \u001b[1minvoke\u001b[22m (\u001b[31mcore.clj\u001b[0m:\u001b[31m\u001b[1 m185\u001b[22m\u001b[0m) at misaki.server$do_all_compile / \u001b[1minvoke\u001b[22m (\u001b[31mserver.clj\u001b[0m:\u001b[31m\u001b [1m52\u001b[22m\u001b[0m) at misaki.server$_main / \u001b[1mdoInvoke\u001b[22m (\u001b[31mserver.clj\u001b[0m:\u001b[31m\u001b[1m91\u001b[ 22m\u001b[0m) \u001b[31mFAIL in 0.500 sec\u001b[0m * Finish Compiling * starting server: \u001b[36mhttp://localhost:8080/\u001b[0m 2013-05-04 01:01:50.673:INFO:oejs.Server:jetty-7.6.1.v20120215 2013-05-04 01:01:53.766:INFO:oejs.AbstractConnector:Started SelectChannelConnect or@0.0.0.0:8080 Cygwinで動作させても同様です (ただし、Windows版のOracleJavaなのでOpenJDKをCygwin上で動かせばもしかしたら動くかもです)。 miki@miki-PC ~/dev/misaki $ lein-cyg run samples/blog * Compiling all templates * Compiling atom.xml.clj java.io.FileNotFoundException: samples\\blog\\public\\samples\\blog\\template\\atom.xml (指定されたパスが見つかりません。) at misaki.util.file$write_file / invoke (file.clj:152) at misaki.compiler.default.core$compile_STAR_ / invoke (core.clj:237) at misaki.compiler.default.core$compile_template / invoke (core.clj:256) at misaki.compiler.default.core$_compile$fn__1874 / invoke (core.clj:70) at misaki.compiler.default.core$_compile / invoke (core.clj:58) at misaki.core$call_compiler_fn / doInvoke (core.clj:55) at misaki.core$compile_STAR_$fn__1112 / invoke (core.clj:160) at misaki.util.sequence$some_with_default_value / invoke (sequence.clj:44) at misaki.core$compile_STAR_ / invoke (core.clj:167) at misaki.core$call_all_compile / invoke (core.clj:185) at misaki.server$do_all_compile / invoke (server.clj:52) at misaki.server$_main / doInvoke (server.clj:91) FAIL in 0.300 sec * Finish Compiling * starting server: http://localhost:8080/ 2013-05-04 01:17:16.365:INFO:oejs.Server:jetty-7.6.1.v20120215 2013-05-04 01:17:16.411:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:8080 付焼き刃な対処ですが、下記の修正でひとまず動作します。 $ git diff diff --git a/src/misaki/config.clj b/src/misaki/config.clj index 9d4b69e..7dcd9c7 100644 --- a/src/misaki/config.clj +++ b/src/misaki/config.clj @@ -137,7 +137,7 @@ \u0026#34;Check whether file is post file or not.\u0026#34; [#^File file] {:pre [(file? file)]} - (and (:post-dir *config*) (str-contains? (.getAbsolutePath file) + (and (:post-dir *config*) (str-contains? (str/replace (.getAbsolutePath file) #\u0026#34;\\\\\u0026#34; \u0026#34;/\u0026#34;) (:post-dir *config*)))) ; =index-file? @@ -209,7 +209,7 @@ (defn- make-regular-output-filename \u0026#34;Make regular output filename from java.io.File.\u0026#34; [#^File file] - (let [path (.getPath file) + (let [path (str/replace (.getPath file) #\u0026#34;\\\\\u0026#34; \u0026#34;/\u0026#34;) len (count (:template-dir *config*))] (if (.startsWith path (:template-dir *config*)) (.substring path len) JavaはWrite Once Run Anywhereを謳ってはいるものの、このようにパスまわりのトラブルが結構あっていつも悩まさせてくれます。。。この問題は結構影響範囲が大きそうなので、修正される可能性は低いかもしれません。 本当はこの不具合は結構前に気づいていたのですが、 PullRequestの方法を良く知らないのと、もうちょっと内容を調査したり整理してからのほうがいいかなと思っていたら Issue に登録されていたのでブログでまとめてみた次第です。 動作環境 OS Windows 7 Professional 64bit Java C:\\Users\\miki\\dev\\misaki\u0026gt;java -version java version \u0026#34;1.7.0_09\u0026#34; Java(TM) SE Runtime Environment (build 1.7.0_09-b05) Java HotSpot(TM) 64-Bit Server VM (build 23.5-b02, mixed mode) leiningen C:\\Users\\miki\\dev\\misaki\u0026gt;lein -v Leiningen 2.1.3 on Java 1.7.0_09 Java HotSpot(TM) 64-Bit Server VM"
},
{
url: "https://zarudama.github.io/tags/misaki/",
title: "misaki",
date: "2019-11-08T20:34:00+09:00",
body: "misaki"
},
{
url: "https://zarudama.github.io/tags/stack/",
title: "stack",
date: "2019-11-08T20:34:00+09:00",
body: "stack"
},
{
url: "https://zarudama.github.io/tags/emacs/",
title: "emacs",
date: "2019-11-08T20:31:00+09:00",
body: "emacs"
},
{
url: "https://zarudama.github.io/post/2013/05/emacs_window_image_disp/",
title: "windows版emacs24.3で画像を表示する。",
date: "2019-11-08T20:31:00+09:00",
body: "windows版emacs24.3で画像を表示する。 \u0026#30446;\u0026#27425; 参考 Windows版Emacsにおいて、image-diredなどで画像が表示されない場合、下記の方法で表示できる。 F1 v dynamic-library-alist で必要なdllを調べる。 表示されたdllをググッてダウンロードする。 PATHの通った場所へdllを置く。 自分の場合pngが表示されなかったので libpng14-14.dll が表示されたのでこれをググり、下記サイトからダウンロードした。 http://www.gtk.org/download/win32.php emacsを再起動後、 zlib1.dll がないと怒られたので、これもダウンロードして配置。 emacsを再起動し、 M-x image-dired でpng画像を開いたところ無事表示できた。 あとはgifやjpegあたりも同様の手順で準備すればとりあえず困らないだろう。 emacs(Windows版)で画像を表示している様子 w3mでakb48を検索してみた。 参考 http://qiita.com/items/dc621c568a294004f5a2 http://stackoverflow.com/questions/2650041/emacs-under-windows-and-png-files"
},
{
url: "https://zarudama.github.io/tags/processing/",
title: "processing",
date: "2019-11-08T20:25:00+09:00",
body: "processing"
},
{
url: "https://zarudama.github.io/post/2013/08/ubuntu_xmonad_emacs_processing/",
title: "ubuntuでxmonadして、emacsでProcessingしてます",
date: "2019-11-08T20:25:00+09:00",
body: "ubuntuでxmonadして、emacsでProcessingしてます \u0026#30446;\u0026#27425; processing のおすすめポイント processingは実はjavaである。 インストールが超簡単。 複数のプラットホームに対応している。 HTMLモード、androidモードがある。 emacsでprocessing xmonadでprocessing 最近Processingをいじり始めました。 \u0026#22259;1: Ubuntu上のXmonadでemacs使ってProcessingしてるところ 上の画像は、Ubuntu上のXmonadでemacs使ってProcessingしてるところです。非常に快適です。 ちょろっと作った テストプログラム Javascriptモードで出力しました。こんなのが簡単に作れます。 日経LinuxでProcessingの連載をしていたので興味があったのですが、きちんと読んでいませんでした(今読みかえしているところです)。最大のきっかけとなったのは下記の本を手にしたからです。 \u0026rdquo;\u0026gt;\u0026rdquo; \u0026gt;\u0026rdquo; /\u0026gt; この本はゲームプログラミングはおろかプログラミングそのものが初めてという人のための本です。事実、本の帯には「猫でも13歳でもわかる」みたいなことが書いてあります(笑)。実際本の内容は懇切丁寧に書かれており、猫は無理でも中学生ならゲームが作れそうです。 初心者向けの本とはいえその内容は広範囲で、基本の2Dプログラミング、アイデアの出しかた、データの作成、Andoroidアプリの公開方法、3Dプログラミング、そしてなんとキネクトプログラミングまでやってます。自分はプログラミング初心者ではないですが、Processingをざっと勉強したいという経験者にもうってつけだと思います。 特にいいなと思ったのは、プログラマの最大の敵であるゲーム素材のつくり方まで解説してある点です。プログラマは大抵絵心がなかったりするので、絵や音の素材を用意するのが苦手だと思うのですが、この本はデータ作成にも多くのページを割いて解説しています。また、本は分厚いですがそれぞれの章の独立生が割と高いので興味のあるところから読むってのもありかもです。 processing のおすすめポイント processingは実はjavaである。 文法はほとんどJavaなので実はしっかりした言語体系です。自分は最初、Processingという独自のスクリプト言語があるものと勘ちがいしていました。でも実は、Processingという独自の言語があるわけではなく、Java言語をProcessingというIDEを通して簡単に始められるというものでした。実際Processingでは普通にArrayListが使えますしジェネリクスも使えます。 Processingをイメージで簡単に説明すると、「Processingという巨大なクラスがあって、このメソッドがグローバルな関数に見立てたAPIとなっていて、PDEという独自IDEによってあたかもグローバル関数や変数を簡単に定義できるようになっている。 PDEのおかげで、javaのパスとかメインクラスの作成とか面倒なことを考えずすぐに再生ボタンで実行できる環境」ってことになります (間違ってたらすみません)。なのでJavaを実際に始める前にProcessingから入るというのは非常に有効な手段かと思います。 インストールが超簡単。 ダウンロードして展開するだけです。Java実行環境は同梱されてるので別途インストールする必要がありません。 複数のプラットホームに対応している。 作ったプログラムは、Linux, Mac, Windows向けにエクスポートできます。出力されたものにJava実行環境も含まれているので配布先に別途Javaをインストールしてもらう必要もありません。 HTMLモード、androidモードがある。 昔のver1.5のころは、エクスポート方法としてアプレットがあったのですが、これはjavascriptに置きかわりました。 JavaAppletはいろいろ問題があるのでこの変更は嬉しいですね。 AndroidのエクスポートもSDKを別途ダウンロードする必要はあるものの非常に簡単にAndroidでプログラムを動かせます。 結局、サポートプラットホームは、Linux、Mac、Windwos、Android、そしてJavascriptになります (ただし最近のゲームライブラリはどれもこの辺サポートしてるのでアピールポイントにはなりにくくなってますね)。問題は各モードでどこまで差異なく実行できるかですが、この辺はまだ検証できてません。 でも活動が活発なので期待です。 emacsでprocessing emacsからもProcessingを使えます。下記を参考にしました。 http://hoshi-sano.hatenablog.com/entry/2013/08/03/121526 MELPAに登録されているのでインスールも簡単です。 C-c C-p C-r で実行できますし、エラーがあれば M-g M-n で簡単ジャンプできます。あとは javascript モードも対応してくれるといいな。 xmonadでprocessing 最後にXmonadでProcessingする方法を書いておきます。 Xmonad上では、JavaのSwingがまともに動かないみたいなので、 Processingするにはxmonadの設定ファイルを修正する必要があります。 ~/.xmonad/xmonad.hs ファイルのlogHookを下記のように XMonad.Hooks.ICCCMFocus をインポートして、 logHook の右辺を takeTopFocus に置き換えます。 import XMonad.Hooks.ICCCMFocus : main = do : xmonad $ defaultConfig : , logHook = takeTopFocus : 意味はわかってません。。。下記のURLを参考にしました。 http://www.willprice.org/about.html"
},
{
url: "https://zarudama.github.io/post/2012/05/ubuntu_install/",
title: "Ubuntu Server インストール時に前回作ったLVMが削除できなかった。",
date: "2019-11-08T20:23:00+09:00",
body: "Ubuntu Server インストール時に前回作ったLVMが削除できなかった。 Ubuntu Serverをインストールし直したとき、前回作ったLVMを再構成しようとしたら VGやLVMが削除できなくて先に進めなくなった。 この状態を回避するには、 まず ALT+F2 でコンソールを切り替える。 Ubuntu Serverでは仮想コンソールが複数立ちあがっていて、 ALT + F1 - F4 で切り替えられるのだ。 まず、論理ボリュームを削除し、その後、ボリュームグループを削除する。 $ lvremove /dev/{ボリュームグループ}/{論理ボリューム} $ vgremove /dev/{ボリュームグループ} で削除できる。この時、swap領域に割り当てたものが削除できない場合があるがその時は、いったんインストール作業を中断してやり直せばよい。"
},
{
url: "https://zarudama.github.io/tags/tmux/",
title: "tmux",
date: "2019-11-08T20:18:00+09:00",
body: "tmux"
},
{
url: "https://zarudama.github.io/post/2012/02/tmux_session/",
title: "tmux セッションの保存方法",
date: "2019-11-08T20:18:00+09:00",
body: "tmux セッションの保存方法 \u0026#30446;\u0026#27425; その他参考にしたもの 下記を参考に.bashrcにSSH_AUTH_SOCKを固定にする方法で解決した。 http://www.gcd.org/blog/2006/09/100/ agent=\u0026#34;$HOME/tmp/ssh-agent-$USER\u0026#34; if [ -S \u0026#34;$SSH_AUTH_SOCK\u0026#34; ]; then case $SSH_AUTH_SOCK in /tmp/*/agent.[0-9]*) ln -snf \u0026#34;$SSH_AUTH_SOCK\u0026#34; $agent \u0026amp;\u0026amp; export SSH_AUTH_SOCK=$agent esac elif [ -S $agent ]; then export SSH_AUTH_SOCK=$agent else echo \u0026#34;no ssh-agent\u0026#34; fi testコマンドのSオプションは以下のとおり。 -S FILE FILE exists and is a socket やっていることは、直接参照する$SSH_AUTH_SOCKは固定のパスにしてしまい、ログインごとに変わるUNIXドメインソケットはシンボリックリンクで指し示すようにしている。 その他参考にしたもの http://hibari.2ch.net/test/read.cgi/unix/1268778432/ 84 ：名無しさん＠お腹いっぱい。：2010/11/02(火) 15:34:12 screenと違って、アタッチ時に環境変数SSH_AUTH_SOCKを新しい値に更新してくれるのは 嬉しいんだけど、それが実際シェルに反映されるのは、新しいシェルを追加した時だけだよね？ デタッチ前から動いてるシェルのSSH_AUTH_SOCKを自動的に更新する事って出来る？ 87 ：名無しさん＠お腹いっぱい。：2010/11/21(日) 07:31:25 \u0026gt;\u0026gt;84 シェル側の適当なフックで、親プロセスの環境変数を調べるとか。 88 ：名無しさん＠お腹いっぱい。：2010/11/24(水) 16:56:11 \u0026gt;\u0026gt;84 こんなのしてる： sc() { if [ -n \u0026#34;$TMUX\u0026#34; ]; then unset $(tmux show-env | sed -n \u0026#39;s/^-//p\u0026#39;) eval export $(tmux show-env | sed -n \u0026#39;s/$/\u0026#34;/; s/=/=\u0026#34;/p\u0026#39;) else tmux -u start \\; attach \\; $@; fi } これでとにかくscって打てばアタッチするし、アタッチ済なら アタッチ前シェルの環境を取り込んでくる。 show-envはshow-environmentのエイリアスで、-で始まる環境変数はシステムから削除されたものらしい。 # \u0026#34;-\u0026#34;のついている（tmuxにより削除された環境変数）をクリア unset $(tmux show-env | sed -n \u0026#39;s/^-//p\u0026#39;) # 環境変数の再定義 eval export $(tmux show-env | sed -n \u0026#39;s/$/\u0026#34;/; s/=/=\u0026#34;/p\u0026#39;)"
},
{
url: "https://zarudama.github.io/tags/clojure/",
title: "clojure",
date: "2019-11-08T20:17:00+09:00",
body: "clojure"
},
{
url: "https://zarudama.github.io/post/2012/09/clojure_swank_repl/",
title: "swank-clojureの後継モジュールのnREPLを試してみた",
date: "2019-11-08T20:17:00+09:00",
body: "swank-clojureの後継モジュールのnREPLを試してみた いつのまにかswank-clojureが非推奨になり、代わりにnREPLというものが推奨されていた。 https://github.com/technomancy/swank-clojure This project is no longer under active development. New users are strongly encouraged to try out nrepl.el instead. If you need an advanced debugger, Ritz might be a better fit. 超意訳。「swank-clojureは全然活動してないから、新規のユーザはnrepl.elを強く推奨する。もしイケテるデバッガが欲しいならRitzがいいかもYO!。」 ということで、el-getでレシピに下記を追加して nrepl.el をインストール。 (:name nrepl :type github :pkgname \u0026#34;kingtim/nrepl.el\u0026#34; ) で lein2.0 で適当にプロジェクトをつくって、 project.clj に下記を追加。 :dependencies [[org.clojure/clojure \u0026#34;1.4.0\u0026#34;] [org.clojure/tools.nrepl \u0026#34;0.2.0-beta9\u0026#34; ]] 最後に M-x nrepl-jack-in すると、nREPL-Server が起動して、nREPLが起動する。 キーバインドはほとんどSLIMEと同様だし、SLIMEの下記の特徴も実現してるので、これは本格的に移行できる雰囲気。 シンボルの補完(TABで補完できる) 関数の引数表示(シンボルを打ちこむとミニバッファに自動表示) ただSLIMEを常用してきたわけではないので足りない機能もまだありそうだけど。たとえば、 REPL上でエラーが発生してもデバッガが起動しない(例外が表示されるだけ) nREPLとは直接関係ないけど、auto-complte.elに対応するモジュール(ac-slime)がない。 HyperSpecのようなドキュメントシステムは？(doc関数ががあるからいらないか) ちなみに下記の記事を読むと、nREPL開発に至る経緯がある。 http://technomancy.us/163 clojureでSLIMEを使用する場合、最新のバージョンだと動かなかったりするので、環境構築に苦労したけど、専用のSLIME代替モジュールができたおかげで環境構築が楽になりますな。 nREPLは、まだまだできたばかりのプロジェクトだけれども、 SLIMEの呪縛から解き放たれた期待のプロジェクト。積極的に使っていきたい。"
},
{
url: "https://zarudama.github.io/tags/linux/",
title: "linux",
date: "2019-11-08T20:16:00+09:00",
body: "linux"
},
{
url: "https://zarudama.github.io/tags/sudo/",
title: "sudo",
date: "2019-11-08T20:16:00+09:00",
body: "sudo"
},
{
url: "https://zarudama.github.io/post/2012/03/sudo_env_variable/",
title: "sudoで環境変数を引き継ぎたい",
date: "2019-11-08T20:16:00+09:00",
body: "sudoで環境変数を引き継ぎたい \u0026#30446;\u0026#27425; 方法 経過 別解 sudo でコマンドを実行する際、今現在のログインアカウントの環境変数を引き継いで実行したい。 方法 -Eオプションを追加する。 sudo -E ls -la $HOME -Eは実行したいコマンドの直前に置く。 経過 sudo -u hogeなどで実行すると、sudoを実行したユーザの環境変数が引き継がれない。昔は、こんなこと考えずに引き継がれてた気がするが、どうやらsudoのバージョンが上がって仕様変更されたらしい。 http://arika.org/2009/04/24/sudo-and-env 環境変数を引き継ぐためにはvisudoを使ってsudoersファイルに環境変数を記述するのが定石のようだが、/etc配下はできるだけ触りたくない。 そこで下記の方法を見つけた。-Eをつけるだけで良いらしい。 http://d.hatena.ne.jp/Yudoufu/20110326/1301129885 ただし、man sudo しても-Eオプションは何故か載っていなかった。（manにないだけで実際には使用できる。) manの最後にver1.6.6とあるのでマニュアルが古いと思われる。 sudo[Enter]で表示されるUsageにはEオプションは存在するので。 別解 -u オプションを使用して別ユーザーとしてsudoを実行したい場合、そのユーザーの .bashrc や /etc/profile に定義してある設定を使用したい場合がある。そんなときは、-i オプションを使用すれば良い。 sudo -u taro -i env"
},
{
url: "https://zarudama.github.io/post/2012/03/skk_windows/",
title: "SKKを導入してみる(WindowsXP)",
date: "2019-11-08T20:14:00+09:00",
body: "SKKを導入してみる(WindowsXP) \u0026#30446;\u0026#27425; corvus-SKK 「;」によるStickyShiftを実現する方法 SKK日本語入力FEP wceSKKServ google-ime-skk xp環境でのインストール 去年からemacs上の日本語入力にはDDSKKを使い続けているのですが、 emacsの外の世界ではgooglIME(or MOZC)を使用していました。滅多に外の世界で活動しないため、別にこれで不自由はなかったのですが、ふと最近のWindwosSKK界隈を調べてみると、今までskkime 一択だったのにクライアントが増えてます!。。。ということでいくつか検証してみて最終的に下記の組み合わせを使用することにしました。快適!快適ー! corvus-SKK(IME) wceSKKServ(辞書サーバー) google-ime-skk(辞書サーバー) ということで以下に調べた内容をメモしておきます。 corvus-SKK 最近できたらしいWindows用のFEP 辞書が独自形式 取り込みボタンを押したタイミングで辞書が独自形式に変換されるので、これは逆に長所になった。 emacs側のユーザー辞書を直接指定しても別ファイルになるので、クライアント単位で競合せずにすむ。 サーバーがひとつしか使えない wceSKKServであれば、複数の辞書を扱えるので問題なし トリガキーが「M-漢字キー」しかうけつけておらず、「漢字」キーのみでない 独自のサーバ(corvuserv)を使用しているが、まだ完成度が低そう。 StickyShiftが使える! Windows XPのテキストサービスフレームワーク(TSF)が不安定なため、XPでの利用はあまり推奨されない。 「;」によるStickyShiftを実現する方法 設定画面で[位置] タブで下記の設定を施す。 開始：; 代替：なし 送り：なし SKK日本語入力FEP 軽快な動作を目的とした比較的新しいWindows版SKK。 Windowsアプリを使いやすくするための独自機能が特徴。 SKK-IME1.5改 と同じ作者であり基本理念が引き継がれている。 WindowsXPのテキストサービスフレームワーク(TSF)が不安定なため、XPでの利用はあまり推奨されない。 WindowsXPで使用する場合は、SKK-IME1.5改を使用したほうが良い。 wceSKKServ wceSKKServというサーバーを使って、ddskkと辞書の共有を図る。 wceSKKServで使用する辞書は、euc-jpしか受付ない模様。 サーバにはユーザ辞書は指定できない。 従って、ddskkで育てた辞書をskkIMEでも利用するということはできない。 どうしてもしたい場合は、コピーしたものを使う。 例えばスタートアップでユーザー辞書をコピーするとか。 サーバを使うメリットとしては、以下がある。 linux環境において辞書を共用することでメモリの節約 予めサーバーとして立ちあげておくことで、起動がスムーズになる サーバー側に複数の辞書を登録することで、クライアント側では、そのサーバーをひとつ設定するだけで複数の辞書を指定したことになり、設定が楽になる。 google-ime-skk 最近は、GoogleIMEが流行っているので、SKKをこのまま使い続けていいのか若干気の迷いがありましたが、 Google-IME-SKKの存在を知ってその不安もなくなりました。なぜなら、SKKからGoogleの辞書が使えるからです。この辞書のおかげで、ネットで話題の言葉とかも簡単に変換可能だし、ローカルの辞書でヒットしなかった場合でも大抵googleIMEが拾ってくれます。 また、Linux上のGoogleIMEであるMOZCの場合、確かネットのデータは反映されないのですが、このサーバを使えば、その問題も解決します。スバラシス! xp環境でのインストール gemを入れてから下記でインストールする。 dos\u0026gt; gem install google-ime-skk dos\u0026gt; gem install json 下記のようなバッチファイルを作ってスタートアップに登録しておく。「gskk.bat」 google-ime-skk.bat あとは下記に接続すればok。 localhost:55100 コンソールが表示されるのが嫌という向きもあるだろうが自分の場合は、あとでログが見れたほうが嬉しいことが多いのでそのままにしている。 また、バーチャルデスクトップ(WinDeskwide)を使っているので不要なウィンドウは全部そっちに集めてスッキリできるので問題ない。"
},
{
url: "https://zarudama.github.io/tags/skk/",
title: "skk",
date: "2019-11-08T20:14:00+09:00",
body: "skk"
},
{
url: "https://zarudama.github.io/post/2013/01/python_window_tiler_use/",
title: "python window tiler を試す",
date: "2019-11-08T20:12:00+09:00",
body: "python window tiler を試す この記事 にxmonadがでてきたので、自分が普段使っているWindowsでもタイル型マネージャを使いたくなった。実は以前にも何度か試したことがあったが、どれもキーバインドが好みでなかったり動作が不安定だったりで、いまいち納得のいくものがなかったので、使っていなかったのだ。でもその時から大分時間も経ってるので、最近は何かないかなと調べたところPythonで実装されたその名もずばり「Python-windows-tiler」というものを見つけた。 https://github.com/Tzbob/python-windows-tiler http://d.hatena.ne.jp/uhiaha888/20121125/1353824257 使用方法は簡単で、バイナリを解凍してPWT.exeを実行するだけだが、パスに日本語を含むとエラーになるのでルートに解凍するのが良いと思う。 キーバインディングはAwesomeなどと似ている。ただ、Altキーを使用するので Emacsとキーバインディングが被ってしまうのでconfig.iniを開き、altを全て winにしてPWT.exeを再起動した。 これでとりあえずEmacsとのキーバインディングの回避ができた。めでたしめでたし、と思ったのだが、Win+Lキーでウィンドウの横幅を広げようとしたらロック画面になってしまう。。。 てことでWin+Lを無効化する方法を模索したけど、結局どれもうまくいかなかったので横幅操作は封印することにした。てか、Winを使用するコンビネーションキーはどれもWindowsに奪われてしまってうまくイカナイ。。。とはいえ、Win キー経由でタイル操作はとても使いやすい。多様する操作はこれ。 Win+SPC ウィンドウレイアウトの変更 Win+j, Win+k ALT+TABの代りになる Win+S+Ent プライマリの切替 Win+数字キー 仮想デスクトップの切替 Win+S+数字キー カレントアプリを仮想デスクトップへ移動 特にWin+j,kがイイ! 自宅のUbuntu環境ではStumpWMを使用していたが、これはEmacserにはなじみのあるキー操作なんだけど(Screen系のプリフィックスキーのあるやつ)、それが逆に操作の混乱を生んでしまう。というのもの、自分の場合デスクトップの emacsでは windows.el を使用し、端末ではtmuxを使用してるので、タイル型ウィンドウマネージャのキーバインドにプレフィックスを使用すると混乱するのだ。それにデスクトップのウィンドウ操作はできるだけすばやくしたいので Screen系のStumpWMよりAwesome系のほうがサクサク操作できる。以上から自分にはAwesome系の操作体系のほうが向いているような気がした。 ということで、Ubuntuではxmonadをもう一度使ってみようと思う。"
},
{
url: "https://zarudama.github.io/tags/cygwin/",
title: "cygwin",
date: "2019-11-08T20:10:00+09:00",
body: "cygwin"
},
{
url: "https://zarudama.github.io/post/2012/08/putty_cygwin_terminal/",
title: "puttyをやめて、cygwin Terminalにする",
date: "2019-11-08T20:10:00+09:00",
body: "puttyをやめて、cygwin Terminalにする puttyベースのminntyがいつのまにcygwinに完全統合されて、 Cygwin Terminal というアプリになっていたので「putty + pagent」の組み合わせをやめて、 Cygwin Terminal と ssh-agent を組みあわせてCygwinだけで SSH接続を実現することにした。 その際、screenを導入することにした。screenを導入することによって、起動の高速化はもちろん、ssh-agentプロセスの共有化ができるので、その都度鍵の設定をする必要がなくなるからだ。 導入は簡単。 $ apt-cyg install screen 次に設定ファイル。 defencoding utf8 escape ^z^z startup_message off vbell off hardstatus alwayslastline \u0026#34;%w\u0026#34; で端末を利用するときは次の手順で。 $ ssh-agent bash $ ssh-add ~/.ssh/id_dsa $ ssh-add -l # 確認 $ screen $ ssh -A HOST ssh-agentを起動してから、screenすることで毎回ssh-agent とssh-addをする必要がなくなる。 あとは必要に応じて、 C-z c で仮想端末を追加すれば良い。これで、 Cygwin Terminal で疑似マルチターミナルが実現できた!"
},
{
url: "https://zarudama.github.io/post/2013/02/emacs_org_paragraph/",
title: "org-modeの段落の改行を削除したい",
date: "2019-11-08T20:07:00+09:00",
body: "org-modeの段落の改行を削除したい 当ブログは、o-blog で運営していて、org-modeで原稿を書いています。その際、頻繁に fill-paragraph(M-q) を使用するのですが、これが org-export-as-html すると都合が悪いのです。 どう都合が悪いかというと、段落の文のなかに半角スペースが紛れこんでしまうのです。 例をあげると 今日はいい 天気ですね! これは、HTMLエクスポートすると \u0026lt;p\u0026gt;今日はいい 天気ですね!\u0026lt;/p\u0026gt; となるので、ブラウザ上では 今日はいい 天気ですね! となり、文の途中に空白文字が挿入されてしまいます。 これはHTMLの仕様なので、変更するのはムズかしそうです。 cssなりorg-modeなりで「pタグの改行は空白にしない」オプションがあればいいのですが、ざっと見たかぎり見つかりませんでした。1 まあしょうがないので、これからは fill-paragraph(M-q) を使用せず、 1行ごとに改行することにします。 今日はいい天気ですね! そうですね。 これはこうなる。 今日はいい天気ですね!そうですね。 わかち書きが基本の英語圈でできた仕様だからしかたないのだろうけど、日本語の文章を書くときは不便だなあ。\r[return]"
},
{
url: "https://zarudama.github.io/post/2013/09/nexus7/",
title: "Nexus7(2013)にBUNKER RINGを装着する!",
date: "2019-11-08T20:04:00+09:00",
body: "Nexus7(2013)にBUNKER RINGを装着する! 主に電子書籍の閲覧に利用していたNexus7ですが、先日新型のNexus7(2013)を購入しました。正常進化したこのモデル、「これはすごい!」という驚きは少ないですが、サクサク動きますし、画面も綺麗で快適です。快適さが自然すぎて逆に感動が少ないって感じです。もう旧式には戻れません。 さてタブレットを使っていく上で大抵の人は、なんらかのカバーを装着すると思います。裸のままだとまず持ちずらいですし、何より落したときの衝撃が怖いですよね。ただしカバーを装着するとすごくかさばります。もともと薄くて軽いNexus7ですが重くて厚いカバーなどを装着したらせっかくのスリムな本体が台無しです。 ですからできるだけかさばらずに本体落下のリスクを抑えるアイテムが欲しい。できることならカバーなしでなんとかしたい。一見矛盾しているこの欲求を満してくれるのがBUNKER RINGです。 指輪のようなリングを直接本体に貼り付けて使います。旧式ではこれを購入して利用していました。 カバーなしなので、落したときの衝撃が怖いのですが BUNKER RINGのおかげでまず落しませんし、かさばって毎日いらいらするのに比べたらこのスッキリ感は手放せません。 で、当然Nexus7(2013)でもBUKER RING を同時購入して装着したのですがこれがうまくいかない。 新型は、裏面が旧型に比べてツルツルしていて、一見旧型より吸いつきが良いように見えるのですが、なぜか簡単にはがれてしまうのです。旧型はそんなことなかったのに! なので裸運用は諦めて、カバーごしにBUNKER RINGを装着することにしました。 できるだけ薄くて本体デザインに影響がでないやつがいい。そこでamazonで良さそうなものを物色して手にいれたのがこれ! 本体に直接貼りつけてたときは、簡単に剥がれてしまったBUNKER RING ですが、このカバーに対しては、なんども貼り直したにも関わらず、がっちり貼り付きました。 新型は重量が軽くなったせいか、スタンドとして使っても割と安定しています。 ぶらぶらさせても全然平気です。 写真ではぶら下げているだけですが、両手を使ってかなり強く引っ張っても剥れる気がしませんでした。 うすーいカバーですので本体落下の衝撃には全く役立ちませんが、 BUNKER RING を貼り付けるためだけに利用するなら逆にこの薄さは利点になります。 BUNKER RING を貼りつけるのに困っているかたはどうぞ。お勧めです!"
},
{
url: "https://zarudama.github.io/tags/android/",
title: "android",
date: "2019-11-08T20:04:00+09:00",
body: "android"
},
{
url: "https://zarudama.github.io/tags/java/",
title: "java",
date: "2019-11-08T20:03:00+09:00",
body: "java"
},
{
url: "https://zarudama.github.io/post/2012/06/javap_use/",
title: "javapコマンドを使ってみた。",
date: "2019-11-08T20:03:00+09:00",
body: "javapコマンドを使ってみた。 Javaは *.java から *.class を生成するが、これはテキストエディタで閲覧できないバイナリファイルだ。これをエディタで閲覧できる状態にするには、jdkに標準搭載されているjavapコマンドを使用しすれば良い。 例えばhogeというパッケージにあるFuga.javaがあるとする。 package hoge; public class Fuga { public static void main(String[] args) { System.out.println(\u0026#34;Hello Javap!\u0026#34;); } } これをコンパイルした結果をjavapで見たい時は、以下のようなコマンドを叩けばいい。このときhoge.Fugaクラスはhoge/Fuga.lcassというディレクトリ構造になければならない。 javap -c hoge.Fuga \u0026gt; Fuga.code Fuga.codeは以下のようになる。 Compiled from \u0026#34;Fuga.java\u0026#34; public class hoge.Fuga { public hoge.Fuga(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V 4: return public static void main(java.lang.String[]); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello Javap! 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return }"
},
{
url: "https://zarudama.github.io/post/2012/05/java_comma_print/",
title: "Javaでカンマ区切りの数字を出力する。",
date: "2019-11-08T20:01:00+09:00",
body: "Javaでカンマ区切りの数字を出力する。 下記のとおり。 int value = 99999999; String.format(\u0026#34;%1$,3d円\u0026#34;, value); // =\u0026gt; 99,999,999円; この場合「%1$,3d」が書式になる。 %は書式の開始を示す。 1$は引数のインデックスを示す。ひとつの引数を使い回すときなどに必要。今回の場合はひとつなので無くても良い。 ,は区切りたい文字 3 は区切りたい桁 d は引数が数字(デシマル)を示す。"
},
{
url: "https://zarudama.github.io/post/2012/09/emacs_howm_org/",
title: "howm-modeとorg-modeを同時に使ってみたい。",
date: "2019-11-08T20:00:00+09:00",
body: "howm-modeとorg-modeを同時に使ってみたい。 \u0026#30446;\u0026#27425; やること 影響されたサイト しばらくメモ管理は、org-modeのみで運用してきた。ブログの下書きも blog.orgという1ファイルのみで運用している (これはo-blogというelispが1ファ イルのみのサポートなため。複数ファイルでの運用方法もあるかもしれないが未確認。結果、ポケットひとつの原則に従うことになりすごくやりやすい)。 しかしさすがに内容が増えてくると管理がきつくなってくるし、将来的には Clojure版JykyllのMisakiに移行したいと考えているので、そろそろhowmにも手を出してみようかなと。 howmにもリンク機能やTODO機能があるが、これらはorg-modeにもあるのでそのまま継続するとして、 howmに任せたいのはファイル管理。ファイル自体を意識せずにどんどんメモが取れる環境が理想。 やること 拡張子は.howmと.orgどちらにするか。 →howmの機能は主にファイル管理に使用する予定なのと、改宗したときに.howmだと面倒なので.orgでいく。 →howmディレクトリをつくってその配下のファイルはすべてhome-modeにしたほうがいいのかも。 →.elも.txtも.orgもすべてhowmで管理。だけどタイトルの仕切りは？ 日報をhowmでうまいこと管理したい。 →repotディレクトリとか作る？ orgのtagによるマッチ機能があれば、howmを使う必要もないかも？ 影響されたサイト Evernote vs Emacs+howm+org+Dropbox 完全同意です。evernoteは流行り始めたころは使ってましたが、 emacsとの連携がしづらいのでいつのまにか使わなくなってしまいました。 emacsだけで書上げた書籍…翔泳社「ツイッター情報収集術」のつくり方(2) 執筆環境編【増田(maskin)真樹】 すごいですね。この方のノウハウをぜひ聞いてみたいです。 My life on Emacs org-modeとhowmを同時に使用するというのはこの方の資料を拝見して初めて気づきました。 howmをサンプルプログラムと日報に活用ってところが詳しくしりたいです。 Emacs + Org-mode + howm + MobileOrg + Dropbox でテキスト管理環境を構築した MobileOrgもぜひ活用したいと思っているのですが、まだできてないですね。。。"
},
{
url: "https://zarudama.github.io/post/2013/06/emacs_helm_file_list/",
title: "helmのファイル一覧でパスを表示する",
date: "2019-11-08T19:58:00+09:00",
body: "helmのファイル一覧でパスを表示する helmをアップデートしたら、ファイルの一覧がファイル名のみになってしまい、パス部分が表示されなくなってしまった。デフォルトの挙動が変更されたようである。 自分の場合、helm-git.elを使用しているが、同じリポジトリに同名ファイルが複数あるため、ファイル名だけになると、どのディレクトリのファイルかがわからなくなってしまう。これでは困るので調査したところ、ファイル表示部分は、helm本体の helm-files.el の機能を流用しており、下記のカスタム変数を定義すればよさそうである。 (defcustom helm-ff-transformer-show-only-basename t \u0026#34;Show only basename of candidates in `helm-find-files\u0026#39;. This can be toggled at anytime from `helm-find-files\u0026#39;with \\ \\\\\u0026lt;helm-find-files-map\u0026gt;\\\\[helm-ff-run-toggle-basename].\u0026#34; :type \u0026#39;boolean :group \u0026#39;helm-files) .emacsに下記の定義をすることで無事解決できた。 (setq helm-ff-transformer-show-only-basename nil)"
},
{
url: "https://zarudama.github.io/tags/git/",
title: "git",
date: "2019-11-08T19:56:00+09:00",
body: "git"
},
{
url: "https://zarudama.github.io/post/2012/08/git_remote_branch_error/",
title: "削除したはずリモートブランチが、別のリポジトリから見ると削除されていない。",
date: "2019-11-08T19:56:00+09:00",
body: "削除したはずリモートブランチが、別のリポジトリから見ると削除されていない。 サーバー上で削除されたリモートブランチは、自動ではローカルリポジトリに反映されない仕様らしい。 http://blog.s21g.com/articles/992 なので、とあるリポジトリで削除したはずのリモートブランチが、別のリポジトリから見ると生きのこってたりする。 git remote show origin で確認できる。 $ git remote show origin * remote origin : : refs/remotes/origin/hoge-branch stale (use \u0026#39;git remote prune\u0026#39; to remove) refs/remotes/origin/fuga-branch stale (use \u0026#39;git remote prune\u0026#39; to remove) : この中で stale (use 'git remote prune' to remove) とあるのがいらないブランチだ。 stale(腐った)をplue(切り詰める)すれば良い。 まず、確認。 $ git remote prune origin --dry-run Pruning origin URL: gitolite@db72-dictwiki:wsrch * [would prune] origin/hoge-branch * [would prune] origin/fuga-branch 実行。 $ git remote prune origin もう一回確認。なにも表示されなければ多分成功している。 $ git remote prune origin --dry-run"
},
{
url: "https://zarudama.github.io/post/2013/05/firefox_sync_error/",
title: "firefox の同期不具合",
date: "2019-11-08T19:54:00+09:00",
body: "firefox の同期不具合 \u0026#30446;\u0026#27425; 追記 参考 下記のエラーが頻繁に表示される。 「接続中にエラーが発生しました: 不明なエラー。この処理は自動的に再施行されます。」 これの対処方法は、 「メニュー」→「ツール」→「オプション」→「Syncタブ」 「アカウントを管理ボタン」→「Syncをリセット」 で、もとに戻るはず。 追記 結局もとに戻らなかった。さらにいろいろ調査してみたところ、アドレスバーに下記を入力すると、 syncエラーの原因が読めることがわかった。 about:sync-log 今まで同期エラーがでると、原因を示してくれないので対処のしようがなかったのだけれど、このログをみれば詳細な情報が手にはいるので大助かり。 自分の場合、ログをみたところ、bookmark同期に原因があった模様。 1368414694893 Sync.Engine.Bookmarks DEBUG First sync, uploading all items 1368414694893 Sync.Engine.Bookmarks INFO 2 outgoing items pre-reconciliation 1368414695441 Sync.Engine.Bookmarks WARN Got exception \u0026#34;Component returned failure code: 0x80070057 (NS_ERROR_ILLEGAL_VALUE) [nsINavBookmarksService.getItemType] Stack trace: _buildGUIDMap()@resource://gre/modules/services-sync/engines/bookmarks.js:233 \u0026lt; resource://gre/modules/services-sync/engines/bookmarks.js:357 \u0026lt; _mapDupe()@resource://gre/modules/services-sync/engines/bookmarks.js:313 \u0026lt; _findDupe()@resource://gre/modules/services-sync/engines/bookmarks.js:413 \u0026lt; _reconcile()@resource://services-sync/engines.js:1120 \u0026lt; resource://services-sync/engines.js:903 \u0026lt; resource://gre/modules/services-sync/record.js:625 \u0026lt; Channel_onDataAvail()@resource://gre/modules/services-sync/resource.js:542 \u0026lt; \u0026lt;file:unknown\u0026gt;\u0026#34; building GUID map. Skipping all other incoming items. 1368414695441 Sync.Engine.Bookmarks WARN Reconciliation failed: aborting incoming processing. そこで「ツール」→「オプション」→「Sync」→「同期するデータ」から、ブックマークを外して再度同期したところ、エラーが表示されなくなった。 しかしこのままではブックマークの同期ができないのでなんとかしなくてはならない。そこで、下記の手順をとることにした。 https://account.services.mozilla.com にアクセス 左ペインの Clear Your Sync data をクリック Clear My Sync Data をクリックしてサーバー上のデータを削除 上述した方法でアカウントをリセット。そのとき、「他のすべてのデバイスのブラウザデータを、このパソコンのデータと置き換える」を選択する。 ただしこの方法は、同期もとにするPCのデータに異常がない場合に有効。 以上で同期が復活するはず。 参考 https://account.services.mozilla.com/sync/request%5Fquota http://coffeecupman.blog28.fc2.com/blog-entry-25.html"
},
{
url: "https://zarudama.github.io/post/2012/09/firefox_focus_ignore/",
title: "Firefoxでサイトを開いた時に自動フォーカスされるのを無効化する。",
date: "2019-11-08T19:52:00+09:00",
body: "Firefoxでサイトを開いた時に自動フォーカスされるのを無効化する。 Twitter,google,その他多くの検索サイトでは、ページを開くと勝手にフォーカスが移動して入力待ち状態になる。この挙動は多くの普通の人にとっては操作性が良くなるんだろうけど、FirefoxのKeysnailでキーボード操作をメインとしている自分にとっては不便極まりない。 ってことで、この挙動をどうにかするAdd-Onを探していたんだけど、なぜかなかった。 代わりにGireaseMonkey1を使った代替方法が見つかったのでそのスクリプトを使用することにした。 http://javascripter.hatenablog.com/entry/20080620/1213923411 GreaseMonkeyアドオンをインストールして、下記コードを追加すれば良い。 新規ユーザスクリプトを追加する手順は以下。 [メニュー]-\u0026gt;[ツール]-\u0026gt;[GreasMonkey]-\u0026gt;[新規ユーザースクリプト] // ==UserScript== // @name no-focus // @namespace no-focus // @version 1 // @include http* // ==/UserScript= window.addEventListener(\u0026#39;load\u0026#39;, function() { document.activeElement.blur(); this.removeEventListener(\u0026#39;load\u0026#39;, arguments.callee, false); }, false); コードの意味はよくわかってないから、問題があるかもしれないが、その場合はその時考えよう。 Greasemonkeyはchromeにも移植されているので、chromeでも利用できるかもしれない。\r[return]"
},
{
url: "https://zarudama.github.io/tags/firefox/",
title: "firefox",
date: "2019-11-08T19:52:00+09:00",
body: "firefox"
},
{
url: "https://zarudama.github.io/post/2013/03/file_open/",
title: "ファイルオープン数が上限値に達した",
date: "2019-11-08T19:51:00+09:00",
body: "ファイルオープン数が上限値に達した \u0026#30446;\u0026#27425; 確認方法 一時的な設定方法 システム全体 ユーザ毎(カレントユーザ) 恒久的な設定方法 - sysctl.conf - limits.conf - メモ CentOSで「too many files」なるエラーが多発したのでその対応策をメモしておく。 下記を参考にした。 http://thinkit.co.jp/free/tech/23/5 http://www.matsuaz.com/matsumotojs/2010/12/24/1293117835413.html 確認方法 ファイル上限値の確認コマンドは以下。 $ cat /proc/sys/fs/file-nr 1792 0 566699 左から順に 今までにオープンしたことのあるファイルの最大数 現在オープンしているファイルの総数 オープン可能なファイル数の上限 となる。 一時的な設定方法 システム全体 現状のファイルディスクリプタの上限値を確認 $ cat /proc/sys/fs/file-nr 1792 0 566699 一時的にファイルディスクリプタの上限値を変更する。 $ /sbin/sysctl -w fs.file-max = 1234567 設定値の確認 $ cat /proc/sys/fs/file-nr 1216 0 1234567 ユーザ毎(カレントユーザ) 現在のセッション(自分が起動したプロセス)に対して、ファイルディスクリプタ上限値を設定するには、 ulimit を使用する。 ulimitはユーザに対していろいろな制限を設定するコマンド。 ulimit -a で全ての設定値を確認できる。 $ ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 114688 max locked memory (kbytes, -l) 32 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 10240 cpu time (seconds, -t) unlimited max user processes (-u) 114688 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited ファイルディスクリプタの上限値を設定するには、 ulimit -n N でファイルディスクリプタ上限をN個に変更できる。 まず現状のファイルディスクリプタの上限値を確認する。 # (open filesが該当) $ ulimit -n 1024 下記は、Nを2048個にする例。 $ ulimit -n 2048 -bash: ulimit: open files: cannot modify limit: 許可されていない操作です $ sudo ulimit -n 2048 sudo: ulimit: command not found 残念ながら一般ユーザ実行すると失敗する(sudoでも実行できない)。 rootユーザで実行しなくてはならない。 $ sudo su # ulimit -n 2048 $ ulimit -n 2048 ただし直接rootになることは禁止されている環境も多いため、実質この方法は実施できない。 恒久的な設定方法 一時的な方法では、OSを再起動すると初期値に戻ってしまう。これを防ぐためには、設定ファイルに直接記述する。 設定対象のファイルは以下のとおり。 /etc/sysctl.conf システム全体のファイルオープン数 /etc/security/limits.conf アカウント毎のファイルオープン数 設定前にバックアップしておく。 sudo cp /etc/security/limits.conf /etc/security/limits.conf.orig sudo cp /etc/sysctl.conf /etc/sysctl.conf.orig sysctl.conf まず現在値を確認。 $ cat /proc/sys/fs/file-nr 1792 0 566699 sysctl.confを編集。 $ sudo vi /etc/sysctl.conf fs.file-max = 1232457 # FORMAT # fs.file-max = N :システム全体のファイルディスクリプタの上限 # kernel.threads-max = N :システム全体のプロセス数の上限 設定ファイルの内容を反映させる。 $ sudo /sbin/sysctl -p 変更を確認。 $ cat /proc/sys/fs/file-nr 1792 0 1234567 ちなみに上限値は下記でも確認できる。 $ /sbin/sysctl fs.file-max fs.file-max = 593544 limits.conf 注意点として、limits.confに設定した値は、ログインしないdameonプロセスには効かないとのこと。 http://yumewaza.yumemi.co.jp/2010/07/limitsconf.html /etc/init.d/配下から起動する場合は、その起動スクリプト内に ulimit -n を記述する必要がある。 limits.confは設定値は、ログインしたユーザのセッション内で有効になる。 $ sudo vi /etc/security/limits.conf mikio soft nofile 2048 mikio hard nofile 2048 # FORMAT # \u0026lt;USER\u0026gt; \u0026lt;soft|hard\u0026gt; \u0026lt;nofile|noproc\u0026gt; \u0026lt;設定数\u0026gt; # soft:一般ユーザが設定可能な上限値(ulimit -nのことかな？) # hard:ルートユーザが設定可能な上限値 # nofile: ファイルディスクリプタの上限値 # noproc: プロセス(スレッド)の上限値 すぐに反映させるには、一度ログアウトして、そこから対象プロセス(tomcatやapache)を再起動する。 メモ れの検証も必要 $ cat /proc/`pgrep httpd | head -1`/limits | grep \u0026#39;open files\u0026#39;"
},
{
url: "https://zarudama.github.io/post/2012/12/emacs_eshell_stack/",
title: "eshell上でリダイレクトした結果が文字化け",
date: "2019-11-08T19:47:00+09:00",
body: "eshell上でリダイレクトした結果が文字化け $ git diff \u0026gt; hoge.patch hoge.patchを開くと下記のような制御コードのまじった結果になりpatchとして使用できない。 ^[[0m^[[01;32march^[[0m ^[[01;32mcut^[[0m ^[[01;32mdoexec^[[0m ^[[01;32mgettext^[[0m ^[[01;36mksh^[[0m るびきちさんのメルマガ第3号に紹介されていたesh-myparser.elを使って以下のコマンドでおっけー。 $ b git diff \u0026gt; hoge.patch"
},
{
url: "https://zarudama.github.io/post/2012/05/emacs_swank_javascript/",
title: "emacs + SLIME + node.js + swank-js でemacsからブラウザ上のjavascriptを実行してみる",
date: "2019-11-08T19:44:00+09:00",
body: "emacs + SLIME + node.js + swank-js でemacsからブラウザ上のjavascriptを実行してみる まず、Windows版のnode.jsをインストールしておく。インストーラなので簡単。その後、npmでsocket.ioをインストール。 dos\u0026gt; npm install socket.io あとは、swank-jsをインストールする。 下記を参考にWindowsXP環境にインストールした。 http://e-arrows.sakura.ne.jp/2011/06/connect-to-nodejs-and-chrome-from-emacs.html 上記記事では、本家は更新が止っているとあるが、最近は更新を再開したっぽい。もろもろバグフィックスがされているようなのでオリジナルからswank-jsを取得した。 https://github.com/swank-js/swank-js インストール方法などは表記のとおりすればOKだが、windowsなのでうまくlnコマンドの部分がうまくいかない。回避方法としてswank-js.elはMarmaladeからインストールした。 M-x packagea-list-packages 下記を選択してixでインスール。 slime-js 0.0.1 installed Slime extension for swank-js. あとは裏でnode swank.jsを走らせて、SLIMEに接続する。 M-x slime-connect 127.0.0.1 4005 その後、repl上で接続したいURLを指定する。 ,target-url 次にブラウザ上で下記にアクセスする。 http://localhost:8009/ その後、repl上で接続する。 ,select-remote あとはrepl上で下記を実行するとlocalhost:8009上でjsが実行される。 alert (\u0026#34;hoge\u0026#34;)"
},
{
url: "https://zarudama.github.io/post/2013/01/emacs_package_elisp/",
title: ".emacsに必要なpackage を指定して自動で各種elispをインストールする",
date: "2019-11-08T19:15:00+09:00",
body: ".emacsに必要なpackage を指定して自動で各種elispをインストールする \u0026#30446;\u0026#27425; 2013/05/13 追記1: 2013/05/13 追記2: 2013/05/13 追記3: 今までパッケージ管理には el-get を使用してきたのですが、 Windows環境がメインだと git clone がうまくいかなかったり、インストール後のビルド工程が失敗したりで、なかなか難儀していたので、 el-getを辞めemacs標準の package.el をメインにすることにしました。 package.el ならば標準装備ですし、サイトリポジトリに各所のelispがダウンロードされた状態なので httpですべてインストールできるので大抵の環境でうまく動きます。 パッケージのリポジトリサイトとしては、昔はMarmaladeが更新が盛んだったのですが、最近ではMELPAがメインになってきてるようです。なので私は、MELPAメインで使用してます。 Marmaladeは無効にしています。理由は同じパッケージが同時に表示されてしまうからです。 以下は私の設定です。 (require \u0026#39;mikio-util) (when (require \u0026#39;package nil t) ;; Marmalade ;; (add-to-list \u0026#39;package-archives ;; \u0026#39;(\u0026#34;marmalade\u0026#34; . \u0026#34;http://marmalade-repo.org/packages/\u0026#34;)) ;; MELPA ;; (add-to-list \u0026#39;package-archives ;; \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;http://melpa.milkbox.net/packages/\u0026#34;) t) ;; MELPAのみにする。 (setq package-archives (list \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;http://melpa.milkbox.net/packages/\u0026#34;))) ;;インストールするディレクトリを指定 (setq my-package-directory (mikio/elisp-home \u0026#34;package\u0026#34;)) (mikio/make-directory my-package-directory) (setq package-user-dir (concat my-package-directory \u0026#34;/\u0026#34;)) ;; (package-initialize) (setq my-packages \u0026#39;(undo-tree helm auto-complete popwin smartrep color-moccur yasnippet helm-git helm-gtags helm-c-moccur helm-c-yasnippet paredit ruby-mode php-mode js2-mode web-mode nrepl nrepl-ritz ac-nrepl ;;ac-slime magit jaunte rainbow-delimiters ;; window manager by kiwanami window-layout e2wm twittering-mode ;;o-blog evil )) (require \u0026#39;cl) (mapcar (lambda (x) (when (not (package-installed-p x)) (package-install x))) my-packages) ) (provide \u0026#39;mikio-package) githubはこちら。 https://github.com/mikio/dotfiles/blob/master/emacs/mikio/mikio-package.el my-packages に自分の必要なパッケージをまとめて定義しています。 こうすることによって、環境が変わってもemacs起動時に自動的にインストールしてくれるので楽チンです。 2013/05/13 追記1: MELPAリポジトリは、常に最新のパッケージを取得してしまうためアップグレードする際は注意が必要です。 Uコマンドなどで間違ってアップグレードしてしまっても多分もとに戻せません。一方Marmaladeリポジトリの場合、 自分のローカルPCに過去のバージョンの履歴が残っている可能性があるので、ダウングレードする道があります(手順は知りませんが)。 https://github.com/emacs-jp/emacs-jp.github.com/issues/31 2013/05/13 追記2: 本文では、gitプロトコルでel-getが失敗すると書きましたが、下記の方法を試せば問題ないかもしれません(未検証)。 http://mikio.github.io/article/2013/05/03%5Fgit.html 2013/05/13 追記3: el-getも全く使用していないというわけではなく、EmacsWikiなどhttp通信するものに関しては使用しています。"
},
{
url: "https://zarudama.github.io/post/2012/12/cyginw_tmux_stack/",
title: "Emacs中毒者に贈るJDEEによるJava開発環境の構築",
date: "2019-11-08T18:01:00+09:00",
body: "Emacs中毒者に贈るJDEEによるJava開発環境の構築 \u0026#30446;\u0026#27425; 追記(2013/08/01) はじめに 必要なもの JDEEのビルド .emacsの設定 サンプルプロジェクトの準備 動作確認してみる BeanShell 依存ライブラリのダウンロード ビルドエラー importの自動挿入とビルド APIドキュメントの参照 メソッド補完 メソッド補完(Helm版) 操作方法まとめ 所感 参考URL 更新履歴 この投稿は Emacs Advent Calendar 2012 の23日目の記事です。 追記(2013/08/01) いつの間にか本家JDEEがCEDET2.0に対応していました。 emacs24.3にはCEDET2.0が最初から導入されているため、CEDETを別途導入する必要はなくなります。これによりJDEEの導入がグッっと簡単になりました。 そこで最新のemacs24.3対応ということでもう一度記事の内容を整理しました。特に理由のない限り、最新のemacsとJDEEを利用するのが良いかと思います。 また嬉しいことにJDEE(に代わるJavaの開発環境)の開発(議論)がスタートしているみたいです。今後に期待しましょう。 http://sourceforge.net/mailarchive/message.php?msg%5Fid=30783951 はじめに Java開発といえばEclipse一択なこの時代、どれだけ需要があるかわかりませんが、 Emacs中毒な皆さんはできればEclipseなんか使いたくないですよね？私は使いたくないです(笑)。私もご多分にもれず、なんでもEmacsで済ましたい人になってしまったので、当然JavaもEmacsで開発したくなります。そこでJDEEの環境を構築しようとしたのですが、 JDEEの開発は停止しているせいか、最新のEmacs23や24だとすんなり動きません。 ならばと、malabar-modeも試したのですが、Maven環境を要求してきますし、なんだか動作がもっさりな上に(JDEEより重い印象)ところどころエラーがでたりしてうまく動きません。 で、やっぱりJDEEがいいということで、苦労の末、最近やっとemacsによるJava開発環境(JDEE)が構築できたのでその方法をメモしておきます。 今回は、JDEEの導入方法しか解説しませんが、最終的な私のJava開発環境は以下のとおりです。今ところantベースのプロジェクトでしか使用しておらず、 Mavenベースのプロジェクトでは動作確認してません。 インポート文の自動生成 JDEE Javadoc表示 JDEE + w3m ビルド JDEE + ant デバッガ JDEE + jdb REPLぽいもの JDEE(BeanShell) コードスニペット Yasnippet タグジャンプ gtags(global) メソッド補完 helm-jdee-method(拙作) まだ導入したばかりで検証してないものもあります。 JDEEは「BeanShell(JavaInterpreter) + 大作Elisp拡張」という、「重い + 重い」の強力タッグです。動作速度については期待しないほうが良いです。メソッド補完については、Helmで補完するelispを自作しました。 必要なもの JDEEのビルドには下記のものが必要になります。 emacs24.3 emacsは執筆時点の最新のemacs24.3を使用しています。 JDEE-2.4.2 githubに ミラー がありますのでそちらを利用します。 CEDET CEDETは、24.3同梱のものを使用するので別途用意する必要はありません。 ant-contrib-0.6 ant-contribは、 ant側のライブラリとしてビルド時に必要です。 あとはantの最新版とJDKの最新版を用意しておきます。また環境変数 JAVA_HOME は必須です。ちなみに、elib1.0はemacs22以降から組み込みなので必要ありません。 以降では、 ~/site-lisp とういうディレクトリを作成し、そこに必要なソースコードを展開してビルドすることにします。 ~/site-lisp | +- jdee ちなみに動作確認は、windows7,windowXP,ubuntu-server上のCUI環境でしています。実際の構築は、Cygwin+WindowsXPで実施しました。LinuxもMacも大体同じかと思います。 JDEEのビルド ビルドには ant-contrib-0.6 が必要です。ant-contrib-0.6.zipを展開してできた ant-contrib-0.6.jar を ~/.ant/lib/ ディレクトリに配置しておいてください。ここでは、~/srcにソースファイル群を展開し、~/site-lisp/jdeeにインストールすことにします。 まずはJDEEモジュールを準備します。 $ cd ~/src $ git clone https://github.com/emacsmirror/jdee.git jdeeディレクトリに入り ant confugre を実行してbuild.propertiesを生成します。 $ cd jdee $ ant configure build.propertiesを編集します。 cedet.dir, build.bin.emacs を環境に合わせて編集します。 # 絶対パスで記述すること elib.dir= prefix.dir=C:/Users/mikio/Dropbox/site-lisp/jdee cedet.dir= build.bin.emacs=c:/Users/mikio/apps/emacs-24.3/bin/runemacs.exe 準備ができたらビルドします。 ant 最後に prefix.dir で定義したディレクトリにインストールします。このときインストール先のディレクトリは無くても勝手に作ってくれます。 ant install 以上で完了です。 .emacsの設定 CEDETとJDEEのビルドができたら下記の設定を.emacsに加えます。 (add-to-list \u0026#39;load-path \u0026#34;~/site-lisp/jdee/lisp\u0026#34;) (load \u0026#34;jde-autoload\u0026#34;) (defun my-jde-mode-hook () (require \u0026#39;jde) (setq jde-build-function \u0026#39;jde-ant-build) ; ビルドにantを利用する (setq jde-ant-read-target t) ; targetを問い合わせる (setq jde-ant-enable-find t) ; antに-findオプションを指定する(要らないかも) ;; complilationバッファを自動的にスクロールさせる (setq compilation-ask-about-save nil) (setq compilation-scroll-output \u0026#39;first-error) (define-key jde-mode-map (kbd \u0026#34;C-c C-v .\u0026#34;) \u0026#39;jde-complete-minibuf) ) (add-hook \u0026#39;jde-mode-hook \u0026#39;my-jde-mode-hook) サンプルプロジェクトの準備 ここまで作業できたら、動作確認してみましょう。 JDEEの動作確認用に Javaプロジェクト を準備しました。といっても私の作ったものではなくて、 java-mode-plus を作成してるskeetoさんの プロジェクト をforkしていくつか追加したものです。 fork前のプロジェクトは、アノテーションを活用してすごくシンプルに書かれた、すばらしいプロジェクトなのですが、JDEEがアノテーションをサポートしていないため、わざわざ改悪？して古いライブラリを使用して書きなおしています。あくまでJDEEの動作確認用のものなので、そのまま使用するときは注意してください。 このプロジェクトはivyを使用しています。ivyとは、antベースのプロジェクトで、 Mavenのリポジトリを利用して必要なjarをダウンロードするモジュールです。 http://ant.apache.org/ivy/download.cgi 上記サイトから最新版をダウンロードして展開したら、 ivy-2.3.0-rc1.jar を ~/.ant/lib/ に配置したらインストール完了です。 ivyのインストールが終わったら、サンプルプロジェクトを下記のようにgithubから落してください。 $ git clone https://github.com/mikio/sample-java-project.git 続いてprj.elを自分の環境に合わせて編集します。 (jde-project-file-version \u0026#34;1.0\u0026#34;) (jde-set-variables ;; -------------- ;; project common ;; -------------- \u0026#39;(jde-jdk (quote (\u0026#34;1.7\u0026#34;))) \u0026#39;(jde-jdk-registry (quote ((\u0026#34;1.7\u0026#34; . \u0026#34;c:/Program Files/Java/jdk1.7.0_09/\u0026#34;) ))) \u0026#39;(jde-jdk-doc-url \u0026#34;http://docs.oracle.com/javase/jp/6/api/\u0026#34;) \u0026#39;(jde-help-docsets \u0026#39;( ;;(\u0026#34;JDK API\u0026#34; \u0026#34;file://c:/Users/mikio/Dropbox/java6_ja_apidocs/ja/api\u0026#34; nil) (\u0026#34;JDK API\u0026#34; \u0026#34;http://docs.oracle.com/javase/jp/6/api/\u0026#34; nil) )) \u0026#39;(jde-help-use-frames nil) ;; -------------- ;; this project only ;; -------------- \u0026#39;(jde-sourcepath (quote (\u0026#34;./src\u0026#34; \u0026#34;./test\u0026#34;))) \u0026#39;(jde-global-classpath (quote (\u0026#34;./build/classes\u0026#34; \u0026#34;./build/test\u0026#34; \u0026#34;./lib\u0026#34;))) \u0026#39;(jde-lib-directory-names \u0026#39;(\u0026#34;lib\u0026#34;)) \u0026#39;(jde-expand-classpath-p t) \u0026#39;(jde-build-function (quote jde-ant-build)) \u0026#39;(jde-ant-enable-find t) \u0026#39;(jde-ant-read-target t) \u0026#39;(jde-ant-working-directory \u0026#34;./\u0026#34;)) jde-jdk 、 jde-jdk-registry をローカルの環境に合わせて編集してください。 また、今回のサンプルを使用しない場合、下記の変数を自分の環境に合わせて適宜設定すれば、どの環境でも動くかと思います。 jde-sourcepath .javaの場所 jde-global-classpath .class、.jarの場所 jde-lib-directory-names .jarのあるディレクトリの正規表現 jde-lib-directory-names には *.jar ファイルのあるディクレトリ名を設定します。今回の場合は、 {PROJECT_ROOT}/lib/ にjarファイルがあるので lib としています。また、 jde-expand-classpath-p にはtを必ず設定します。設定しないと、BeanShell起動時に *.jar ファイルがClassPathに設定されません。 動作確認してみる 続いてもろもろの動作確認をしていきます。 \u0026lt;PROJECT-ROOT\u0026gt;/src/sample/java/project/SampleJavaProject.java を開いてください。 BeanShell おもむろに、 C-c C-v C-k でBeanShellを起動します。まれにJavaファイルを開いてもJde-modeにならないことがあります。原因はわからないのですが、もしキーバインドが効かなかった場合は、手動で M-x jde-mode してから再度、 C-c C-v C-k して下さい。 BeanShellは、JDEEを使用する上でEmacsとJavaの橋渡し的な位置づけにあるようで、様々な動作の裏で動くみたいです。ただし非常に起動が重いので最初に起動しておくと良いです。起動をかけると Starting the BeanShell. Pleasewait... のメッセージがミニバッファに表示されるので、 bsh % のプロンプトがでるまで待ちます。コーヒーの一杯でも用意したほうがいいかもです(2回目移行は速い)。 BeanShellを起動しておくと、ちょっとしたAPIの挙動を調べるとき便利です。例えば環境変数 JAVA_HOME を調べるAPIの動作確認をしたい時は、 bsh % System.out.println(System.getenv().get(\u0026#34;JAVA_HOME\u0026#34;)); C:\\Program Files\\Java\\jdk1.7.0_09 という風に簡単に確認できます(いちいちSystem.out.printlnしないと結果がわからないですが)。 ちなみに、なにか動作がおかしいな(インポートやメソッドの補完が効かないなど)と思ったら、このBeanShellを再起動すれば( M-x jde-bsh-exit でBeanShellを終了できる)治ることがあります。この辺はSLIMEに似てますね。 依存ライブラリのダウンロード 続いてプロジェクトに必要なjarをリポジトリからローカルにもってきます。通常は、下記のようにコマンドラインから入力しますが、これをJDEEから操作してみましょう。 $ ant lib C-c C-v C-b でantを実行できます。ミニバッファにantのターゲットを求めるプロンプトが表示されるので C-i してください。ターゲットの一覧が表示されます。 プロンプトで lib と入力してエンターしてください。 無事成功すれば、 \u0026lt;PROJECT_ROOT\u0026gt;/lib に必要なjarファイルがダウンロードされているはずです。 $ ls -la lib total 26716 drwxr-xr-x+ 1 mikio None 0 Dec 22 11:06 . drwxr-xr-x+ 1 mikio None 0 Nov 28 23:04 .. -rwxr-xr-x 1 mikio None 74080 Jan 10 2012 annotations-2.0.0.jar : : -rwxr-xr-x 1 mikio None 124724 Nov 23 2005 xmlParserAPIs-2.6.2.jar -rwxr-xr-x 1 mikio None 108874 Nov 16 2006 xom-1.0.jar ビルドエラー つぎにビルドに失敗してエラー表示された時の挙動を試してみましょう。まず、わざとビルドを失敗させるために、ソース冒頭のimport文を全て削除します。次に、 C-c C-v C-b RET でビルドしてみてください。 当然エラーが表示されますが、エラーが表示された場合、 M-g M-n, M-g M-p ですばやくジャンプできます。 importの自動挿入とビルド import文を自動挿入するには、 C-c C-v z してください。通常は、JDEEが自動で必要なクラスをどばっと挿入してくれます。ただし今回の場合は、候補が複数あるのでCUIによる選択画面が表示されます。必要なクラスのカッコのところでRETを叩いて選択してください ( org.apache.commons で始まるものを選択してください)。最後にOKの上でRETで決定です。 import文の挿入が成功したら C-c C-v C-b でビルドプロンプトを表示し、何もターゲットを入力せずにエンターしてください。今度はビルドが成功するはずです。 APIドキュメントの参照 カーソルをStringのところに合わせて C-c C-v C-w してください。 StringクラスのJavadocがブラウザ上に開きます。 emacserなら当然w3mですよね？ローカルにダウンロードしたAPIを指定すると更に快適です。 メソッド補完 C-c C-v . でメソッドの補完ができます。 options. とピリオドまで打ったところで C-c C-v . します。 ミニバッファに [...] が表示されます。ここで C-i してください。候補が一覧表示されます。引数も含めて入力してください。適当なところで C-i しながら候補がひとつに絞りこめたところでエンターすれば、選んだメソッドを入力できます。これはこれで感動ものですが1 ・・・とっても使いづらいですね。でも安心してください。helm版を作りました。 メソッド補完(Helm版) ミニバッファでメソッドを補完する機能は確かに便利ですが、今となってはこのインターフェイスは古くさいですね。そこでこの機能をHelmで実現してみました。 helm-jdee-method.el\u0026nbsp;2 今回は時間がなかったので手動インストールですが、そのうちMELPAに登録します。 このelisp拡張はHelmとYasnippetに依存しています (導入してない方はこの機会にインストールすることをお勧めします)。まずhelm-jdee-moethod.el をロードパスのとおったところに置いて、今回設定した .emacs の my-jde-mode-hook 関数の冒頭で下記の設定をしてください。 (defun my-jde-mode-hook () (require \u0026#39;helm-jdee-method) ;; これを追加 (require \u0026#39;jde) (define-key jde-mode-map (kbd \u0026#34;C-c C-v C-i\u0026#34;) \u0026#39;helm-jdee-method) ;; これを追加 ) これで例えば、 options. とピリオドまで打ったところで C-c C-v C-i すると、メソッドの候補一覧がhelmで表示されます。 適当に選ぶとメソッドが挿入されるのですが、Yasnippetで動的にテンプレートを作成しているので、引数ごとに値を入力できます。引数を入力したらTabで移動してください。 先程のミニバッファ版に比べると、Eclipseのインテリセンス機能みたいで、なかなか便利なんじゃないでしょうか？また、自前のクラスもBeanShellを再起動すれば補完されますし、 ClassPathさえ正しく設定されてれば、AndroidSDKなんかのAPIも適切に補完してくれると思います (Androidに関して私はまだ試してません。DalvikVMなので駄目かも？)。 ちなみに補完機能をauto-completeにしなかった理由は、メソッド補完がかなり高コストだからです。これを自動でやると、とてももっさりになってしまうので、ユーザが必要なときに「よっこらしょ」って感じで利用することを想定しました。 操作方法まとめ ここまでの機能の操作方法をまとめました。 メソッドの補完 C-c C-v . メソッドの補完(Helm) C-c C-v C-i ビルド(ant) C-c C-v C-b BeanShell起動 C-c C-v C-k BeanShell終了 M-x jde-bsh-exit prj.elの再読込 M-x jde-load-project-file 自動import C-c C-v z javadocの表示 C-c C-v C-w これだけでも大分便利に使えるのではと思います。 これに加えて、デバッガの起動やJunitのファイル単位の実行などが使えれば更に便利だと思いますが、自分はまだ試していません。 また、これらJDEEの基本機能に加えて、私は、AutoComplete, Yasnippet,Gtagsなどを導入しており、かなり快適に使えてます3flymakeも試したのですが、動作が重いのでいまのところ常用してません。 所感 ここまで紹介しておいてなんですが、JDEEは現在では開発が停止してます。そのため新しい文法はサポートされてません(アノテーション、ジェネリクス、拡張for文など)。特にアノテーションを利用したJavaコードだと、Import文などはうまく補完できなかったりします。個人的には再開を願っているのですが、全然その気配がありません。。。そんなJDEEとは対象的にCEDETの開発は盛んで、JAVAの対応も結構進んでいるようです (メーリングリストでよく話題をみかけます)。なので将来的には、JDEEをやめてCEDETメインの環境に移行するかもしれません。 以上、長文をここまで読んで頂いてありがとうございました。 参考URL JDEEインストールしてからの設定とか下記のサイトが大変参考になった。 http://epian-wiki.appspot.com/wiki/Emacs/JDEE 操作方法はメニューを開けば大体わかる。詳しくは以下のサイトが詳しい。 http://www.02.246.ne.jp/~torutk/jdee/jdee.html 割と最近のMLのやりとり。 http://sourceforge.net/mailarchive/message.php?msg%5Fid=28645729 更新履歴 2013/01/15 jde-lib-directory-names の説明が間違っていたため、修正しました。失礼しました。 2013/08/01 本家JDEEがCEDET2.0に対応したので記事も併せて修正しました。 JDEE紹介サイトの多くが、メソッド補完のスクリーンショットにGUIメニュー版を載せていたので、CUIではメソッド補完は使えないものと勘違いしてました。\r[return] すみません、anything版は作成してません。要望があれば対応するかもです。\r[return] Yasnippetはnekopさんの定義した Javaのやつ を利用しています。ありがとうございます。\r[return]"
},
{
url: "https://zarudama.github.io/post/2013/01/cyginw_tmux_stack/",
title: "cygwin経由で表示したtmuxの分割罫線が表示崩れする",
date: "2019-11-08T17:38:00+09:00",
body: "cygwin経由で表示したtmuxの分割罫線が表示崩れする 最初Cygwinのバージョンが古いからかなと思ってバージョンアップしても改善せず、ならばとtmuxのバージョンを最新にしても直らず、結局cyg-terminalのオプションでTextの設定を下記のように変更したら、表示崩れが解消した。 変更前 Locale:JA_jp CharacterSet:UTF-8 変更後 Locale:C CharacterSet:UTF-8"
},
{
url: "https://zarudama.github.io/post/2012/08/cyginw_svn_stack/",
title: "cygwinでsvn upgradeに失敗する。",
date: "2019-11-08T17:34:00+09:00",
body: "cygwinでsvn upgradeに失敗する。 本格的にcygwinをputty代替として使っていく気になったので、Subversionに関してもTortoiseSVNからcygwin版のSubversionを使用することにした。 apt-cyg install subversion インストール後、今まで使用していたリポジトリで svn status を実行したら、upgradeしろと言われたのでしてみたところ、下記のエラーが。 $ svn upgrade svn: E200029: Couldn\u0026#39;t perform atomic initialization svn: E200030: SQLite compiled for 3.7.13, but running with 3.7.3 ぐぐってみたところ、TortoiseSVNがSQLite3を使用しているのが原因のようだったので、TortoiseSVNを削除してらリトライ。でも変化せず。 $ sqlite3 SQLite header and source version mismatch 2010-10-08 02:34:02 2677848087c9c090efb17c1893e77d6136a9111d 2012-06-11 02:05:22 f5b5a13f7394dc143aa136f1d4faba6839eaa6dc ソースと実行ファイルでバージョンの不一致がおこっている模様。でもソースからビルドした記憶はないんだけどなぜだろう。よくわからないので、 apt-cyg find sqlite3 して関連するパッケージを調べて全て削除した。 $ apt-cyg remove libsqlite3-devel libsqlite3_0 odbc-sqlite3 sqlite3 sqlite3-debuginfo Removing libsqlite3-devel Package libsqlite3-devel removed Removing libsqlite3_0 Package libsqlite3_0 removed Package odbc-sqlite3 is not installed, skipping Removing sqlite3 Package sqlite3 removed そして、再インストール。 $ apt-cyg install sqlite3 今度はうまくいった。 $ svn upgrade Upgraded \u0026#39;*************\u0026#39; Upgraded \u0026#39;*************\u0026#39; ："
},
{
url: "https://zarudama.github.io/post/2012/12/cyginw_ssh_stack/",
title: "cygwinでssh接続できない",
date: "2019-11-08T17:32:00+09:00",
body: "cygwinでssh接続できない \u0026#30446;\u0026#27425; まとめ /home/mikio にホームを設定してるのではなく、 c:/Users/mikio にHOMEを設定してる場合でssh接続すると、下記のように /home/mikio ディレクトリが作成できないと怒られてしまう。 $ ssh -v 192.168.10.2 -p 30890 -i ~/.ssh/id_rsa.whitebase OpenSSH_6.1p1, OpenSSL 1.0.1c 10 May 2012 debug1: Connecting to 192.168.10.2 [192.168.10.2] port 30890. debug1: Connection established. Could not create directory \u0026#39;/home/mikio/.ssh\u0026#39;. この場合は、 /etc/passwd の /home/mikio となってるところを、 /cygdrive/c/Users/mikio に書き換えれば良い。 http://ekawas.blogspot.jp/2007/03/solving-pesky-ssh-issues-in-cygwin.html しかし今度はpublickeyがパーミッションエラー。 debug1: Authentications that can continue: publickey debug1: Next authentication method: publickey debug1: Trying private key: /cygdrive/c/Users/miki/.ssh/id_rsa.whitabase debug1: No more authentication methods to try. Permission denied (publickey). 下記よるとホスト側で /etc/ssh/sshd_config の設定でユーザを許可してないのが原因とあったので調べたところドンピシャでした。 http://lunatear.net/archives/000300.html 早速編集して再起動したところ、まだ駄目。 # AllowUsersにユーザを追加 $ sudo vi /etc/ssh/sshd_config # 再起動 $ sudo /etc/init.d/ssh restart ： debug1: SSH2_MSG_SERVICE_ACCEPT received debug1: Authentications that can continue: publickey debug1: Next authentication method: publickey debug1: Trying private key: /cygdrive/c/Users/miki/.ssh/id_rsa.whitabase debug1: No more authentication methods to try. Permission denied (publickey). 接続ホスト側でログを確認してみる。 /etc/ssh/sshd_config を編集 SyslogFacility AUTH LogLevel VERBOSE$ sudo tail -f /var/log/auth.log : Dec 1 21:54:00 whitebase sshd[20701]: Set /proc/self/oom_score_adj to 0 Dec 1 21:54:00 whitebase sshd[20701]: Connection from 192.168.10.229 port 64522 Dec 1 21:54:01 whitebase sshd[20701]: Connection closed by 192.168.10.229 [preauth] : \u0026hellip;ログをみてもよくわからなかった。 今度は、サーバー側でもデバッグモードにして接続してみる。 mikio@whitebase:~/.ssh$ whereis sshd sshd: /usr/sbin/sshd /usr/share/man/man8/sshd.8.gz mikio@whitebase:~/.ssh$ sudo /usr/sbin/sshd -d debug1: sshd version OpenSSH_5.9p1 Debian-5ubuntu1 debug1: read PEM private key done: type RSA debug1: Checking blacklist file /usr/share/ssh/blacklist.RSA-2048 debug1: Checking blacklist file /etc/ssh/blacklist.RSA-2048 debug1: private host key: #0 type 1 RSA debug1: read PEM private key done: type DSA debug1: Checking blacklist file /usr/share/ssh/blacklist.DSA-1024 debug1: Checking blacklist file /etc/ssh/blacklist.DSA-1024 debug1: private host key: #1 type 2 DSA debug1: read PEM private key done: type ECDSA debug1: Checking blacklist file /usr/share/ssh/blacklist.ECDSA-256 debug1: Checking blacklist file /etc/ssh/blacklist.ECDSA-256 debug1: private host key: #2 type 3 ECDSA debug1: rexec_argv[0]=\u0026#39;/usr/sbin/sshd\u0026#39; debug1: rexec_argv[1]=\u0026#39;-d\u0026#39; Set /proc/self/oom_score_adj from 0 to -1000 debug1: Bind to port 30890 on 0.0.0.0. Server listening on 0.0.0.0 port 30890. debug1: Bind to port 30890 on ::. Server listening on :: port 30890. debug1: Server will not fork when running in debugging mode. debug1: rexec start in 5 out 5 newsock 5 pipe -1 sock 8 debug1: inetd sockets after dupping: 3, 3 Connection from 192.168.10.229 port 64488 debug1: Client protocol version 2.0; client software version OpenSSH_6.1 debug1: match: OpenSSH_6.1 pat OpenSSH* debug1: Enabling compatibility mode for protocol 2.0 debug1: Local version string SSH-2.0-OpenSSH_5.9p1 Debian-5ubuntu1 debug1: permanently_set_uid: 105/65534 [preauth] debug1: list_hostkey_types: ssh-rsa,ssh-dss,ecdsa-sha2-nistp256 [preauth] debug1: SSH2_MSG_KEXINIT sent [preauth] debug1: SSH2_MSG_KEXINIT received [preauth] debug1: kex: client-\u0026gt;server aes128-ctr hmac-md5 none [preauth] debug1: kex: server-\u0026gt;client aes128-ctr hmac-md5 none [preauth] debug1: expecting SSH2_MSG_KEX_ECDH_INIT [preauth] debug1: SSH2_MSG_NEWKEYS sent [preauth] debug1: expecting SSH2_MSG_NEWKEYS [preauth] debug1: SSH2_MSG_NEWKEYS received [preauth] debug1: KEX done [preauth] debug1: userauth-request for user mikio service ssh-connection method none [preauth] debug1: attempt 0 failures 0 [preauth] debug1: PAM: initializing for \u0026#34;mikio\u0026#34; debug1: PAM: setting PAM_RHOST to \u0026#34;miki-pc.lan\u0026#34; debug1: PAM: setting PAM_TTY to \u0026#34;ssh\u0026#34; Connection closed by 192.168.10.229 [preauth] debug1: do_cleanup [preauth] debug1: monitor_read_log: child log fd closed debug1: do_cleanup debug1: PAM: cleanup うーん、よくわからん。 今度は、クライアント側のデバッグログの出力レベルをあげて試す。 (vの数がレベルになる。知らなかった。) $ ssh -vvv whitebase : : debug1: Next authentication method: publickey debug1: Trying private key: /cygdrive/c/Users/miki/.ssh/id_rsa.whitabase debug3: no such identity: /cygdrive/c/Users/miki/.ssh/id_rsa.whitabase debug2: we did not send a packet, disable method debug1: No more authentication methods to try. Permission denied (publickey). おおおお!、なんという初歩的ミス!。 .ssh/config の秘密鍵の名前をタイポ。 - IdentityFile ~/.ssh/id_rsa.whitabase + IdentityFile ~/.ssh/id_rsa.whitebase これで無事接続できました。 まとめ パーミッションを疑え! $HOME -\u0026gt; 700 $HOME/.ssh -\u0026gt; 700 $HOME/.ssh/id_rsa -\u0026gt; 644 サーバ側の $HOME/.ssh/authorized_keys -\u0026gt; 644 ログイン許可してるユーザを確認しろ! サーバ側の /etc/ssh/sshd_config の AllowUsers クライアント側のログを確認しろ! ssh -v HOSTNAME vオプションの数でデバッグレベルを調節できる! ssh -v HOSTNAME ssh -vv HOSTNAME ssh -vvv HOSTNAME サーバ側のログを確認しろ! サーバ側の /etc/ssh/sshd_config SyslogFacility AUTH LogLevel VERBOSE sudo tail -f /var/log/auth.log /usr/sbin/sshd -d $HOME/.ssh/config のタイポを確認しろ! 以上で大体解決すると思います。"
},
{
url: "https://zarudama.github.io/post/2011/11/clojure_game/",
title: "Clojureでゲームプログラミングその1 実験編",
date: "2019-11-08T17:26:00+09:00",
body: "Clojureでゲームプログラミングその1 実験編 \u0026#30446;\u0026#27425; はじめに ウィンドウ表示 画像表示 位置調整 画像の一部を表示したい メインループの実現 画像の移動 ちらつき防止対策 所感 参考書籍 はじめに LispでGAMEつくろうかなと。最初CommonLispでつくろうかなと思ったけども、現時点でCommonLispとClojure(+Java)を比較したときに後者のほうが詳しいかなということで、まずはClojureでつくってみて、落ち着いたらCommonLispでもつくってみようかなと。 とりあえず、下記の流れで、画像を表示して動かすところまでチャレンジしてみる。 ウィンドウ表示 画像表示 メインループの実現 画像移動 もちろん前回インストールしたSLIMEとLeiningenを使って作業しますよ。ちなみにClojureで「もの」を作るのは初めてなので、ホント手探りです。しかもClojureでGameプログラミングの情報ってほとんどないんだよな。さて。 ウィンドウ表示 ClojureでのGUIはさっぱりわからんけども、とりあえずJavaのサンプルとかを頼りにウィンドウを表示してみる。 (import (javax.swing JFrame)) (def frame (JFrame. \u0026#34;Clojure SampleGame\u0026#34;)) (doto frame (.setSize 640 480) (.setVisible true)) でた。簡単すぎる！結構感動します。 \u0026#22259;1: 初めてのウィンドウ表示! 次は画像を表示してみる。 画像表示 まずは、画像ファイルの読み込みだ。下記のコードをclojureで動かしてみる。 java.awt.image.BufferedImage bimage; image = javax.imageio.ImageIO.read(new java.io.File(\u0026#34;hoge.png\u0026#34;)); 下記の画像を表示してみる。これは昔作ったゲームで使用したものでアニメーションパターンもはいってる。 \u0026#22259;2: スプライトパターン 画像ファイルはプロジェクト直下においてある（REPLを起動したディレクトリ)。外部ファイルはプロジェクトルートからの相対パスでOKのようである。 (import (java.awt.image BufferedImage)) (import (javax.imageio ImageIO)) (import (java.io File)) (def image (ImageIO/read (File. \u0026#34;gai.png\u0026#34;))) とりあえずうまく読み込めたっぽいので、ウィンドウに表示してみる。 (import (java.awt Graphics)) (def graphics (.. frame (getGraphics))) (doto graphics (.drawImage image 0 0 frame)) でた！ \u0026#22259;3: スプライトの表示 線もかけたよ。 (.. graphics (drawLine 0 0 640 480)) \u0026#22259;4: いろいろ試す ところでこれまでの画像表示はタイトルバーにめり込んでしまっている。これは描画命令の座標原点が、ウィンドウそのもの左上を原点としているためである。これを回避するには、Graphics#translateを呼び出す。 位置調整 ずれの原因であるタイトルバーや枠お情報は、java.awt.Insetsとういクラスに格納されている。これはJframe#getInsetsメソッドで取得でいるので、束縛しておく。 (def insets (.. frame getInsets)) 確認。それっぽい値が入っている。 user\u0026gt; insets #\u0026lt;Insets java.awt.Insets[top=24,left=1,bottom=5,right=1]\u0026gt; では、このinsetsを使って描画用原点をずらしてみる。 (.. frame (setVisible true)) (.. graphics (translate (.. insets left) (.. insets top))) (.. graphics (clearRect 0 0 640 480)) (.. graphics (drawImage image 0 0 frame)) \u0026#22259;5: 原点をずらしたところ これで左上原点が、ずれていい具合に表示された。 insentsを利用したついでに説明。実はウィンドウサイズで640x480を指定しているけれども、タイトルバーや枠のサイズがあるため、描画領域は640x480よりもちょっと小さい。なので、例えば640x480ちょうどのサイズの画像を表示しようとしても少し切れてしまったりする。ということで、insentsを利用して描画領域が純粋に640x480似なるように調整する。 (doto frame (.setSize (+ 640 (.. insets left) (.. insets right)) (+ 480 (.. insets top) (.. insets bottom))) (.setVisible true)) 以上で描画領域の細かい調整が完了した。 画像の一部を表示したい ところで、現状だとアニメパターンがすべて表示されていてみっともないので一部だけを表示したい。この要件を満たすには、Graphics#DrawImageで下記のように引数を指定すれば良い。 (.drawImage image ;; 描画画像 0 0 ;; 転送先の左上座標 32 32 ;; 転送先の右下座標 0 0 ;; 画像元の左上座標 32 32 ;; 画像元の右下座標 frame) ;; 描画対象(import java.awt.Color) (def clear-color (Color. 0 0 127)) (let [g (.. frame (getGraphics))] (doto g (.translate (.. insets left) (.. insets top)) (.setColor clear-color) (.fillRect 0 0 640 480) (.drawImage image 0 0 32 32 0 0 32 32 frame) (.dispose))) \u0026#22259;6: 毎フレーム画像をクリア なんども描画してると、前の画像が残って確認しづらいので描画前にクリアカラーで塗りつぶしている。ついでにグラフィックオブジェクトもその都度破棄するようにした。 つぎはゲームのかなめ、メインループを実現してみる。 メインループの実現 メインループの実現方法にはにはいろいろあけれどもとりあえず動かすことが目的なので、実装が簡単そうなjava.util.TimerTaskを使用してみる。 Clojureで継承が必要なJavaクラスを使うには、proxyを使う。以下のようにTimerTaskを継承したクラスをつくる。 (import (java.util Timer TimerTask)) (import (java.util TimerTask)) (def mainloop (proxy [TimerTask] [] (run [] (println \u0026#34;呼びだされた\u0026#34;)) )) テストしてみる。 user\u0026gt; (.. mainloop run) 呼びだされた nil うまくいっているようである。 続いてTimeクラスにmainloopを渡してみる。これがはまった。 user\u0026gt; (.. (Timer.) schedule mainloop 0 500) Malformed member expression [Thrown class java.lang.IllegalArgumentException] Restarts: 0: [QUIT] Quit to the SLIME top level Backtrace: 0: clojure.lang.Compiler$HostExpr$Parser.parse(Compiler.java:825) 1: clojure.lang.Compiler.analyzeSeq(Compiler.java:5369) 「Malformed member expression」の原因がわからなくてかなりはまった。ぐぐった結果、javaのlong型を引数として渡すときは、long関数を呼び出す必要があることがわかった。 user\u0026gt; (.. (Timer.) schedule mainloop (long 0) (long 500)) No matching field found: schedule for class java.util.Timer [Thrown class java.lang.IllegalArgumentException] Restarts: 0: [QUIT] Quit to the SLIME top level Backtrace: 0: clojure.lang.Reflector.getInstanceField(Reflector.java:245) 1: clojure.lang.Reflector.invokeNoArgInstanceMember(Reflector.java:267) とここでまたエラー。でまたぐぐった結果、メソッドの呼び出し方が間違っていたorz。 scheduleをカッコでくくらないと駄目らしい。 user\u0026gt; (.. (Timer.) (schedule mainloop (long 0) (long 500))) 呼びだされた 呼びだされた 呼びだされた 呼びだされた 呼びだされた 呼びだされた 呼びだされた 呼びだされた 呼びだされた 呼びだされた 呼びだされた 呼びだされた 呼びだされた 呼びだされた 呼びだされた nil ということでやっとTimerクラスにTimerタスクで作ったメインループを渡すことができた。ふぅ。次は画像を動かしてみる。 画像の移動 いよいよ画像に魂を与えるw。その為には状態を管理しなければならない。座標だ。 Clojureはデフォルトでは値を更新できない。これを変更するためには特別な定義が必要。スレッドを使う予定は今のところ無いので、扱いの簡単そうなatomを使用してみる。 ;; プレイヤー定義 (def player (atom {:pos [0 0]})) こんな感じで参照できる。 user\u0026gt; (@player :pos) [0 0] user\u0026gt; x座標は配列の0番目 user\u0026gt; (nth (@player :pos) 0) 0 y座標は配列の1番目 user\u0026gt; (nth (@player :pos) 1) 0 playerの座標を更新してみる。 user\u0026gt; player #\u0026lt;Atom@2a134eca: {:pos [0 0]}\u0026gt; ;; 変更 user\u0026gt; (swap! player assoc :pos [0 1]) {:pos [0 1]} ;; たしかに更新された user\u0026gt; player #\u0026lt;Atom@2a134eca: {:pos [0 1]}\u0026gt; x座標を更新させる user\u0026gt; (swap! player assoc :pos [(+ 1 (nth (@player :pos) 0)) 1]) {:pos [1 1]} user\u0026gt; (swap! player assoc :pos [(+ 1 (nth (@player :pos) 0)) 1]) {:pos [2 1]} user\u0026gt; (swap! player assoc :pos [(+ 1 (nth (@player :pos) 0)) 1]) {:pos [3 1]} user\u0026gt; (swap! player assoc :pos [(+ 1 (nth (@player :pos) 0)) 1]) {:pos [4 1]} ではここまでの移動処理を組み込む。 (def mainloop (proxy [TimerTask] [] (run [] (swap! player assoc :pos [(+ 1 (nth (@player :pos) 0)) 1]) ;; 座標更新 (if (\u0026lt; 640 (nth (@player :pos) 0)) (swap! player assoc :pos [0 0])) (let [g (.. frame (getGraphics)) player-x (nth (@player :pos) 0) player-y (nth (@player :pos) 1)] (doto g (.translate (.. insets left) (.. insets top)) (.setColor clear-color) (.fillRect 0 0 640 480) (.drawImage image player-x player-y (+ player-x 32) (+ player-y 32) 0 0 32 32 frame) (.dispose)))))) 定義したメインループを20ms間隔で呼び出す。 (.. (Timer.) (schedule mainloop (long 0) (long 20))) \" frameborder=\"0\" allowfullscreen 画面がちらつきというか、画像が点滅していて話にならない。次はこのチラツキを抑えるために java.awt.image.BufferStrategyを使ってみる。 ちらつき防止対策 下記のようにJFrame#setIgnoreRepaint, JFrame#createBufferStrategyを呼び出しバッファの準備をする。この時注意すべきは、JFrame#createBufferStrategyはJFrame#setVisibleのあとに呼び出さなければならないこと。 (doto frame (.setSize (+ 640 (.. insets left) (.. insets right)) (+ 480 (.. insets top) (.. insets bottom))) (.setVisible true) (.setIgnoreRepaint true) ;; ウィンドウの再描画を無効に(BufferStrategyを使うので) (.createBufferStrategy 2) ;; setVisibleメソッドのあとで呼ばないと実行時エラーになる ) ;; バッファ作成 (def buffer (.. frame (getBufferStrategy))) bufferを使って以下のように呼び出し。TimerTaskクラスオブジェクトは都度生成できるように関数化しておいた。 (defn create-mainloop [] (proxy [TimerTask] [] (run [] (swap! player assoc :pos [(+ 1 (nth (@player :pos) 0)) 1]) ;; 座標更新 (if (\u0026lt; 640 (nth (@player :pos) 0)) (swap! player assoc :pos [0 0])) (if (not (.. buffer (contentsLost))) (let [g (.. buffer (getDrawGraphics)) player-x (nth (@player :pos) 0) player-y (nth (@player :pos) 1)] (doto g (.translate (.. insets left) (.. insets top)) (.setColor clear-color) (.fillRect 0 0 640 480) (.translate (.. insets left) (.. insets top)) (.drawImage image player-x player-y (+ player-x 32) (+ player-y 32) 0 0 32 32 frame) (.dispose)) (.. buffer (show)) ))))) \" frameborder=\"0\" allowfullscreen 最終的なコード。 (ns hello-cube.core) (import (javax.swing JFrame)) (import (java.util Timer TimerTask)) (import (java.awt Graphics Color)) (import (java.awt.image BufferedImage)) (import (javax.imageio ImageIO)) (import (java.io File)) (def clear-color (Color. 0 0 127)) (def frame (JFrame. \u0026#34;Clojure Sample Game\u0026#34;)) (def image (ImageIO/read (File. \u0026#34;gai.png\u0026#34;))) ;; 画像読み込み (def player (atom {:pos [0 0]})) ;; 枠を考慮してサイズ指定 (doto frame (.setVisible true) (.setIgnoreRepaint true) ;; ウィンドウの再描画を無効に(BufferStrategyを使うので) (.createBufferStrategy 2) ;; setVisibleメソッドのあとで呼ばないと実行時エラーになる ) ;; バッファ作成 (def buffer (.. frame (getBufferStrategy))) (def insets (.. frame getInsets)) ;; ウィンドウを表示してから出ないと値が入らない。 (doto frame (.setSize (+ 640 (.. insets left) (.. insets right)) (+ 480 (.. insets top) (.. insets bottom)))) (defn create-mainloop [] (proxy [TimerTask] [] (run [] (swap! player assoc :pos [(+ 1 (nth (@player :pos) 0)) 1]) ;; 座標更新 (if (\u0026lt; 640 (nth (@player :pos) 0)) (swap! player assoc :pos [0 0])) (if (not (.. buffer (contentsLost))) (let [g (.. buffer (getDrawGraphics)) player-x (nth (@player :pos) 0) player-y (nth (@player :pos) 1)] (doto g (.translate (.. insets left) (.. insets top)) (.setColor clear-color) (.fillRect 0 0 640 480) (.translate (.. insets left) (.. insets top)) (.drawImage image player-x player-y (+ player-x 32) (+ player-y 32) 0 0 32 32 frame) (.dispose)) (.. buffer (show)) ))))) (def timer (Timer.)) (.. timer (schedule (create-mainloop) (long 0) (long 20))) 所感 ほとんどJavaのメソッドしか使ってないけどもSLIMEの良さは体感できた。コードが即時反映されて画像が動くのは楽しい。理想はSLIME上からGameObjectをリアルタイムに操作することだけど、これを実現するにはatomでは無理かも。あとはスレッドとSLIMEの関係がよくわかってない。TimerTaskを使いにくく感じたのでメインループは別の方法で実現したい。 次回はもうちょっとコードのリファクタリングを施しつつ、アニメーションとキーボード操作をできるようにしてみる。 参考書籍 \"\"\" \"\"\""
},
{
url: "https://zarudama.github.io/tags/game/",
title: "game",
date: "2019-11-08T17:26:00+09:00",
body: "game"
},
{
url: "https://zarudama.github.io/post/2014/05/uim_skk/",
title: "uim-skkでsticky-shiftを実現する",
date: "2019-11-08T17:23:00+09:00",
body: "uim-skkでsticky-shiftを実現する Ubuntuを13.04から14.04にアップグレードしました。 Ubuntu界隈では、IMEがIBus1.5になり使いにくいと大荒れのようです。 IBus1.5では、IMEを切り替えるとキーボードの配置まで変わるらしく、特に英語キーボードを使ってたりするとストレスが半端ないようです。 私は、幸いにもuim-skkを使用していたので、この騒ぎを体験せずにすみました。やっぱりskkはおすすめですね。 そんな我が道をいくuim-skkですが、ひとつ問題がありました。それは、sticky-shiftの設定ができないとうことです。 私は、EmacsとWindowsのSKKFEPでは、セミコロンをSticky-Shiftとして設定しています。しかし、uim-skkには、設定ダイアログにそのような項目が見当たりません。公式ドキュメントには、対応したとはあるのですが、具体的な設定方法が見当りません。 https://code.google.com/p/uim-doc-ja/wiki/RequestUimSolved#sticky%5Fshift%E3%82%92%E4%BD%BF%E3%81%84%E3%81%9F%E3%81%84 2chに質問したりもしたのですが、特に反応もなく放置されたままでした。 http://anago.2ch.net/test/read.cgi/software/1328329402/197 それでもやはりなんとかしたいと思い、 改めてドキュメントを読んでみると、 ~/.uim という設定ファイルの詳しい記述方法がありました。最初からもっと読んでおくべきでしたね。。。 https://code.google.com/p/uim-doc-ja/wiki/CustomizeUim そこで、そこの説明に載っているソース( /usr/share/uim/ )をgrepしてみると、それらしきカスタム変数が定義されていたのです。さっそく見よう見まねで ~/.uim を定義してみました。 (require-module \u0026#34;skk\u0026#34;) (define-key skk-sticky-key? \u0026#39;(\u0026#34;;\u0026#34;)) これでバッチリセミコロンでSticky-Shiftできました! uim-skkを使用している人はぜひ試してみてください。快適さが全然ちがいますよ。 以下わかったことをまとめておきます。 基本は、GUIの設定ダイアログで設定する。 それで設定できないものは、 ~/.uim にSchemeで設定ファイルを記述する。 ダイアログとかぶる設定は、 ~/.uim が優先される。 端末を開き、uim-shを打ち込めば、uimのschemeのREPLが起動する。 (exit)で終了。 \u0026#22259;1: uim-shを起動したところ Schemeで設定できる UIM ってやっぱカッコいいな。"
},
{
url: "https://zarudama.github.io/post/2014/03/tokyo_clojure/",
title: "tokyo.clj#19に参加してきた。",
date: "2019-11-08T17:21:00+09:00",
body: "tokyo.clj#19に参加してきた。 鉄は熱いうちに打てということで、帰宅直後のいまのうちに書いておきます。 3年ぶりにtokyo.cljに参加してきました。その前の日にはsaitama.cljにも参加してきました。この2日間で得られた知見をメモしておきます。 引数は、なんでもmapにするのがおすすめらしい。 変数がないからといってletを使ってはいけないことはない。 むしろ自己説明的なコードとしてどんどん使うべき。 Luminus は結構よさげ(とある洋書 で推されてるとのこと) noirとLightTableとkormaとVisualStudioは全部おなじ作者 ベテランのすごいエンジニアからも注目されているClojure(どんな人かはここでは言えませんが) 会社経営者からも注目されているClojure(技術に強い会社をつくりたいとのこと) asyncを使った Dots というスマホゲームのClojureScriptの移植版があるらしい。 ゲームをつくるときの状態管理のひとつの実装例として、ゲーム内のすべての状態をひとつのatomで定義しておく。 4clojure は良い でも全部解く必要はない Clojureをつかって機能拡張したいからエディタ作ってますというemacserが二人もいたこと! 自分もClojureでemacs的なエディタをぼんやりと作りたいなーと思ってた。 WebViewを使ったエディタが最近のトレンド？(Atom, LightTable, ねこはる氏の自作エディタなどなど) 以外とClojureでゲームをつくりたいという需要があること やっぱりみんな英語が得意、少なくとも情報を得るために海外サイトは見ている。 Clojureをおしゃれな言語にして女子受けをよくして、ゆくゆくは アイドル を生みだそう! 5月下旬にはClojureの入門本がでる 次回のtokyo.cljはサイン会!(重要) 勘ちがいとかあるかもしれまんせんがこんな感じ。ライトニングトークの内容はあとで追いかけおようと思います。 やはり勉強会は懇親会が重要なんだなと思った次第です。なにより普段ひとりでClojureコード書くので実際にリアルでClojureの話をできたのはよかったですね。 自分は長らく初級者だと思ってたんですが、今日いざコードを書いてみようとおもったら普通に括弧mapとか括弧ifとか打ってて、「あれ、これはもう初級者じゃなくね？」と思ったのでした。あ、でもこれは、EmacsLispの影響かもしれません。というか、Clojureのスキルはほとんどないです。それでもこのブログは、Clojure製のブログジェネレータ で書いてます。なにが言いたいかというと、みんなClojureやりましょうです。LightTable とかおすすめです。 最後に、勉強会を開催主導してくれたスタッフの皆様、お疲れさまでした。"
},
{
url: "https://zarudama.github.io/tags/keyboard/",
title: "keyboard",
date: "2019-11-08T17:19:00+09:00",
body: "keyboard"
},
{
url: "https://zarudama.github.io/tags/thinkpad/",
title: "thinkpad",
date: "2019-11-08T17:19:00+09:00",
body: "thinkpad"
},
{
url: "https://zarudama.github.io/post/2014/01/keyboard/",
title: "キーボードについて",
date: "2019-11-08T17:19:00+09:00",
body: "キーボードについて 自分はまだThinkpadを持っていないんですが、将来的にThinkPad(X1Carbon)を使いたいと思っていました。そこでここ数ヶ月は、会社のデスクトップで Thinkpadのトラックポイントキーボード を使用していました。 しかし先日ThinkpadX1Carbonが5列配列になった と知り、大変衝撃を受けました。ファンクションキーは、オフィス系アプリで頻繁に使いますし、ブラウザや開発ツールなどでもよく使用する利用頻度の高いキーです。これを外すなんてありえません。1 さらに下記の不満が日頃から溜まっていました。 HOME、ENDと矢印キーが離れすぎていて使いずらい(このストレスが一番大きい)。 F5とF4,F12の後ろなどに隙間がないため、ファンクションキーが押しにくい。 ドリフト現象(指が触れていないのに勝手にカーソルが動いていしまう)が頻繁おきる。 トラックポイントを使ったスクロールがうまくいかないアプリがたまにある。 トラックポイントによるスクロールを一番良く使うChromeでスクロールができなくなった(Chrome更新による不具合)。 結構ドライバ依存なところがあり、ubuntuできちんと動いてくれるか不安 などです。 トラックポイント自体は非常に使いやすいのですが、上に挙げた不満を帳消しにするほどの利点ではないということで、結局いつものキーボードに戻りました。 今回の件でわかったことは、自分は、HOME,ENDと矢印キーの配置が非常に重要で、この配置以外は受けいれられないんだなということでした。 \u0026#22259;1: この配置じゃないと指が受けつけない。 たぶんこの配置を満たしているノートPCはなくて、そういう意味ではどんなノートでもいいのかもしれません。 次期ノートからは、Thinkpadは選択肢から外し、 VAIO Proあたりを検討しようと思います。 昔、HappyHakkingキーボードを使ってましたが、ファンクションキーがないのが馴染めませんでした。\r[return]"
},
{
url: "https://zarudama.github.io/post/2014/01/misaki_clojure_2/",
title: "Emacsのorg-modeでBlogを書ける「Misaki org-mode」を書いた",
date: "2019-11-08T17:16:00+09:00",
body: "Emacsのorg-modeでBlogを書ける「Misaki org-mode」を書いた \u0026#30446;\u0026#27425; 参考 年末から地味につくっていた Misaki のプラグインですが、ひととおり欲しい機能の実装を終えたので、github公開しました。 Emacs org-mode で記事を書けるBlogジェネレータです。 https://github.com/mikio/misaki-orgmode デモ org-modeのBlogジェネレータは以外と少ないので選択肢が増えたと思います (Misaki-orgmodeは、Blogに特化しているわけではないので、静的サイトジェネレータとしても使えます)。 Misaki をベースに、記事部分(orgファイル)をemacs本体を使ってhtmlにコンパイルする方式を取っています。実装にあたっては、misaki-markdown を参考にしました(というかほぼまるパクリですが…)。 Misaki-orgmodeのロゴはイラストレータを使ってイチから作りました(ちょっとバナーが大きかったかも)。デモサイトはcssフレームワークなどを使用して用意したらよかったかもしれませんが、シンプルな構成のほうがカスタマイズの自由度が高いと考えあえて採用していません。また、このブログ自体、Misaki-orgmodeで生成しており、こちらは Pure というCSSフレームワークを使用しています。 本ブログ「ざるだましい」はもともと o-blog というツールを使用していました。このツールは大変使いやすかったのですが、1ファイルでの運用を強制されるのと、 Clojureプログラミングをしたいという理由からMisakiに乗り換えました。 現状では、Emacsによるインターフェースがないので記事ファイルが増えた場合は管理が大変ですが、ゆくゆくは下記で紹介されている org-octopress のようなツールを作りたいと思っています。 http://quickhack.net/nom/blog/2013-05-01-org-octopress.html org-modeをブログに利用していみたいかたは一考してみてください。 参考 ざるだましいのロゴに使用しているフォント http://www.hogera.com/pcb/font/catalog/"
},
{
url: "https://zarudama.github.io/post/2014/03/java_jvm_heap/",
title: "JVMのヒープサイズと変更方法",
date: "2019-11-08T17:12:00+09:00",
body: "JVMのヒープサイズと変更方法 \u0026#30446;\u0026#27425; JVMの初期ヒープサイズ JVMの稼動時のヒープサイズ ヒープサイズの変更方法 参考 稼動中のJVMのヒープサイズを知りたくなることは良くあるのでその方法。1 JVMの初期ヒープサイズ JVMは、サーバーモードで起動しているのか、クライアントモードで起動しているかで、初期割り当てのヒープサイズが異なる。 サーバーモードなのかクライアントモードなのかは、実行ユーザにて、下記コマンドで確認できる。 $ java -version java version \u0026#34;*****\u0026#34; Java(TM) SE Runtime Environment (build ******) Java HotSpot(TM) Server VM (build ******) Severモードの場合は、 Server の表記があるはず。 サーバーモード 初期ヒープサイズ マシンの物理メモリーの 1\u0026frasl;64 か、妥当な最小サイズかの大きい方。 最大ヒープサイズ 物理メモリーの 1\u0026frasl;4 か、1GB かの小さい方。 http://docs.oracle.com/javase/jp/6/technotes/guides/vm/gc-ergonomics.html JVMの稼動時のヒープサイズ JVMの使用しているヒープの量を調べる(以降、すべてOracleJava)。 $ sudo jstat -gc 28905 S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT 127552.0 137152.0 0.0 68410.3 224000.0 107742.6 996736.0 113947.3 61440.0 61324.8 7 1.323 1 0.045 1.368 割りあてられた容量を見るには、*Cのサイフィックス、使用量を見るには、*Uのサフィックスに着目する(単位はKb)。 S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT 127,552.0 137,152.0 0.0 68,410.3 224,000.0 107,742.6 996,736.0 113,947.3 61,440.0 61,324.8 7 1.323 1 0.045 1.368 容量(概算) S0C + S1C + EC + OC + PC = 127 + 137 + 224 + 996 この場合、ヒープ領域の合計は、約1,484MBとなる。 ここで注意が必要なのは、ヒープ領域はnew演算子で割りあてられる領域であるということ。 プログラムがロードされる領域であるPermanent領域は、ヒープ領域とは別に管理される場所なので注意が必要。上記の場合、Permanent領域は、PCの61MBとなる。 (Permanent領域のデフォルトサイズは、64MB) ヒープサイズの変更方法 ヒープ領域は、次のオプションで変更できる。 例) -Xms1024m -Xmx1024m 上記オプションには、プログラム格納用の領域のPermanet領域は割り当てられないので注意が必要である。 Permanet領域はデフォルトで64MBのようなので、プログラムサイズが足りないときは増やす必要がある。この値は、次のオプションで変更できる。 例) -XX:MaxPermSize=128m 参考 http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html http://www.hitachi.co.jp/Prod/comp/soft1/manual/cosmi/v0900/03Y0401D/EY040134.HTM#ID00610 http://nori3tsu.hatenablog.com/entry/2014/01/11/144927 OracleJava 1.5以降のはなし\r[return]"
},
{
url: "https://zarudama.github.io/tags/jvm/",
title: "jvm",
date: "2019-11-08T17:12:00+09:00",
body: "jvm"
},
{
url: "https://zarudama.github.io/post/2014/03/java_gc/",
title: "GCの発生頻度などの調査",
date: "2019-11-08T17:10:00+09:00",
body: "GCの発生頻度などの調査 \u0026#30446;\u0026#27425; メモリ使用量を確認したいとき GCの発生頻度を調査するためのカンペ。gclogを使用せずにお手軽に実施できる。 まずはプロセスIDを調べる。例としてtomcatの場合。 $ sudo -u tomcat jps -v tomcatユーザの起動したJavaプロセスのIDを付加情報付きで表示する。 javaプロセスがひとつしかない場合などは、下記のほうが楽かもしれない。 $ pgrep -lf java PIDが123456だった場合、3秒ごとにgcの発生状況をチェックするコマンドの例。 jstat -gcutil -t 123456 3000 意味は以下のとおり。 jstat \u0026lt;出力オプション\u0026gt; \u0026lt;プロセスID\u0026gt; \u0026lt;データ取得間隔(ms)\u0026gt; -t タイムスタンプを出力 -gcutil GCの統計情報 jstatのマニュアルは以下。 http://docs.oracle.com/javase/jp/6/technotes/tools/share/jstat.html gcutilの見出し Timestamp S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT gcutilの見出しは以下のルールになる S* Suviver E* Eden Y Young O* Old P* Permenet Permanent領域は、JVMにロードされたクラスの置き場所 F* Full *C comitted javaが確保したメモリサイズ *U used 使用済みメモリ *GC GCの回数 *GCT GCの時間 GCについては、下記が詳しい。 http://www.atmarkit.co.jp/ait/articles/0404/02/news079.html http://www.atmarkit.co.jp/ait/articles/0211/30/news002.html メモリ使用量を確認したいとき gcオプションを使えばよい。 $ sudo jstat -gc -t 12345 3000"
},
{
url: "https://zarudama.github.io/tags/find/",
title: "find",
date: "2019-11-08T17:08:00+09:00",
body: "find"
},
{
url: "https://zarudama.github.io/post/2014/03/linux_find/",
title: "特定の日付より古いファイルを削除する方法",
date: "2019-11-08T17:08:00+09:00",
body: "特定の日付より古いファイルを削除する方法 \u0026#30446;\u0026#27425; 答え 解説 ついでに日数指定の復習 timeの意味 TODO 日数の指定 参考 例えば一年以上前の3/3より前(3/2以前)のログファイルを削除したい場合。 findがすぐに思いつくが、findには日付指定のオプションが見あたらない。 答え touchでダミーファイルを作って、findのnewerオプションと否定演算子を使い、xargsとrmで削除する。 $ touch -t 201303030000 /tmp/hoge $ find /usr/local/apache/logs \\! -newer /tmp/hoge|sort|less 中身を確認して問題なさそうなら $ find /usr/local/apache/logs \\! -newer /tmp/hoge|xargs rm 解説 普通に考えると find を使って -mtime などで日数を指定する。 $ find /usr/local/apache/logs -mtime +180|wc -l 554 $ find /usr/local/apache/logs -mtime +90|wc -l 757 でも今回の要件の場合日数を計算するのが面倒なので日付を直接指定して削除したい。しかし man find してもそんなオプションはない。だが良くみるとファイルのタイムスタンプを基準にするオプション newer ならある。このオプションを使えばなんとかなりそうである。 まず下記のようにダミーのファイルを作成する。 $ touch -t 201303030000 /tmp/hoge tオプションの意味は YYYYMMDDhhmm 。詳細は man touch 参照。 で、このファイルのタイムスタンプを基準に newer を使えばよい。 $ find /usr/local/apache/logs -newer hoge|sort|less これで2013年3月3日以降に変更されたファイルを抽出できる。だが今回の場合は「指定日以前」のファイルを抽出したいのでこれでは駄目だ。 newer があるなら older オプションがありそうだが残念ながらなかった。ではどうすればいいんだと小一時間考えた結果、否定オプション ! を使えば良いことがわかった。 $ find /usr/local/apache/logs \\! -newer hoge|sort|less 否定オプションにはエスケープが必要である。 newer は指定した日を含む「以降」であり、その否定なので「以前」ではなく「前」になることに注意(当日は含まない)。 あとはこの抽出したファイルにxargsを使って適当なコマンドをあてれば良い。今回の場合は削除のrmコマンドを使った。 ついでに日数指定の復習 timeの意味 atime:アクセス日(access) ctime:ステータス変更日(chenge) mtime:ファイルを修正した日(modify)。普通はこれを使用する。 TODO 日数の指定 -mtime 4: ちょうど4日前 -mtime +4: 5日以前 -mtime -4: 3日以内 参考 http://futuremix.org/2011/01/find-newer-file-timestamp http://www.sixnine.net/roadside/find.html http://x68000.q-e-d.net/~68user/unix/pickup?find"
},
{
url: "https://zarudama.github.io/tags/evil/",
title: "evil",
date: "2019-11-08T17:05:00+09:00",
body: "evil"
},
{
url: "https://zarudama.github.io/post/2014/12/emacs_evil/",
title: "第3のエディタEvilのすすめ",
date: "2019-11-08T17:05:00+09:00",
body: "第3のエディタEvilのすすめ \u0026#30446;\u0026#27425; EmacsとVim それでもEmacsを選ぶ理由 Evilとは、Vimの操作性を備えたelisp実行環境である。 Evil-modeでVimの操作性とEmacsの拡張性を両方手に入れる! 迷ったらEvil(Emacs)。 最後に Evilを使う気になった人へのちょっとしたメモ Emacserじゃない人向け Emacser向け Evil Advent Calendar 2014 の8日目の記事になります。 Evil の使用人口が少なすぎるのでEvilを使う理由などを述べて人口が増えるのを目論みます。 Evilを薦めてるのかEmacsを薦めてるのかよくわからないまとまりのない記事になってしまいました。 EmacsとVim そこそこ経験のあるEmacserは大抵、viの操作もマスターしています。 Emacsがインストールされてない環境も多いのでそんなときはviを使ってささっと編集するのです。 hjklはもちろん、yy,dd,u,cw,yw,dw,もマスターしている人も多いのではないでしょうか？自分はそのたびに感じていました。 「ああ、viはなんて編集が楽なんだろ。指が全然痛くならねぇ。」 Emacsのカーソル移動「 C-p, C-n, C-f, C-b 」は、言葉の意味に関連付けているので覚えやすいです。だから一見viに比べるととっつきやすんです。でも疲れるんですよ。指が圧倒的に！ これには理由があってホームポジションで状態を持たずに沢山の操作を実現するには修飾キーや２段ストロークキーを使うしかないのです。なので、ほぼほぼ全ての動作に小指コントーロールがつきまといます。 それに比べてviはどうでしょうか？まずホームポジションから指を一切動かさずに右手だけでカーソル移動できます。文字的には意味のないhjklですが、指の配置的には理にかなっています。モードがあるおかげで修飾キーを使わずともいろいろと操作できます。そして一番好きなのは {count}{operater}{motion} というシンプルだけど覚えやすいコマンド体系。 viを使うたびに私は思っていました。 「viはなんて操作しやすいのだろう」 と。 それでもEmacsを選ぶ理由 「そんなにviを賛美してEmacsをDisるんならとっととVimmerになれや」との声が聞こえてきそうですが、 Vimへ宗旨替えしようと思ってもできない自分がいるのです。 その最大の理由は「Lisp」。「ハッカーと画家」を読んだ方ならわかると思いますが「Lisp」は魅力的です。プログラマならみんな憧れがあるのではないでしょうか？ LispプログラマにはEmacserが多いですし1、Lispの開発環境といえばEmacsのSLIMEが定番です。なのでEmacsから離れたくないのです。 最近のVimは昔に比べてEmacsのような環境化が進んでいますし、拡張がしやすいという理由でEmacsを選ぶ理由は薄いかもしれません。ただしLispを勉強したいというなら別です。CommonLispにしろSchemeにしろCLojureにしろ、やはりEmacsが一番サポートが厚い気がします。なによりEmacs自身がLispで書かれているのでEmacsを選ぶイコール毎日Lispと戯れることになるのです。 以上のような理由でviのコマンド体系でLispで拡張できるエディタがあったらなぁと思っていたのでした。 Evilとは、Vimの操作性を備えたelisp実行環境である。 そんな時Evilに出会ったのです。EmacsなのにVim。「俺の求めていたのはこれだー」と思いました。なんせEmacsLispで書かれたVimなので「Lispで拡張できる最高やん」と思ったのです。 EvilはEmacsでもあるのでもちろんEmacsの沢山の魅力的な拡張がそのまま動かせます。 org-mode これがないと生きていけない dired 同じく！ anything,helm ライフチェンジング！これなしでは(ry auto-complate いまどきのIDEぽく eshell Editor上でShellを動かす快適さ、シェル上でS式評価できる便利さ！ gnus メールが読めちゃうよ！ skk Emacsとの相性バツグンIME! navi2ch これで仕事中2chしててもばれない twittering-mode これで仕事中Twitterしてても(ry magit ベンリング！ slime CommonLisp 最高の開発環境！ cider Clojureといったらこれ！ こんなにあります(自分がよく使う拡張を挙げてみました)。他にもはじめからEvil用に書かれたプラグインもあったりして積極的にVimの機能がEvilに 移植 されています。 Emacsの豊富な資産を継承しつつも、Vimの操作性を高い再現度で手にいれることができる、それがEvilなのです。 EmcasLispという実行環境の上にEmacsLispで書かれたVimを模倣したエディタが動く。もうこれは、EmacsでもVim でもなく第３のエディタとっいってもいいのではないでしょうか？ Evil-modeでVimの操作性とEmacsの拡張性を両方手に入れる! Evilの魅力をちょっとまとめてみます。 Evilは、vimの基本的な操作は大体通用する。 Evil(vim)は、(達人になれば)呪文をとなえるように編集ができる。それが気持ちよさにつながる。 Evil(vim)は、小指への負担が少ない(重要)。 Evilは、EmacsだからEditorなのに画像が表示できる。その気になれば 3Dゲーム もつくれるぜ! Evilは、日本語編集にも強いVimとして使用できる。 skkが簡単に使える。 ちょっと工夫すれば、モード間のskkの状態遷移がスムーズにできる。よって日本語入力がVimなのに快適! Evilとは、Vimの効率的なテキスト編集能力と、lisp子孫の機能拡張言語を備えた第3のエディタである。 EmacslispはまがりなりにもLispの子孫。言語自体にパワーある。 迷ったらEvil(Emacs)。 EmacsとVimどちらを使えばいいのか迷っている場合、私はEmacsを進めます。 Emacs使いは、結局必要に迫られてviを操作することが多いです。それに比べてvi使いがEmacsの操作もできることは少ない気がします。 viやvimの人がわざわざEmacsを操作する機会がないからですね。であれば、Emacserのほうが両方の操作を覚えられるという点でお得です(面倒と考えずポジティブにいきましょう)。 Evilは、VimとEmacs両方の操作能力を求められので、EmacsもVimも全く知らない人がいきなりEvilから始めるのはあまりお勧めできません。ある程度両方の操作をマスターしてからのほうがいいでしょう。そしてその順序は上述のとおりEmacsからのほうが良いと思います。 最後に どうでしょうか？ちょっとはEvilに興味を持っていただけたしょうか？面倒くさそうだなって思う人のほうが多そうな気もすごくするのですが、少しでも試してみようと思うかたが増えたら幸いです(この記事自体、既にEvilを使ってる人しか読まなそうでけどね)。 Evilを使う気になった人へのちょっとしたメモ EmacsとVimはコマンド体系が喧嘩しまくる感じです。なのでちょっとした基本は最初に知っておいたほうがいいです。とりあえずすぐに思いついたものだけ。 Emacserじゃない人向け C-g は Vim の ESC みたいなもの。困ったらこれを連打。 C-c は メジャーモードのプリフィックス。そのメジャーモードで何かするときは C-c してからコマンドを続けることが多い。 C-c C-c は何かを実行とか決定するときによく使う。 C-u は、反対の意味的なプリフィックス。普段使ってるコマンドを C-u を使って実行するとオルタナティブなコマンドになる。 Emacser向け 迷ったら C-z これでEmacsキーバインドになる。 「ハッカーと画家」の作者は「vi」な人らしいです（Vimではないっぽいところが重要）。\r[return]"
},
{
url: "https://zarudama.github.io/post/2014/04/windows7_emacs/",
title: "Windows7でemacsのアイコンが2重に表示されるのを防ぐ",
date: "2019-11-08T17:04:00+09:00",
body: "Windows7でemacsのアイコンが2重に表示されるのを防ぐ Windows7には、タスクバーにアイコンを登録しておくと、 Win+数字キーで起動できる便利な機能があります。 でもこれ、Windows版emacsだとうまくいきません。 runemacs.exe を起動してタスクバーに登録しても、起動時にDos窓が開いてアイコンが2つ表示されてしまいます。これでは不便なのでなんとかします。 この問題については、下記で解説されてるので一読をおすすめします。 http://dnerkx.blogspot.jp/2009/12/emacs-ntemacs-231-windows-7-part2.html ただしこのサイトで公開されているツールはもうないようなので、下記から代替ツールをダウンロードして適当なところに配置します。 https://code.google.com/p/win7appid/ runemacs.exe のショートカットを作成して、先程ダウンロードしたWin7AppId1.1.exeと同じ場所に配置します。 さきほどダウンロードしたWin7AppId1.exeを、登録したタスクバーアイコンを指定してコマンドプロンプトから実行します。 DOS\u0026gt; Win7AppId1.1.exe runemacs.lnk GNU.Emacs runemacs.lnkが更新されるので、右クリックして「タスクバーに表示する」を選択すれば準備オッケーです。 これで、タスクバーのアイコンをランチャーとして登録し、かつ余計なDos窓が開くこともなくなります。"
},
{
url: "https://zarudama.github.io/post/2014/06/cygwin_tmux/",
title: "cygwinにtmuxを導入",
date: "2019-11-08T17:01:00+09:00",
body: "cygwinにtmuxを導入 \u0026#30446;\u0026#27425; はじめに インストール方法 翌日、なぜか起動しなくなった。 はじめに Cygwinでは、長らくtmuxが使えなかったのですが、最近tmuxが正式にCygwinをサポートしたようです。 コンパイルしてインストールするため、依存するライブラリが必要です。 インストール方法 apt-cygで事前に必要なパッケージをインストールしておく。 $ apt-cyg install ncurses $ apt-cyg install libncurses-devel $ apt-cyg install libevent-devel $ apt-cyg install pkg-config autoconf automake $ apt-cyg install make gcc-core あとは参考サイトにあるとおりでオッケー。 $ git clone http://git.code.sf.net/p/tmux/tmux-code tmux-tmux-code $ cd tmux-tmux-code/ $ ./autogen.sh $ CFLAGS=\u0026#34;-I/usr/include/ncurses\u0026#34; ./configure --prefix=/usr $ make \u0026amp;\u0026amp; make install 参考 http://atdxfe.hatenablog.com/entry/2013/11/27/031058 http://java.ociweb.com/mark/programming/tmuxInCygwin.html 翌日、なぜか起動しなくなった。 後日、起動時に下記のエラーが発生 $ tmux failed to connect to server: No error .bashrc に下記を追記することで治った。 alias tmux=\u0026#39;rm -rf /tmp/tmux* \u0026amp;\u0026amp; tmux\u0026#39; 参考 http://superuser.com/questions/760503/cygwin-tmux-failed-to-connect-to-server-no-error"
},
{
url: "https://zarudama.github.io/post/2014/04/clojure_xml/",
title: "Clojureでxmlを読みこむ方法",
date: "2019-11-08T16:59:00+09:00",
body: "Clojureでxmlを読みこむ方法 \u0026#30446;\u0026#27425; 基本 xml-seq xml-zip XPATH 参考 clojureでxmlを処理する方法のメモ。随時更新予定。 基本 下記のxmlをtest.xmlとしてプロジェクト直下に保存。 \u0026lt;parent\u0026gt; \u0026lt;child\u0026gt; hello \u0026lt;/child\u0026gt; \u0026lt;/parent\u0026gt; clojure.xml/parse関数を使うとmapデータに変換できる。 user\u0026gt; (require \u0026#39;[clojure.xml :as xml]) user\u0026gt; (xml/parse (slurp \u0026#34;test.xml\u0026#34;)) {:tag :parent, :attrs nil, :content [{:tag :child, :attrs nil, :content [\u0026#34;\\n\\t\\thello\\n\\t\u0026#34;]}]} ここでは、slurp関数を使ってXMLファイルを直接読んで処理したが、 slurp以外の関数で読み込んだxmlを扱いたいときなどは、xmlは既に文字列になっていることが多い。 clojure.xml/parse関数は文字列を直接パースできないので下記のようなラッパー関数を用意する。 (defn xml-parse [s] (xml/parse (java.io.ByteArrayInputStream. (.getBytes s)))) これで文字列としてのxmlもパースできるようになった。 user\u0026gt; (def xml-doc \u0026#34;\u0026lt;parent\u0026gt; \u0026lt;child\u0026gt; hello \u0026lt;/child\u0026gt; \u0026lt;/parent\u0026gt;\u0026#34;) #\u0026#39;user/xml-doc user\u0026gt; (xml-parse xml-doc) {:tag :parent, :attrs nil, :content [{:tag :child, :attrs nil, :content [\u0026#34; hello \u0026#34;]}]} xmlのデータが画面に表示されると、場合によってはスクロールが重くなるので、そんな時はC-c M-o でバッファクリアすると良い感じ。 xml-seq xmlをmapデータにしただけだと、各要素へのアクセスが大変なので xml-seq を使用して、各要素をトラバースした状態のシーケンスを用意することができる。この関数を使用すると、それぞれのタグが先頭になった状態シーケンスが得られる。 user\u0026gt; (xml-seq (xml-parse xml-doc)) ({:tag :parent, ;; 最初のparentタグが先頭 :attrs nil, :content [{:tag :child, :attrs nil, :content [\u0026#34; hello \u0026#34;]}]} {:tag :child, ;; 子供のchidleタグが先頭 :attrs nil, :content [\u0026#34; hello \u0026#34;]} \u0026#34; hello \u0026#34; ;; 一番最後の要素 ) こうすることで、ツリー構造なXMLデータがフラットなシーケンスデータになる。つまり for などの従来のシーケンス関数がそのまま使用できるようになる。 \u0026lt;parent\u0026gt; \u0026lt;child name=\u0026#34;taro\u0026#34;\u0026gt;hello\u0026lt;/child\u0026gt; \u0026lt;child name=\u0026#34;hanako\u0026#34;\u0026gt;wao\u0026lt;/child\u0026gt; \u0026lt;/parent\u0026gt;user\u0026gt; (def xml-doc2 \u0026#34; \u0026lt;parent\u0026gt; \u0026lt;child name=\\\u0026#34;taro\\\u0026#34;\u0026gt;hello\u0026lt;/child\u0026gt; \u0026lt;child name=\\\u0026#34;hanako\\\u0026#34;\u0026gt;hi\u0026lt;/child\u0026gt; \u0026lt;/parent\u0026gt;\u0026#34;) #\u0026#39;user/xml-doc2 user\u0026gt; (for [x (xml-seq (xml-parse xml-doc2)) :when (= :child (:tag x))] (:name (:attrs x))) (\u0026#34;taro\u0026#34; \u0026#34;hanako\u0026#34;) xml-zip xml-seq でxmlデータをシーケンスにできるのは良いが、正直使いづらい。そこでもうちょっと直感的に扱える clojure.zip/xml-zip 関数を使用してみる。 user\u0026gt; (require \u0026#39;[clojure.zip :as zip]) user\u0026gt; (zip/xml-zip (xml-seq (xml-parse xml-doc))) [({:tag :parent, :attrs nil, :content [ {:tag :child, :attrs nil, :content [ \u0026#34; hello \u0026#34;]}]} {:tag :child, :attrs nil, :content [ \u0026#34; hello \u0026#34;]} \u0026#34; hello \u0026#34;) nil] zipperとは、ツリー構造を扱うためのライブラリっぽい。 http://en.wikibooks.org/wiki/Clojure%5FProgramming/Examples/API%5FExamples/Advanced%5FData%5FStructures#Zippers XPATH clj-xpath というライブラリを使用すれば、xpathを使うことができる。しかし、XPATHは正規表現のようなミニ言語であり、それなりに学習コストがかかる。また、要素を指定する部分が文字列になるため、実行時エラーの可能性と、コンパイルで時間がかかる可能性などがあるため、現時点では使用しない。 参考 http://d.hatena.ne.jp/sy-2010/20110405/1301992585 https://gist.github.com/bouzuya/4648350"
},
{
url: "https://zarudama.github.io/post/2014/07/emacs_org/",
title: "org-mode でファイルを開くとエラーが発生",
date: "2019-11-08T16:58:00+09:00",
body: "org-mode でファイルを開くとエラーが発生 org-modeをcask経由で新しくしたところ、挙動がおかしくなってしまった。 *.orgファイルを開くと、下記のようなエラーが *Message* バッファに表示され、そのファイルが更新された状態になってしまう。 Invalid function: org-with-silent-modifications 似たような症状が下記にも報告されている。 http://lists.gnu.org/archive/html/emacs-orgmode/2014-06/msg00622.html 上記スレッドでは、 ...Emacs -q and reinstalling from elpa... としたら解決したとあるが具体的なコマンド例がないのでよくわからなかった。 かわりにcask管理のorgを取得しなおした。こんな感じ。 $ rm -rf ~/.emacs.d/.cask/24.3.1/elpa/org-plus-contrib-20140707/ $ cd ~/.emacs.d/ $ cask その際、バージョンをひとつ前の2.8.6に変更 (source org) (depends-on \u0026#34;org-plus-contrib\u0026#34; \u0026#34;2.8.6\u0026#34;) これでエラーにならなくなった。しかし、バージョンを確認すると最新の2.8.7bになっている。なのでバージョン指定は不要かもしれない。 Caskの指定方法が間違っていたのだろうか？"
},
{
url: "https://zarudama.github.io/post/2014/06/emacs_cask/",
title: "Caskの導入と設定ファイルの棚卸し",
date: "2019-11-08T16:55:00+09:00",
body: "Caskの導入と設定ファイルの棚卸し \u0026#30446;\u0026#27425; はじめに Caskの導入 Emacs設定ファイルの書き方 私の.emacsのインストール方法 私の.emacsのディレクトリ配置 私の.emacsの分割のポリシー はじめに 最近Caskが流行り始めてますね。標準のパッケージシステムであるpackage.elがあるのにどうよ？って最初は否定的だったのですが、その機能が自分が求めてたものだったので導入しました。 ClojureのLeiningenみたいに設定ファイルを記述してコマンド叩けば自動でライブラリを落としてくれます。良いです。 そしてCask導入ついでに、設定ファイルたちの見直しを実施しました。これって部屋の掃除と同じで、なかなか気がすすまない作業ですよね。毎日すこしずつ掃除してればちょっとの手間ですむけど溜め込むと大変。自分は後者でした。ここでは、Caskの導入方法と、自分の設定ファイルの解説をしたいと思います。 Caskの導入 インストールは非常に簡単です。 https://github.com/cask/cask 公式にあるとおり下記コマンドを実施するだけです。 $ curl -fsSkL https://raw.github.com/cask/cask/master/go | python すると、 ~/.cask にcask自身がインストールされます。あとは、PATHに下記を追加しておきます。 export PATH=$PATH:~/.cask/bin これで準備オッケーです。 Caskファイルを編集して自分の欲しいパッケージを羅列してきます。 $ vim ~/.emacs.d/Cask で、最後に下記コマンドを実行すれば、あとはツラツラと必要なパッケージが ~/.emacs.d/.cask というディレクトリに保存されていきます。 $ cd ~/.emacs.d $ cask 簡単ですなー。 そしてこれらを利用するにはロードパスを通しておきます。 (require \u0026#39;cask \u0026#34;~/.cask/cask.el\u0026#34;) (cask-initialize) あとはいつもどおりの自分の設定を書けばオッケー。 ちなみにWindowsでは導入できないとの情報を見ましたが自分の環境では問題ありませんでした。環境は下記のとおりです。 # PC Intel(R) Core(TM) i5-3210M CPU @ 2.50GHz 2.50GHz RAM 4.00 GB # Windows Windows7 Professional Service Pack 1 32bit # emacs GNU Emacs 24.3.1 (i386-mingw-nt6.1.7601) of 2013-03-18 on MARVIN # Cygwin $ uname -r 1.7.30(0.272/5/3) Emacs設定ファイルの書き方 .emacsの整理にあたっては、下記の方やりかたを全面採用しました。 http://unknownplace.org/memo/2013/01/21/1/ https://github.com/emacs-jp/emacs-jp.github.com/issues/15#issuecomment-13706554 このやり方を採用すれば $ emacs -q -l init.el とするだけで自分の環境が閉じた状態で簡単に再現できます。設定ファイルを公開している方は、みんなこの方法を採用したほうがいいんじゃないかなーと思います。 ちなみに、初期化ファイルは、init-loaderを使用するのが定番のようですが、自分には合いませんでした。ファイル名をいじって読み込む順番や読み込みの有無を指定するのが苦手で。それよりはコードを直接いじったりコメントアウトするほうが楽でした。 私の.emacsのインストール方法 私のemacs環境は下記の方法でどなたでも試すことができます(ただしまだテストしてません)。 https://github.com/mikio/.emacs.d $ cd ~ $ git clone https://github.com/mikio/.emacs.d.git $ cd .emacs.d $ cask $ emacs -q -l init.el ちなみに、手動インストールが必要なddskkやJDEEなどはインストールできません(当然)。 やりかたを公開しているのは別にオレオレemacsをみんなに使って欲しいのではなくて自分がどこでも環境を再構築できるようにしたいためです。念の為。 私の.emacsのディレクトリ配置 ディレクトリ構成は下記のようになってます。 $HOME + Dropbox/site-lisp/ # 手動でインストールしたlisp + .cask/ # Cask自身のインストール場所 + .skk/ # ddskkのプライベート辞書の場所 + jisyo + .emacs.d/ init.el # ブート的な起動ファイル .cask/ # Caskによりインストールされたパッケージ群の保存場所 conf/ # 各パッケージの初期化ファイル群 私の.emacsの分割のポリシー 最後に設定ファイル分割のポリシーをメモしておきます。 requireが必要ない設定(キーバインドとか、単純な設定など) conf/init.elにまとめる 標準取り込み済みだけどrequireが必要な設定 conf/extend.elにまとめる caskで取り込んだ外部パッケージ 適当な単位で処理を分ける 完全に手でインストールしなければならないもの JDEE ddskk sdic w3m navi2ch これらは、個別に設定ファイルを準備 全体として、elispが存在しなければ無視するように気を使う"
},
{
url: "https://zarudama.github.io/tags/awk/",
title: "awk",
date: "2019-11-08T16:54:00+09:00",
body: "awk"
},
{
url: "https://zarudama.github.io/post/2014/03/awk_basic/",
title: "ちょい足しawkの基本",
date: "2019-11-08T16:54:00+09:00",
body: "ちょい足しawkの基本 \u0026#30446;\u0026#27425; 基本 デリミタを変更するには マッチした文字列だけを表示 タブを出力する例 参考 基本 コンマンドラインでちょい足し的に使うときのカンペ。 $ awk \u0026#39;[BEGIN {各行を処理する前の処理}] [パターン] {各行の処理} [END {各行を処理した後の処理}]\u0026#39; BEGIEN, END, パターンは省略できる(\u0026rdquo;[]\u0026ldquo;でくくったもの) 例は以下。アクセスログのステータスコードが200のものを出力 awk \u0026#39;$4 == \u0026#34;200\u0026#34; {print $4,$5}\u0026#39;# $4が200のとき、$4,$5を表示 awk \u0026#39;$4 != \u0026#34;200\u0026#34; { print }\u0026#39; # $4が200でないとき、1行まるごと表示 awk \u0026#39;$4 ~ /200/ { print }\u0026#39; # $4が200のとき、1行まるごと表示(正規表現) awk \u0026#39;$1 ~ /^a/ { print}\u0026#39; # $1が\u0026#34;a\u0026#34;で始まるとき、表示(正規表現) awk \u0026#39;$1 !~ /^a/{ print}\u0026#39; # $1が\u0026#34;a\u0026#34;以外で始まるとき、表示(正規表現) (例) $ cat access.log | awk \u0026#39;$4 = \u0026#34;200\u0026#34; {print $5$6}\u0026#39; | sed \u0026#39;s/\\\u0026#34;//g\u0026#39; デリミタを変更するには Fオプションを使用する。カンマの場合は以下のとおり。 cat access.log | awk -F , \u0026#39;$4 = \u0026#34;200\u0026#34; {print $5$6}\u0026#39; | sed \u0026#39;s/\\\u0026#34;//g\u0026#39; マッチした文字列だけを表示 文字列の中から数字部分を取りだす場合は以下のとおり。 $ gawk \u0026#39;{print gensub(/(.*)([0-9]+)(.*)/,\u0026#34;\\\\2\u0026#34;,\u0026#34;\u0026#34;)}\u0026#39; gensubのgenは汎用からきている。 第1引数：正規表現 第2引数：置換文字列。ここでは後方参照の2番目として「\\\\2」を指定している。 第3引数：g/Gを指定した場合、マッチするすべてを置換する。それ以外の場合は最初だけ置換する。 マッチしたい部分とさせたくない部分を正規表現でグルーピングし、マッチしたグループだけで後方参照で置換することで、マッチさせた文字列だけを表示できる。 タブを出力する例 整形する際、区切り文字としてタブを出力したい場合の例。 $ cat hoge.txt |awk \u0026#39;{print $1\u0026#34;\\t\u0026#34;$2}\u0026#39; 参考 http://d.hatena.ne.jp/Rocco/20071120/p6 http://www.kt.rim.or.jp/~kbk/gawk-30/gawk%5F13.html"
},
{
url: "https://zarudama.github.io/tags/vim/",
title: "vim",
date: "2019-11-08T16:50:00+09:00",
body: "vim"
},
{
url: "https://zarudama.github.io/post/2014/04/cygwin_apt_cyg/",
title: "vimのclojure実装であるaviを試してみた。",
date: "2019-11-08T16:50:00+09:00",
body: "vimのclojure実装であるaviを試してみた。 vimをclojureで実装したらしい avi を試してみることにした。確認環境は、ubuntu13.04。 $ git clone https://github.com/maitria/avi.git $ cd avi READMEによると、avi本体を /usr/local 配下にインストールするとのこと。あとでアンインストールができなくなると困るので paco を使うことにした。 $ sudo paco -D LEIN_ROOT=yes /home/mikio/bin/lein install LEIN_ROOT は lein をrootユーザーで使用するときは定義しなくてはならないらしい。 (値のyesは適当)。pacoのDオプションはインストールの対象をカレントディレクトリにするという意味。 インストールが始まるとワラワラと沢山のライブラリをダウンロードしてくる。ダウンロードとインストールが終ったらコマンドが返るのでおもむろに $ avi で見慣れたvimの画面が表示された。 \u0026#22259;1: 起動したところ JVMで動くから重いと思ってたら起動が早くてびっくりした(本家よりはわずかに重い)。どうやらJNIを使って下回りの部分はC言語で書かれているようである。 (なのでwindowsでは動かないかも)。 肝心の操作は、iコマンドはもちろんaコマンドも受け付けず、文字入力はなにもできない状態だった。唯一、 :q はできたので、終了させることはできた。。。 (個々の環境にも依存すると思うので無事操作できた人がいたらコメントやリプで教えていただけると嬉しいです) ちょっと残念な結果になったが、今後の開発が非常に楽しみなプロダクトだ。"
},
{
url: "https://zarudama.github.io/post/2014/06/cygwin_apt_cyg/",
title: "apt-cygがうまくいかなくなった。",
date: "2019-11-08T16:47:00+09:00",
body: "apt-cygがうまくいかなくなった。 \u0026#30446;\u0026#27425; はじめに 対応方法 はじめに Cygwinには、非公式で、apt-cygというパッケージ管理システムがあります。これは、ubuntuでいう apt-get のようなものです。標準のsetup.exeはGUIベースで操作が面倒なので、apt-cygを導入すると非常に捗ります。 2014/06/23 追記 ここから 最新のapt-cygでは、下記の問題は全て解決されています。古いapt-cygを利用してる方は、最新のapt-cygをチェックしてください。 (間違った内容の記事を載せてしまいました。申し訳ありません) 2014/06/23 追記 ここまで そんなapt-cygですが、最近は更新が滞ってるらしく、最新のCygwinではうまく動きません。 2013/08にリポジトリパスの変更があった それに伴い、apt-cygが動かなくなった。 さらに2013/10時点で、リポジトリ内のアーカイブ内のフォーマットの変更もあった模様 tar.bz2から、tar.xzなどに変更になった模様。詳細は不明。 インストールできるパッケージとできないパッケージが発生。 上記変更点をサポートするapt-cygは以下(本家はメンテされていない。。。) https://github.com/zship/apt-cyg といった感じです。 対応方法 2014/06/23 追記 対応方法は、本家最新版を利用すれば問題ありませんので、削除しました。"
},
{
url: "https://zarudama.github.io/post/2014/01/clojure_problem/",
title: "4clojureを解いていく記事",
date: "2019-11-08T16:43:00+09:00",
body: "4clojureを解いていく記事 \u0026#30446;\u0026#27425; A nil key【難しい】 For the win 【forの使いかた】 Logical falsity and truth【真偽について】 Subset and Superset【重量】 Map Defaults Lists: conj【重要】 Intro to Vectors【重要】 Vectors :conj【重要】 Intro to Sets【重要】 Sets: conj【重要】 Intro to Maps Maps: conj Intro to Sequences Sequences: rest Intro to Functions【重要】 Double Down Hello World Sequences: map【重要】 Sequences: filter【重要】 #35 Local bindings #37 Regular Expressions #64 Intro to Reduce #57 Simple Recursion【難しい】 S#71 Rearranging Code: -\u0026gt;【重要】 #68 Recurring Theme S#72 Rearranging Code: -\u0026gt;\u0026gt;【重要】 Last Element【難しい】 #20 Penultimate Element【難しい】 #21 Nth Element【難しい】 4clojureを解いていった過程を愚直にメモしておきます。 あとで見返して復習するためです。 基本的に時間のかかった問題と重要と思われるものだけ記述します。 この記事は随時更新してきます。 A nil key【難しい】 - #134 - Difficulty: Elementary - Topics: maps Write a function which, given a key and map, returns true iff the map contains an entry with that key and its value is nil. (true? (__ :a {:a nil :b 2})) (false? (__ :b {:a nil :b 2})) (false? (__ :c {:a nil :b 2})) 答 #(nil? (%2 %1 \u0026#39;())) 経過 一瞬、マップをキーにして、値を取るようにすればいいと考えたけど user\u0026gt; (:b {:a nil :b 2}) 2 外側のカッコの使いかたがわからん。次に思いついたのがget関数。でもこれは引数の位置が合わない。 user\u0026gt; (get :b {:a nil :b 2}) nil user\u0026gt; (get {:a nil :b 2} :b) 2 キーは第２引数にしないとnilが返ってきてしまうのでNG。そもそも問題分のiffの意味がわからないのでググル。 わかったこと。問題にあるiffとは「if and only if」の略で同値のこと。 0 and 0 =\u0026gt; true 0 and 1 =\u0026gt; false 1 and 0 =\u0026gt; false 1 and 1 =\u0026gt; true true?,false?,nil?関数はiffの関数で完全に同値でないと真を返さない。 user\u0026gt; (true? true) true user\u0026gt; (true? 1) false user\u0026gt; (true? 2) false user\u0026gt; (false? nil) false user\u0026gt; (false? false) true user\u0026gt; (false? \u0026#34;\u0026#34;) false user\u0026gt; (nil? nil) true user\u0026gt; (nil? false) false user\u0026gt; (nil? \u0026#34;\u0026#34;) false user\u0026gt; (nil? \u0026#39;()) false いろいろ指向錯誤した結果、即時呼び出しする無名関数を定義すれば良いと思いついた。 こんなやつ。 (#(str %1 %2) \u0026#34;Hello\u0026#34; \u0026#34;World!\u0026#34;) 似た記述をjavascriptで良くみますな。 この後いろいろ試す。 結構試行錯誤したうえでやっとできた。 user\u0026gt; (#(nil? (%2 %1 \u0026#39;())) :a {:a nil :b 2}) true user\u0026gt; (#(nil? (%2 %1 \u0026#39;())) :b {:a nil :b 2}) false user\u0026gt; (#(nil? (%2 %1 \u0026#39;())) :c {:a nil :b 2}) false For the win 【forの使いかた】 #145 Difficulty: Elementary Topics: core-functions seqs Clojure\u0026#39;s for macro is a tremendously versatile mechanism for producing a sequence based on some other sequence(s). It can take some time to understand how to use it properly, but that investment will be paid back with clear, concise sequence-wrangling later. With that in mind, read over these for expressions and try to see how each of them produces the same result.(= __ (for [x (range 40) :when (= 1 (rem x 4))] x)) (= __ (for [x (iterate #(+ 4 %) 0) :let [z (inc x)] :while (\u0026lt; z 40)] z)) (= __ (for [[x y] (partition 2 (range 20))] (+ x y))) 答 (map inc (filter #(= 0 (rem % 4)) (range 40))) 経過 forを読めば、どんなシーケンスを返すかは想像できるが単純にそのシーケンスを書くのは意味がない。 この問題は、下記の数列を考える問題。 0から開始して4の倍数に1足した数列を40未満まで出力する。 \u0026#39;(1 5 9 13 17 21 25 29 33 37) でも実際forを読むことはできても、これと同じ挙動を捻りだすのは難題。 以下のような感じで作れた。 user\u0026gt; (range 40) (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39) user\u0026gt; (filter #(rem % 4) (range 40)) (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39) user\u0026gt; (filter #((= 0 (rem % 4))) (range 40)) ClassCastException java.lang.Boolean cannot be cast to clojure.lang.IFn user/eval6704/fn--6705 (NO_SOURCE_FILE:1) user\u0026gt; (filter #((not (rem % 4))) (range 40)) ClassCastException java.lang.Boolean cannot be cast to clojure.lang.IFn user/eval6851/fn--6852 (NO_SOURCE_FILE:1) user\u0026gt; (rem 4 4) 0 user\u0026gt; (filter #(= 0 (rem % 4)) (range 40)) (0 4 8 12 16 20 24 28 32 36) user\u0026gt; (map inc (filter #(= 0 (rem % 4)) (range 40))) (1 5 9 13 17 21 25 29 33 37) Logical falsity and truth【真偽について】 #152 Difficulty: Elementary Topics: logic In Clojure, only nil and false represent the values of logical falsity in conditional tests - anything else is logical truth.(= __ (if-not false 1 0)) (= __ (if-not nil 1 0)) (= __ (if true 1 0)) (= __ (if [] 1 0)) (= __ (if [0] 1 0)) (= __ (if 0 1 0)) (= __ (if 1 1 0)) 答 1 要点 clojureでは、falseとnilだけが偽。それ以外は全て真。 Subset and Superset【重量】 #162 Difficulty: Elementary Topics: set-theory Set A is a subset of set B, or equivalently B is a superset of A, if A is \u0026#34;contained\u0026#34; inside B. A and B may coincide.(clojure.set/superset? __ #{2}) (clojure.set/subset? #{1} __) (clojure.set/superset? __ #{1 2}) (clojure.set/subset? #{1 2} __) 答 #{1 2} 経過 user\u0026gt; (clojure.set/subset? #{1} #{1 2}) true user\u0026gt; (clojure.set/superset? #{1 2} #{1 2}) true user\u0026gt; (clojure.set/superset? #{1 2} #{1 2}) true user\u0026gt; (clojure.set/subset? #{1 2} #{1 2}) true 内容が同じ場合は、superset?もsubset?も真になる。 要点 Bの集合があり、その中にAの集合が含まれるとき、 BがAのsupersetとなり、AはBのsubsetとなる。 +---------+ | +-+ | | |A| B | | +-+ | +--------- Map Defaults Difficulty: Elementary Topics: seqs #156 When retrieving values from a map, you can specify default values in case the key is not found: (= 2 (:foo {:bar 0, :baz 1} 2)) However, what if you want the map itself to contain the default values? Write a function which takes a default value and a sequence of keys and constructs a map.(= (__ 0 [:a :b :c]) {:a 0 :b 0 :c 0}) (= (__ \u0026#34;x\u0026#34; [1 2 3]) {1 \u0026#34;x\u0026#34; 2 \u0026#34;x\u0026#34; 3 \u0026#34;x\u0026#34;}) (= (__ [:a :b] [:foo :bar]) {:foo [:a :b] :bar [:a :b]}) 答 経過 キーからなる配列とひとつの値を指定してmapをつくる関数を考える問題。 Lists: conj【重要】 #5 Difficulty: Elementary Topics: When operating on a list, the conj function will return a new list with one or more items \u0026#34;added\u0026#34; to the front. test not run (= __ (conj \u0026#39;(2 3 4) 1)) test not run (= __ (conj \u0026#39;(3 4) 2 1)) 答 \u0026#39;(1 2 3 4) conjは第２以降の引数を順番にlistの先頭にくっつけていく。複数の引数をフラットなリストにする感じ。 user\u0026gt; (conj \u0026#39;(2 3 4) 1) (1 2 3 4) user\u0026gt; (conj \u0026#39;(3 4) 1 2) (2 1 3 4) ↑引数を左から順番に、先頭に追加していくことに注意。 一方、consは追加する要素は、第1引数にひとつだけとる。こちらも同様に先頭へ追加していく。 user\u0026gt; (cons 1 \u0026#39;(2 3)) (1 2 3) user\u0026gt; (cons 1 2 \u0026#39;(2 3)) ; Evaluation aborted. Intro to Vectors【重要】 #6 Intro to VectorsSolutions Difficulty: Elementary Topics: Vectors can be constructed several ways. You can compare them with lists. test not run(= [__] (list :a :b :c) (vec \u0026#39;(:a :b :c)) (vector :a :b :c)) 答 :a :b :c リストをベクタに変換する user\u0026gt; (vec \u0026#39;(:a :b :c)) [:a :b :c] ベクタを作る user\u0026gt; (vector :a :b :c) [:a :b :c] それぞれの返り値がベクタなので最初わからなかったが REPLに入れたらtrueが帰ってきた！ user\u0026gt; (= [:a :b :c] (list :a :b :c) (vec \u0026#39;(:a :b :c)) (vector :a :b :c)) true = 関数は中身だけ見るのね。 で、これを4clojureに回答しても、正解にならない。。。 (= [:a :b :c] (list :a :b :c) (vec \u0026#39;(:a :b :c)) (vector :a :b :c)) REPLではtrueになるのになぜ？ (= (lis \u0026lsquo;(:a :b :c)) (list :a :b :c) (vec \u0026lsquo;(:a :b :c)) (vector :a :b :c)) -\u0026gt; 問題をよくみたらカギカッコが含まれていた。 「[___]」つまり「[:a :b :c]」のうち中身の「:a :b :c」だけを書けばよかった。だから下記であってたということ。 user\u0026gt; (= [:a :b :c] (list :a :b :c) (vec \u0026#39;(:a :b :c)) (vector :a :b :c)) この問題でわかることは、ベクタには「\u0026rsquo;」がいらないということ。 \u0026#39;[a b c] ではなくて [a b c] でよいとうこと。 Vectors :conj【重要】 注意!ベクタの場合は、リストと違って後ろに追加されていく。 user\u0026gt; (= [1 2 3 4] (conj [1 2 3] 4)) true user\u0026gt; (= [1 2 3 4] (conj [1 2] 3 4)) true Intro to Sets【重要】 (= __ (set \u0026#39;(:a :a :b :c :c :c :c :d :d))) (= __ (clojure.set/union #{:a :b :c} #{:b :c :d})) とりあえずリテラルを書いてみる。 user\u0026gt; (= #{:a :a :b :c :c :c :c :d :d} (set \u0026#39;(:a :a :b :c :c :c :c :d :d))) ; Evaluation aborted. \u0026hellip;うまくいかない。なぜアボートになるのか。。。そうかsetは値はユニークになるものだった。set関数の引数が非ユニークだからそのままリテラル書いたけどリテラルは当然setの仕様どおりに記述しなくちゃならないからユニークにしなくちゃだね。 user\u0026gt; (= #{:a :b :c :d} (set \u0026#39;(:a :a :b :c :c :c :c :d :d))) true union関数はふたつのsetを合成するものかな。 user\u0026gt; (clojure.set/union #{:a :b :c} #{:b :c :d}) #{:a :c :b :d} Sets: conj【重要】 (= #{1 2 3 4} (conj #{1 4 3} __)) 試す。 user\u0026gt; (conj #{1 4 3} #{2 3 5}) #{1 3 4 #{2 3 5}} user\u0026gt; (conj #{1 4 3} 2 3 5) #{1 2 3 4 5} なるほど。理解した。setは中身がソートされるのね。 user\u0026gt; (= #{1 2 3 4} (conj #{1 4 3} 2 3)) true Intro to Maps (= __ ((hash-map :a 10, :b 20, :c 30) :b)) (= __ (:b {:a 10, :b 20, :c 30}))user\u0026gt; (= 20 ((hash-map :a 10, :b 20, :c 30) :b)) true user\u0026gt; (= 20 (:b {:a 10, :b 20, :c 30})) true Maps: conj (= {:a 1, :b 2, :c 3} (conj {:a 1} __ [:c 3])) Mapにconjするにはキーと値のペアのベクタを渡す。 user\u0026gt; (conj {:a 1} [:b 2] [:c 3]) {:c 3, :b 2, :a 1} Intro to Sequences (= __ (first \u0026#39;(3 2 1))) (= __ (second [2 3 4])) (= __ (last (list 1 2 3))) Sequences: rest (= __ (rest [10 20 30 40]))(= \u0026#39;(20 30 40) (rest [10 20 30 40])) Intro to Functions【重要】 (= __ ((fn add-five [x] (+ x 5)) 3)) (= __ ((fn [x] (+ x 5)) 3)) (= __ (#(+ % 5) 3)) (= __ ((partial + 5) 3)) 無名関数をカッコでくるむことで即時呼び出しされる。 partial関数ってなに？初見だ。 Double Down Write a function which doubles a number. (= (__ 2) 4) (= (__ 3) 6) (= (__ 11) 22) (= (__ 7) 14) 答え (= (#(* 2 %) 2) 4) Hello World Write a function which returns a personalized greeting. (= (__ \u0026#34;Dave\u0026#34;) \u0026#34;Hello, Dave!\u0026#34;) (= (__ \u0026#34;Jenn\u0026#34;) \u0026#34;Hello, Jenn!\u0026#34;) (= (__ \u0026#34;Rhea\u0026#34;) \u0026#34;Hello, Rhea!\u0026#34;) 答 user\u0026gt; (= (format \u0026#34;Hello, %s!\u0026#34; \u0026#34;Rhea\u0026#34;) \u0026#34;Hello, Rhea!\u0026#34;) true Sequences: map【重要】 The map function takes two arguments: a function (f) and a sequence (s). Map returns a new sequence consisting of the result of applying f to each item of s. Do not confuse the map function with the map data structure. (= __ (map #(+ % 5) \u0026#39;(1 2 3))) Sequences: filter【重要】 The filter function takes two arguments: a predicate function (f) and a sequence (s). Filter returns a new sequence consisting of all the items of s for which (f item) returns true. (= __ (filter #(\u0026gt; % 5) \u0026#39;(3 4 5 6 7))) #35 Local bindings Difficulty: Elementary Topics: syntax Clojure lets you give local names to values using the special let-form. test not run (= __ (let [x 5] (+ 2 x))) test not run (= __ (let [x 3, y 10] (- y x))) test not run (= __ (let [x 21] (let [y 3] (/ x y)))) #37 Regular Expressions Difficulty: Elementary Topics: regex syntax Regex patterns are supported with a special reader macro. test not run (= __ (apply str (re-seq #\u0026#34;[A-Z]+\u0026#34; \u0026#34;bA1B3Ce \u0026#34;)))user\u0026gt; (= \u0026#34;ABC\u0026#34; (apply str (re-seq #\u0026#34;[A-Z]+\u0026#34; \u0026#34;bA1B3Ce \u0026#34;))) true #64 Intro to Reduce Difficulty: Elementary Topics: seqs Reduce takes a 2 argument function and an optional starting value. It then applies the function to the first 2 items in the sequence (or the starting value and the first element of the sequence). In the next iteration the function will be called on the previous return value and the next item from the sequence, thus reducing the entire collection to one value. Don\u0026#39;t worry, it\u0026#39;s not as complicated as it sounds. (= 15 (reduce __ [1 2 3 4 5])) (= 0 (reduce __ [])) (= 6 (reduce __ 1 [2 3]))user\u0026gt; (= 15 (reduce + [1 2 3 4 5])) true #57 Simple Recursion【難しい】 Difficulty: Elementary Topics: recursion A recursive function is a function which calls itself. This is one of the fundamental techniques used in functional programming. (= __ ((fn foo [x] (when (\u0026gt; x 0) (conj (foo (dec x)) x))) 5))user\u0026gt; (= \u0026#39;(5 4 3 2 1) ((fn foo [x] (when (\u0026gt; x 0) (conj (foo (dec x)) x))) 5)) true S#71 Rearranging Code: -\u0026gt;【重要】 Difficulty: Elementary Topics: The -\u0026gt; macro threads an expression x through a variable number of forms. First, x is inserted as the second item in the first form, making a list of it if it is not a list already. Then the first form is inserted as the second item in the second form, making a list of that form if necessary. This process continues for all the forms. Using -\u0026gt; can sometimes make your code more readable. (= (__ (sort (rest (reverse [2 5 4 1 3 6])))) (-\u0026gt; [2 5 4 1 3 6] reverse rest sort __) 5)(= (last (sort (rest (reverse [2 5 4 1 3 6])))) (-\u0026gt; [2 5 4 1 3 6] reverse rest sort last) 5) #68 Recurring Theme Difficulty: Elementary Topics: recursion Clojure only has one non-stack-consuming looping construct: recur. Either a function or a loop can be used as the recursion point. Either way, recur rebinds the bindings of the recursion point to the values it is passed. Recur must be called from the tail-position, and calling it elsewhere will result in an error. (= __ (loop [x 5 result []] (if (\u0026gt; x 0) (recur (dec x) (conj result (+ 2 x))) result))) S#72 Rearranging Code: -\u0026gt;\u0026gt;【重要】 Difficulty: Elementary Topics: The -\u0026gt;\u0026gt; macro threads an expression x through a variable number of forms. First, x is inserted as the last item in the first form, making a list of it if it is not a list already. Then the first form is inserted as the last item in the second form, making a list of that form if necessary. This process continues for all the forms. Using -\u0026gt;\u0026gt; can sometimes make your code more readable. test not run (= (__ (map inc (take 3 (drop 2 [2 5 4 1 3 6])))) (-\u0026gt;\u0026gt; [2 5 4 1 3 6] (drop 2) (take 3) (map inc) (__)) 11) こたえ (= (apply + (map inc (take 3 (drop 2 [2 5 4 1 3 6])))) (-\u0026gt;\u0026gt; [2 5 4 1 3 6] (drop 2) (take 3) (map inc) (apply +)) 11) Last Element【難しい】 Difficulty: Easy Topics: seqs core-functions Write a function which returns the last element in a sequence. (= (__ [1 2 3 4 5]) 5) (= (__ \u0026#39;(5 4 3)) 3) (= (__ [\u0026#34;b\u0026#34; \u0026#34;c\u0026#34; \u0026#34;d\u0026#34;]) \u0026#34;d\u0026#34;) lastは使っちゃダメらしい。 難しい。ここみてカンニング。。。 http://stackoverflow.com/questions/8264881/clojure-find-last-element-without-using-last-function user\u0026gt; (= (#(first (reverse %)) \u0026#39;(5 4 3)) 3) true 無名関数を使い、さらに即時呼出するとか。絶対おもいつかん。。。 #20 Penultimate Element【難しい】 Difficulty: Easy Topics: seqs Write a function which returns the second to last element from a sequence. (= (__ (list 1 2 3 4 5)) 4) (= (__ [\u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34;]) \u0026#34;b\u0026#34;) (= (__ [[1 2] [3 4]]) [1 2]) 先の問題にあった「Last Element」と同じ。 user\u0026gt; (= (#(second (reverse %)) (list 1 2 3 4 5)) 4) true user\u0026gt; (= (#(second (reverse %)) [\u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34;]) \u0026#34;b\u0026#34;) true user\u0026gt; (= (#(second (reverse %)) [[1 2] [3 4]]) [1 2]) true #21 Nth Element【難しい】 Nth Element Difficulty:Easy Topics:seqs core-functions Write a function which returns the Nth element from a sequence. Special Restrictions nth(= (__ \u0026#39;(4 5 6 7) 2) 6) (= (__ [:a :b :c] 0) :a) (= (__ [1 2 3 4] 1) 2) (= (__ \u0026#39;([1 2] [3 4] [5 6]) 2) [5 6]) Special Restrictions nth とあるのでnthが使えないので難しい。無名関数を駆使しないと溶けない。"
},
{
url: "https://zarudama.github.io/post/2014/05/libgdx_emacs/",
title: "Emacs JDEE でlibGDXプログラミング!",
date: "2019-11-08T16:32:00+09:00",
body: "Emacs JDEE でlibGDXプログラミング! \u0026#30446;\u0026#27425; はじめに gradleプロジェクトをJDEEでも使えるようにする はじめに libGDX でゲームプログラミングを始めています。 最初は、Eclipseでコーディングしていました。 でも重すぎるので、軽いと評判のIntelliJ IDEAに乘りかえました。 確かに快適でした。Eclipseよりは。しかしそれでもいろいろ不満がつのる。。。 …結局、Emacsに戻ってきました。やはり最後はいつもの場所へ。悲しい性ですね。 ということで、EmacsでJavaやるなら JDEE です。 gradleプロジェクトをJDEEでも使えるようにする JDEEはgradleをサポートしてません。でもやっぱりいるんですねー。すばらしき先人が。 GradleプロジェクトをJDEEの plj.el に変換するスクリプトを発見しました。 http://ignatyev-dev.blogspot.jp/2013/07/gradle-projects-in-jdee.html 上記で紹介されている jdee.gradle を、libGDXのプロジェクトルートに配置します。そのままだと、testディレクトリがないと怒られるので、testを含む行をコメントアウトします。 更に build.gradle を編集し、 apply from:... を追加します。 } } +apply from:\u0026#39;jdee.gradle\u0026#39; allprojects { apply plugin: \u0026#34;eclipse\u0026#34; apply plugin: \u0026#34;idea\u0026#34; あとは、プロジェクトルートで下記コマンドを実行します。 $ ./gradlew jdee すると各サブプロジェクト内で、 prj.el が作成されます。 最後に下記の plj.el をプロジェクトルートに配置します。 (jde-project-file-version \u0026#34;1.0\u0026#34;) (jde-set-variables \u0026#39;(jde-jdk (quote (\u0026#34;1.7\u0026#34;))) \u0026#39;(jde-jdk-registry (quote ( ;;(\u0026#34;1.7\u0026#34; . \u0026#34;c:/Program Files/Java/jdk1.7.0_09/\u0026#34;) (\u0026#34;1.7\u0026#34; . \u0026#34;/usr/lib/jvm/jdk1.7.0/\u0026#34;) ))) \u0026#39;(jde-jdk-doc-url \u0026#34;http://docs.oracle.com/javase/jp/6/api/\u0026#34;) ;; JDKのjavadocのURL \u0026#39;(jde-help-docsets \u0026#39;((\u0026#34;JDK API\u0026#34; \u0026#34;http://docs.oracle.com/javase/jp/6/api/\u0026#34; nil) (\u0026#34;libGDX API\u0026#34; \u0026#34;http://libgdx.badlogicgames.com/nightlies/docs/api/\u0026#34; nil) )) \u0026#39;(jde-help-use-frames nil) ) (setq jde-import-auto-sort t) ;; import文挿入時に自動でソート パスは各自の環境に合せて適宜変更してください。 これで、libGDXのインポートの自動生成やメソッド補完ができます。 C-c C-v C-w でコンテキストヘルプ(JavaDoc)も引けます。ただしビルドはコンソールから実行する必要があります。でもメッソッド補完とクラスインポートが使えれば十分。 \u0026#22259;1: Helmメソッド補完 + YASnippetで快適快適ー いやしかしこんな奇特な人間、世界でも数人しかいないんだろうなぁー。"
},
{
url: "https://zarudama.github.io/tags/libgdx/",
title: "libgdx",
date: "2019-11-08T16:32:00+09:00",
body: "libgdx"
},
{
url: "https://zarudama.github.io/post/2014/05/libgdx01/",
title: "libGDX入門 その01 画像を表示したり音を鳴らしたり",
date: "2019-11-08T16:24:00+09:00",
body: "libGDX入門 その01 画像を表示したり音を鳴らしたり \u0026#30446;\u0026#27425; はじめに プロジェクトを作る 注意点 IntelliJで使う プロジェクトのインポート PC版を動かす Android版を動かす HTML版を動かす Eclipseで使う Gradleプラグインのインストール プロジェクトのインポート PC版を動かす Android版を動かす HTML版を動かす コマンドラインで使う PC版を動かす Android版を動かす HTML版を動かす 基本的なクラスについて 文字表示 スプライトクラスを使用する。 座標系 画像を動かす 効果音を鳴らす BGMを鳴らす 画像を拡大・縮小・回転してみる ソース おわりに 参考書籍 はじめに てすてす libGDX は、Javaでゲームを作るためのライブラリです。マルチプラットフォーム対応で、PC(Windows,Linux,Mac), Android, iOS, HTMLに対応しています。 libGDXは、日本での知名度はイマイチのようですが、海外ではかなり人気があるようです。実際、ググってみると、英語のドキュメントは沢山みかけますが、日本語のドキュメントはまだまだ少数です。 また、公式ドキュメントも大変充実しています(英語のみ)。 https://github.com/libgdx/libgdx/wiki 実のところこのドキュメントを読めば大抵の事は解決します。 ただ、私もそうなんですが、日本語情報がないってだけで、重い腰が上がらないって人も多いと思います。そんな人向けに(というより自分の勉強ついでに)、そして少しでもlibGDXを使用する人が増えることを願い、少しずつ記事を書いていこうと思います。 この記事が、libGDXを学ぶためのきっかけになって頂ければ幸いです。 その2は こちら。 このシリーズの目次は こちら 。 プロジェクトを作る libGDXでは、専用のプロジェクト生成アプリが用意されています。マルチプラットフォームの性質上、プロジェクトの構成が複雑なので素直にこのアプリを使用したほうが良いかと思います。 http://libgdx.badlogicgames.com/download.html 起動は、以下のような感じです。Windowsならばダブルクリックで起動できるでしょう。 $ java -jar gdx-setup.jar Usage: GdxSetup --dir \u0026lt;dir-name\u0026gt; --name \u0026lt;app-name\u0026gt; --package \u0026lt;package\u0026gt; --mainClass \u0026lt;mainClass\u0026gt; --sdkLocation \u0026lt;SDKLocation\u0026gt; dir ... the directory to write the project files to name ... the name of the application package ... the Java package name of the application mainClass ... the name of your main ApplicationListener sdkLocation ... the location of your android SDK. Uses ANDROID_HOME if not specified \u0026#22259;1: 起動したところ 入力値は見たままですが、 Name プロジェクトの名前(設定ファイルでアプリ名として利用される) Package プロジェクトのパッケージ Game class 起点となるクラス Destination プロジェクトの出力ディレクトリ(ディレクトリは存在しなくても自動作成してくれる) Android SDK AndroidSDKへのパス となります。 Generateボタンをクリックすれば、プロジェクトが生成されます。必要なライブラリ(gradle、dllやsoなど)も全部まるっとダウンロードしてくれるので楽チンです。 以降、プロジェクトを ~/dev/libgdxtest/ に生成した前提で話をすすめます。 注意点 今後プロジェクトを実行する際、挙動がおかしいなと思ったら、下記のデイレクトリを(バックアップしたうえで)削除して再実行してみてください。 $ rm -rf ~/.m2 $ rm -rf ~/.gradle ともにjarファイルなどの依存ファイルを保存するディレクトリですが、稀に状態がおかしくなるようです。 IntelliJで使う Eclipseに比べて軽いと評判の IntelliJ IDEA での扱い方です。 プロジェクトのインポート まずは、IntelliJを起動し、Import Projectを選択します。既に別のプロジェクトを起動していた場合は、「close Project」を選択します。 \u0026#22259;2: IntelliJの最初のダイアログ gdx-setup.jar で生成したディレクトリを選択します。 \u0026#22259;3: プロジェクトディレクトリを選択 Gradleを選択し、「next」ボタンを押下します。 \u0026#22259;4: Gradle選択 「Use default gradle wrapper」を選択します。 \u0026#22259;5: defaultを選択 最後にFinishボタンを押下します。最初のインポートには時間がかかります。最終的に下記のエラー(HTML関係)が表示されますが、HTMLはひとまず使用しないので気にしないでおきます。 \u0026#22259;6: HTMLのエラー PC版を動かす インポートが終わったら、早速実行してみます。 メニュー → Run → Edit Configrationsを選択。 \u0026#22259;7: 実行の際の設定ダイアログ 入力内容は以下のとおり。 Name Desktop Use class path of module desktop Main class DesktopLauncher クラスを選択 Working directory android/assetsディレクトリを選択 最後にOKを選択します。 実行環境が作成できたら、右上にあるIntelliJのセレクトボックスからDesktopを選択して再生ボタンを押下します。最初の実行は、インポート以上に時間がかかりますので心してください。 \u0026#22259;8: 右上にあるセレクトボックス 下記の画面が表示されたら成功です!おめでとうございます!! \u0026#22259;9: 実行画面 Android版を動かす デバイスを接続します。 予めOSがきちんと認識していることを確かめておいて下さい。 右上のセレクトボックスから「android」を選択し、再生ボタンを押下します。 認識しているデバイスが表示されるので、選択して実行します。 HTML版を動かす ターミナルを開きます。 メニュー → View → Tool Windows → Terminal ターミナルでプロジェクトルートに移動します。 $ cd ~/dev/libtext 下記のコマンドを実行します。 $ ./gradlew html:superDev いろいろ出力が表示され、最終的に The code server is ready. の表示がされたら、下記にアクセスします。 http://localhost:8080/html/ \u0026#22259;10: Terminal HTML版は、 String.format メソッドが使えなかったり、 BitmapFontが表示できなかったり制限があるので注意してください。 \u0026#22259;11: HTML版を起動している様子 Eclipseで使う Juno4.2、日本語版で解説します。 Gradleプラグインのインストール メニュー → ヘルプ → 新規ソフトウェアのインストール 作業対象欄に下記を入力し、追加ボタンを押下 http://dist.springsource.com/release/TOOLS/gradle ダイアログの名前欄に「Gradle」と入力し、OKボタンを押下 「Extensions / Gradle Integration」をチェックし、「次へ」ボタンを押下 「次へ」ボタンを押下 「使用条件の条項に同意します」をチェックし、「完了」ボタンを押下 プロジェクトのインポート メニュー → ファイル → インポート → Gradel Project → 次へボタンを押下 ルートフォルダー欄に、生成したプロジェクトディレクトリを入力、BuiildModeボタンを押下 プロジェクト欄の最上意プロジェクトを選択して、完了ボタンを押下 PC版を動かす 下記の手順です。 パッケージエクスプローラから、desktopプロジェクトを選択、右クリック 実行 → Javaアプリケーション を選択 型選択欄で、desktopと入力 一致する項目からDesktopLauncherクラスを選択し、OKボタンを押下 以上で実行されます。 Android版を動かす 下記の手順です。 事前にデバイスをOSが認識していることを確認してください。 パッケージエクスプローラから、androidプロジェクトを選択、右クリック 実行 → Android アプリケーション を選択 以上で実行されます。 HTML版を動かす 下記の手順です。 パッケージエクスプローラから、gwtプロジェクトを選択、右クリック 実行 → 外部ツールの構成 左ペインの「プログラム」をダブルクリック 名前欄に「GWT SuperDev」と入力 ローション欄：ファイルシステムの参照ボタンから「gradlew(windowsの場合は、gradlew.bat)」を選択 作業ディレクトリ欄：ファイルシステムの参照ボタンから、プロジェクトルートを選択 引数欄に「html:superDev」と入力 適用ボタンを押下 実行ボタンを押下 するとコンソールビューが表示され、いろいろ出力されます。最終的に The code server is ready. の表示がされたら、下記にアクセスします。 http://localhost:8080/html/ コマンドラインで使う コマンドラインで実行する場合は特に準備は不要で、最初のプロジェクト生成で既に準備は整っています。 Emacserの自分は、この方法が一番好きです。 基本的には、gradlewコマンドでタスクを実行するだけです。 Windowsの場合は、gradlewに、拡張子 .bat を追加して実行してください。 gradlewコマンドは、プロジェクトルートで実行する必要があります。 $ cd ~/dev/libgdxtest PC版を動かす 下記のように実行します。 $ ./gradlew desktop:run Android版を動かす 予め ANDROID_HOME を定義しておく必要があります。 .bashrc などに記述しておきます。 export ANDROID_HOME=~/opt/adt-bundle-linux-x86_64-20130717/sdk 下記のように実行します。 $ gradlew android:installDebug android:run HTML版を動かす 下記のように実行します。 $ ./gradlew html:superDev : : The code server is ready. Next, visit: http://localhost:9876/ いろいろ出力が表示され、最終的に The code server is ready. の表示がされたら、下記にアクセスします。 http://localhost:8080/html/ HTML版は、 String.format メソッドが使えなかったり、 BitmapFontが表示できなかったり制限があるので注意してください。 基本的なクラスについて gdx-setup.jarで作成される雛形は下記のとおりです。 PROJECT_ROOT + android + core + desktop + gradle + html + ios 環境別にディレクトリが切られ、ゲームロジックそのものは core ディレクトリに記述していきます。環境ごとのディレクトリにはそれぞれその環境専用の起動クラス(*Launcher.java)が定義されています。環境に依存するコード(例えば広告表示など)は、この環境別のディレクトリ内に記述してきます。 さて core/src ディレクトリには下記のようなクラスがあります。 package com.zarudama.libgdxtest; import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.SpriteBatch; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; Texture img; @Override public void create () { batch = new SpriteBatch(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); } @Override public void render () { Gdx.gl.glClearColor(1, 0, 0, 1); //画面を赤で塗りつぶし Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); // カラーバッファをクリア batch.begin(); // 描画の開始 batch.draw(img, 0, 0); // テクスチャーを描画 batch.end(); // 描画の終了 } } これは、 gdx-setup.jar で最初に作られる画像を表示するだけのクラスです。 createメソッドは、アプリ内で一度だけ実行される処理を記述し、 renderは毎フレーム呼びだす処理を記述します。renderはつまりメインループとなります。 ApplicationAdapterクラスは、ApplicationListenerインターフェイスを実装したクラスです。 ApplicationListenerインターフェイスは、libGDXでは必ず実装する必要があるため、 ApplicationAdapterクラスが基本的な実装として用意してあります。単純なゲームやテストプログラムであれば、このクラスを継承するだけで良いのですが、実際のゲーム開発では、画面遷移を伴うことが多いはずです。なのでApplicationAdapterクラスに代わり Gameクラスを継承することが多くなります。 Gameクラスは、画面遷移を担当するScreenクラスを扱い、 GameクラスもまたApplicationListenerインターフェイスを実装しています。 \u0026#22259;12: ApplicationListenerクラス SpriteBatchクラスは、libGDXで描画を担当するクラスでこれもまた必ず必要なクラスです。 batch.beginメソッドとbatch.endメソッドの間のdrawメソッドで様々な描画を行ないます。 Textureクラスは名前そのままの画像を扱うクラスです。この例では最もシンプルな画像表示なので、 Textureクラスをそのまま描画していますが、実際には後述するSpriteクラスを介して使用することが多くなるはずです。 文字表示 いろいろテストプログラムを書きたいところですが、まずは文字が表示できないと状態を把握できません。 libGDXはデフォルトで文字描画をサポートしていますので、それを利用します。 下記のように変更してください。diff形式で表示しています。\u0026rdquo;+\u0026ldquo;は追加した行、\u0026rdquo;-\u0026ldquo;は削除した行です。 mikio@gnudam:~/dev/libgdxtest$ git diff diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.java index ad39967..3c84c72 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -4,17 +4,20 @@ import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; +import com.badlogic.gdx.graphics.g2d.BitmapFont; import com.badlogic.gdx.graphics.g2d.SpriteBatch; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; - Texture img; + BitmapFont font; + Texture img; @Override public void create () { batch = new SpriteBatch(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); - } + font = new BitmapFont(); + } @Override public void render () { @@ -22,6 +25,7 @@ public class LibGdxSample extends ApplicationAdapter { Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); batch.draw(img, 0, 0); + font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } + @Override + public void dispose() { + font.dispose(); + batch.dispose(); + img.dispose(); + } } サンプルでは、なぜかリソースを解放する処理が抜けていたので、 disposeメソッドに追加してあります。disposeはアプリケーションの終了処理を記述します。 \u0026#22259;13: 実行画面 スプライトクラスを使用する。 サンプルでは、Textureクラスを直接描画していましたが、 Textureクラスはあくまで画像そのもののクラスであり、ゲーム内で直接扱うのには向いていません。 ゆくゆくは拡大縮小したりアニメーションしたりする必要がでてきますので、そのような操作が扱いやすいSpriteクラスを使用します。 diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.java index 3c84c72..5ab4749 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -5,18 +5,22 @@ import com.badlogic.gdx.Gdx; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.BitmapFont; +import com.badlogic.gdx.graphics.g2d.Sprite; import com.badlogic.gdx.graphics.g2d.SpriteBatch; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; BitmapFont font; Texture img; + Sprite sprite; @Override public void create () { batch = new SpriteBatch(); font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); + sprite = new Sprite(img); } @@ -24,7 +28,7 @@ public class LibGdxSample extends ApplicationAdapter { Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); - batch.draw(img, 0, 0); + sprite.draw(batch); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } このプログラムを実行しても、見た目の変化はありません。 座標系 サンプルプログラムの表示で気づいた方もいるかもしれませんが、libGDXでは座標の原点は左下になります。 座標系に関しては、下記の記事が詳しいです。 http://qiita.com/fslasht/items/d5798516bdbeea49a5d3 要点をまとめると 画面の座標系は左下が原点 スプライトの座標系も左下が原点 スプライトの拡縮時はまんなかが原点 スプライトの回転はまんなかが原点 ただしSprite#setOriginを使えば、中心を変更できる BitMapフォントはなぜか左上が原点(注意!) また、デフォルトで表示されるウィンドウサイズは PC版 640 x 480 Android版 物理画面サイズ Html版 480 x 320 となります。 数値の根拠は以下のソースになります。 https://github.com/libgdx/libgdx/blob/master/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java https://github.com/libgdx/libgdx/blob/master/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidApplicationConfiguration.java /dev/libgdxtest/html/src/com/zarudama/libgdxtest/client/HtmlLauncher.java 画像を動かす 画像の表示ができたのでさっそく動かしてみます。 diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.java index 5ab4749..e97625e 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -2,18 +2,20 @@ package com.zarudama.libgdxtest; import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; +import com.badlogic.gdx.Input; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.BitmapFont; import com.badlogic.gdx.graphics.g2d.Sprite; import com.badlogic.gdx.graphics.g2d.SpriteBatch; +import com.badlogic.gdx.math.Vector2; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; BitmapFont font; Texture img; Sprite sprite; + Vector2 pos; @Override public void create () { @@ -21,14 +23,30 @@ public class LibGdxSample extends ApplicationAdapter { font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); sprite = new Sprite(img); + pos = new Vector2(); } @Override public void render () { + if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) { + pos.x -= 1; + } + if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) { + pos.x += 1; + } + if (Gdx.input.isKeyPressed(Input.Keys.UP)) { + pos.y += 1; + } + if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) { + pos.y -= 1; + } + String info = String.format(\u0026#34;pos(%f,%f)\u0026#34;, pos.x, pos.y); + + sprite.setPosition(pos.x, pos.y); + dx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); sprite.draw(batch); batch.draw(sprite, 0, 0); font.draw(batch, info, 0, 420); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } @Override public void dispose() { font.dispose(); batch.dispose(); img.dispose(); } 座標を扱うのはベクトルクラスが便利なので、posフィールドを追加しています。 また、今自分がいる場所も把握したいので、info変数にposフィールドの値を設定して描画しています。 \u0026#22259;14: spriteを動かす キーボードの入力を得るには、Gdx.input.isKeyPressedメソッドを利用します。どのキーかどうかは、Input.Keysの定数で判定できます。 http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/Input.Keys.html 今回は、キーボードだけの例ですが、Androidで入力を扱うには、タッチされた座標を取得する必要があります。タッチ処理は少し複雑なのでここでは割愛します。 効果音を鳴らす 下記のサイトで適当に音を作りました。 http://www.bfxr.net/ 次からダウンロードできます。 http://mikio.github.com/demo/sound/jump.wav ダウンロードしたファイルを下記に追加してください。 ~/dev/libgdxtest/android/assets/ 下記のように変更します。 mikio@gnudam:~/dev/libgdxtest$ git diff diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.j ava index 5ab4749..cf11ba1 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -2,18 +2,22 @@ package com.zarudama.libgdxtest; import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.Input; +import com.badlogic.gdx.audio.Sound; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.BitmapFont; import com.badlogic.gdx.graphics.g2d.Sprite; import com.badlogic.gdx.graphics.g2d.SpriteBatch; +import com.badlogic.gdx.math.Vector2; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; BitmapFont font; Texture img; Sprite sprite; Vector2 pos; + Sound sound; @Override public void create () { @@ -21,14 +25,35 @@ public class LibGdxSample extends ApplicationAdapter { font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); sprite = new Sprite(img); pos = new Vector2(); + sound = Gdx.audio.newSound(Gdx.files.internal(\u0026#34;jump.wav\u0026#34;)); } @Override public void render () { if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) { pos.x -= 1; } if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) { pos.x += 1; } if (Gdx.input.isKeyPressed(Input.Keys.UP)) { pos.y += 1; } if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) { pos.y -= 1; } String info = String.format(\u0026#34;pos(%f,%f)\u0026#34;, pos.x, pos.y); + if (Gdx.input.isKeyPressed(Input.Keys.SPACE)) { + sound.play(); + } Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); batch.draw(sprite, pos.x, pos.y); font.draw(batch, info, 0, 420); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } @Override public void dispose() { font.dispose(); + sound.dispose(); batch.dispose(); img.dispose(); } soundクラスを使いして、playメソッドを呼ぶだけです。スペースキー押下でジャンプしたような効果音が鳴ります。最後にリソースを解放するのを忘れずに。 BGMを鳴らす 下記のサイトで適当に曲を作りました。 http://soundation.com/ 次からダウンロードできます。 http://mikio.github.com/demo/sound/mixdown.mp3 ダウンロードしたファイルを下記に追加してください。 ~/dev/libgdxtest/android/assets/ 下記のように変更します。 diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.java index 5ab4749..c345ac8 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -2,18 +2,24 @@ package com.zarudama.libgdxtest; import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.Input; +import com.badlogic.gdx.audio.Music; import com.badlogic.gdx.audio.Sound; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.BitmapFont; import com.badlogic.gdx.graphics.g2d.Sprite; import com.badlogic.gdx.graphics.g2d.SpriteBatch; import com.badlogic.gdx.math.Vector2; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; BitmapFont font; Texture img; Sprite sprite; Vector2 pos; Sound sound; + Music music; @Override public void create () { @@ -21,15 +27,48 @@ public class LibGdxSample extends ApplicationAdapter { font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); sprite = new Sprite(img); pos = new Vector2(); sound = Gdx.audio.newSound(Gdx.files.internal(\u0026#34;jump.wav\u0026#34;)); + music = Gdx.audio.newMusic(Gdx.files.internal(\u0026#34;mixdown.mp3\u0026#34;)); + music.setLooping(true); + music.setVolume(0.5f); + music.play(); } @Override public void dispose() { font.dispose(); sound.dispose(); + music.dispose(); batch.dispose(); img.dispose(); } } これもMusicクラスを使用して、playメソッドを呼ぶだけです。ただしBGMなので、ループフラグを有効にし、ボリュームを控えめにしています。簡単ですね。最後にリソースを解放するのを忘れずに。 画像を拡大・縮小・回転してみる 最後に、せっかくスプライトクラスを使っているので、拡縮を試してみます。 下記のように変更してください。 diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.java index e52752e..1c12907 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -20,6 +20,7 @@ public class LibGdxSample extends ApplicationAdapter { Vector2 pos; Sound sound; Music music; + float angle; @Override public void create () { @@ -55,11 +56,15 @@ public class LibGdxSample extends ApplicationAdapter { if (Gdx.input.isKeyPressed(Input.Keys.SPACE)) { sound.play(); } sprite.setPosition(pos.x, pos.y); + sprite.setScale((float) Math.sin(angle)); + angle += 0.04; Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); sprite.draw(batch); font.draw(batch, info, 0, 420); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); angle フィールドを追加し、 Sprite#setScale メソッドで拡縮しています。 sclae値としてマイナスを与えると、画像が反転するようです。 \u0026#22259;15: spriteを拡縮 ついでに回転させてみます。 diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.java index 1c12907..696c158 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -17,6 +17,7 @@ public class LibGdxSample extends ApplicationAdapter { BitmapFont font; Texture img; Sprite sprite; + Sprite sprite2; Vector2 pos; Sound sound; Music music; @@ -28,6 +29,7 @@ public class LibGdxSample extends ApplicationAdapter { font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); sprite = new Sprite(img); + sprite2 = new Sprite(img); pos = new Vector2(); sound = Gdx.audio.newSound(Gdx.files.internal(\u0026#34;jump.wav\u0026#34;)); music = Gdx.audio.newMusic(Gdx.files.internal(\u0026#34;mixdown.mp3\u0026#34;)); @@ -60,11 +62,14 @@ public class LibGdxSample extends ApplicationAdapter { sprite.setScale((float) Math.sin(angle)); angle += 0.04; + sprite2.setPosition(200, 300); + sprite2.setRotation(angle); + Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); sprite.draw(batch); + sprite2.draw(batch); font.draw(batch, info, 0, 420); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); 効果がわかりにくいので、sprite2フィールドを追加し、スプライトを2つにしました。このようにスプライトを追加しても画像は共有できます。回転は、Sprite#setRotationメソッドで実施しています。 \u0026#22259;16: spriteを回転 これ以上の詳しいSpriteクラスの操作は下記のAPIマニュアルを参照してください。 http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g2d/Sprite.html ソース 最後にソースの全体を載せておきます。 package com.zarudama.libgdxtest; import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.Input; import com.badlogic.gdx.audio.Music; import com.badlogic.gdx.audio.Sound; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.BitmapFont; import com.badlogic.gdx.graphics.g2d.Sprite; import com.badlogic.gdx.graphics.g2d.SpriteBatch; import com.badlogic.gdx.math.Vector2; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; BitmapFont font; Texture img; Sprite sprite; Sprite sprite2; Vector2 pos; Sound sound; Music music; float angle; @Override public void create () { batch = new SpriteBatch(); font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); sprite = new Sprite(img); sprite2 = new Sprite(img); pos = new Vector2(); sound = Gdx.audio.newSound(Gdx.files.internal(\u0026#34;jump.wav\u0026#34;)); music = Gdx.audio.newMusic(Gdx.files.internal(\u0026#34;mixdown.mp3\u0026#34;)); music.setLooping(true); music.setVolume(0.5f); music.play(); } @Override public void render () { if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) { pos.x -= 1; } if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) { pos.x += 1; } if (Gdx.input.isKeyPressed(Input.Keys.UP)) { pos.y += 1; } if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) { pos.y -= 1; } //String info = String.format(\u0026#34;pos(%f,%f)\u0026#34;, pos.x, pos.y); String info = \u0026#34;\u0026#34;; //html版ではコンパイルできない。 if (Gdx.input.isKeyPressed(Input.Keys.SPACE)) { sound.play(); } sprite.setPosition(pos.x, pos.y); sprite.setScale((float) Math.sin(angle)); angle += 0.04; sprite2.setPosition(200, 300); sprite2.setRotation(angle); Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); sprite.draw(batch); sprite2.draw(batch); font.draw(batch, info, 0, 420); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } @Override public void dispose() { sound.dispose(); music.dispose(); batch.dispose(); font.dispose(); img.dispose(); } } おわりに この記事ではゲームプログラミングに最低限必要な以下の方法を学びました。 画像の表示 キーボードの入力 サウンド・BGMの再生 これで一応ゲームは開発できるはずです。でもこれは最低限の方法なので、まだまだいろいろ考慮しなくてはなりません。例えば、 タッチ処理 アニメーション 物理画面に依存しない画面表示 画面遷移 などなどです。 次回 は、これらの処理を学んでいきます。 参考書籍 \"\" \" width=\"1\" height=\"1\" border=\"0\" alt=\"\" style=\"border:none !important; margin:0px !important;\" / libGDXの作者が書いた本。Androidでゲームを作るための基本を独自のフレームワーク作成を通して解説しています。 libGDXの解説ではないけれど、その思想は当然libGDXにも引き継がれています。もちろんlibGDXの理解もしやすくなります。また、Androidの本ではありますが、スマホに特化したわけでもなく、どんなゲーム開発にも通用しそうな内容ばかりです。実践的かつ基本的で自分は退屈せずに読めました(特にMVCについての言及が良い)。そういう意味でこの本は、すべての初級ゲーム開発者におすすめできる本かと思います。ただし一部内容が古いので注意してください(沢山売れて第2版が翻訳されればいいんですが)。それでもlibGDXをやるなら読んでいて損はないと思います。"
},
{
url: "https://zarudama.github.io/post/2014/06/libgdx02/",
title: "libGDX入門 その02 カメラとビューポート",
date: "2019-11-08T16:24:00+09:00",
body: "libGDX入門 その02 カメラとビューポート \u0026#30446;\u0026#27425; はじめに 物理画面に依存しない画面表示 カメラとビューポート 実際のコーディング カメラの導入 ビューポートの導入 背景の追加 カメラの位置調整 ワールド軸の描画 setToOrthメソッド カメラを動かす UI用カメラの導入 Windowサイズの変更 タッチ処理 ソース おわりに 参考URL 参考書籍 変更履歴 はじめに libGDX を勉強するついでに解説記事を書く シリーズ 2回目です。 前回 は、プロジェクトを作って、以下のことを学びました。 画像の表示 キーボードによる操作 BGMの再生 効果音の再生 今回は次のことを学びます。 物理画面に依存しない画面表示 タッチ処理 物理画面に依存しない画面表示 物理画面とは何でしょうか？ここでは次のように定義します。 スマホやタブレット画面解像度 デスクトップのウィンドウサイズ Androidには様々な画面サイズがありますし、 iPhoneもモデルチェンジ毎に画面サイズが変化しています。これら様々な画面サイズのことを考慮しないと、意図した通りの画面が表示できません。 ゲームを作るときの基本として、物理画面でプログラムしないというのがあります。物理的なディスプレイのサイズに依存した座標管理をすると、移植性が下がり仕様変更に弱くなったり、端末毎の画面サイズの違いを吸収できないプログラムになってしまいます。 例えば横スクロールアクションを作ったときに、 Aさんの画面は小さいから敵の動きがところ狭しとなるところが、 Bさんの端末だと画面が大きいからフィールドが遠くまで見わたせて楽々プレイできる、なんてことが発生します。端末によって難易度が変わってくるのです。 \u0026#22259;1: 端末の小さいAさんは、端末の大きいBさんより不利になる 実は既にこの問題は、私の手元で発生しています。下記は、Nexus7(2013)で表示したサンプルの画面です。 \u0026#22259;2: nexus7の画面 \u0026#22259;3: PC版の画面 Nexus7版は、PCの画面と全然違いますね。キャラクターや文字が非常に小さくなってます。これはPC版が640x480の解像度なのに対して、Nexus7版は1920x1200の解像度で表示しているからです。この状態でゲームを作ってしまったら全然別ものになってしまいますよね。ちなみにMac持ってないのでiOS系ではどうなるかわかりません。 というわけで、どの端末でも公平に画面表示できるようにひと工夫必要になってきます (こういう処理は、ゲームづくりの序盤でやっておかないと、あとから変更するのは大変なのでさっさと済ませておきたいことのひとつですね)。 カメラとビューポート ではどうやってこの問題を解決するか。それにはカメラとビューポートを使用します。 カメラとは、ゲームの世界を現実世界のディスプレイに届けるためのオブジェクトです。 ビューポートとは、カメラの捉えたゲームの世界を、ディスプレイのどこに表示するかを決める枠(矩形領域)のことです。 \u0026#22259;4: カメラとビューポート ビューポートは、ディスプレイサイズと一致しているわけではないことに注意してください。ゲームのサンプルなどだと一致していることが多いですが、今回のように様々なディスプレイサイズに対応させる場合は、一致しなくなることの方が多くなるはずです。また、他の使い方としては、カメラを2つ用意して一方はゲーム画面、一方は小さな枠で別のシーンを表示するなんてこともできるかもしれません(やったことないですが)。 カメラを使うことにより、カメラとして定義した論理空間でゲームを制御できます。この空間でやりとりすれば、あとはlibGDXがよろしく画面に表示してくれるわけです。カメラでできることを列挙してみます。 物理的な画面サイズを気にせず、自分の定義した画面サイズでゲームを構築できる ズームイン、ズームアウト、画面を回転させたり、揺らしたりなど、画面全体にかかるエフェクトが簡単にできる カメラを動かすことで、スクロール処理が簡単に実装できる カメラを導入することでこのような自由が手に入るわけですが、その代償として操作が複雑になってしまうのも事実です。コーディング中は、今自分がどこの座標系で何を操作しているかを常に意識する必要があります。ちょっと大袈裟ですが、慣れれば大したことありません。またこの考えはそのまま3Dプログラミングにも繋がります。 座標系には、以下の種類があります。 ワールド座標系。ゲームオブジェクトを置く論理空間。画面サイズは気にしなくて良い。 カメラ座標系。ワールドのゲームオブジェクトをカメラの枠での座標系で測りなおした座標系。真ん中が原点となる。 ビューポート座標系。左下を原点とした座標系。 スクリーン座標系。Android左上を原点とした最終的な座標系。タッチ座標などはOSからこの座標系の値が得られる。 ビューポート座標系とスクリーン座標系は他では別の呼びかたかもしれません。座標系を意識する例を示します。 たとえば、画面をタッチして、その座標にキャラクターが向って行くのであれば、タッチ操作で得られた座標(スクリーン座標系)をワールド座標系に変換する必要があります。 逆にワールドに落ちているコインなどのアイテムを画面UIのスコア表示に吸いこまれるようなエフェクトをかけるときは、ワールドからスクリーンへの変換が必要になるでしょう。 カメラを使用しなくてもゲームは作れますが、いろいろと応用が効くので、パズルゲームのような固定画面のゲームしか使わない予定であっても、使いかたに慣れておいたほうが良いと思います。 実際のコーディング 講釈が多くなってしまいました。実際のコーディングに進みます。まずゲームに使用する画面解像度を決定します。これは、物理的なサイズではなく、論理的なものです。今回は下記のように定義しました。 横800 x 縦480 横長の割と無難なサイズです。 カメラの導入 では早速カメラを導入してみましょう。前回のソースコードに手を入れていきます。前回のサンプルでは、画面サイズはデフォルトのままでしたが、今回はターゲットサイズを横800 x 縦480に設定したので、 createメソッド内でカメラを下記のように定義します。 OrthographicCamera camera; @Override public void create () { ： camera = new OrthographicCamera(800, 480); ： } フィールドに camera を追加しています。ちなみになぜこんな長たらしい名前がついてるのかわかりませんが、 2D用のカメラは、 OrthographicCamera クラスといいます。 libGDXのソースコードを見渡しましたが、他に2D用のカメラは見当たらなかったので OrthographicCamera は2D専用と思って問題ないでしょう。 続いて、描画にカメラを反映させるため、 render メソッドを変更します。 @Override public void render() { : Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); camera.update(); // 追加 #1 batch.setProjectionMatrix(camera.combined); // 追加 #2 batch.begin(); sprite.draw(batch); : } #1 でカメラ自身の座標計算(行列演算)をし、 #2 でその結果をスプライトに適用させる準備をします。この処理は定型処理なので、最初のうちは決めごとと思って問題ありません。 ここまでの実行結果は下記のとおりです。 \u0026#22259;5: とりあえずカメラ導入 なにか変です。画像のサイズが以前に比べて縦長になっています。なぜでしょうか？ ビューポートの導入 原因はビューポートの設定にあります。libGDXは、デフォルトのビューポート設定だと、物理画面いっぱいに最終画像を引き伸ばします。今回の場合、カメラの設定を 800x480 に設定したのに対し、実際のウィンドウサイズが 640 x 480 のため歪みがでてしまったのです(横方向に潰れている)。 では、ビューポートはどのように設定すれば良いのでしょうか？ libGDXは、OpenGLを直接操作する低レイヤのメソッドも用意してますので、自分で直接ビューポートをやりくりすることもできます。しかし、libGDXには、このような面倒な作業を請け負ってくれる、高レイヤの ViewPort クラスがあります。今回は、この便利クラスを使うことにしましょう。 フィールドに viewport を追加し、createメソッド内でビューポートを定義します。 OrthographicCamera camera; Viewport viewport; // 追加 @Override public void create () { ： camera = new OrthographicCamera(800, 480); viewport = new FitViewport(800, 480, camera); // 追加 ： } ViewPort はスーパークラスであり、このクラスを継承した様々なクラスがあります。インスンタンスを設定する際には、用途に応じたViewPort継承クラスを指定する必要があります。今回は、 FitViewport クラスを利用します。 続いて resize メソッドを追加します。 resize メソッドは、 ApplicationListener クラスのメソッドであり、画面の向きが変わったり、アプリケーションが起動したタイミングなどで呼ばれます。 @Override public void resize(int width, int height) { viewport.update(width, height); } ビューポートは画面の大きさが変化した時だけ設定すれば良いため、 resize メソッドから呼びだすだけでよく、 render メソッドなどで呼びだす必要はありません。 ここまでの実行結果は下記のとおりです。 \u0026#22259;6: とりあえずビューポートも導入 やった、歪みがなくなりました! しかし、ここでひとつおかしいことに気づかないでしょうか？カメラとビューポートのサイズには 800x480 を設定しました。でも、このサンプルのウィンドウサイズは 640x480 です。なぜ表示できるんでしょうか？ このままでは、背景となる塗りつぶし色の赤と、ビューポートの枠の区別がつきにくため、ビューポートの働きがわかりつらくなっています。そこで、 FitViewPort の動きを分かりやすくするために、大きなサイズの画像を背景として表示してみます。 背景の追加 背景用に次の画像を「右クリ→名前をつけて保存」で保存してください。 \u0026#22259;7: 背景 保存したファイルを下記に追加してください。 ~/dev/libgdxtest/android/assets/ 下記のように変更します。 フィールド Texture bgImg; // 追加 Sprite bg; // 追加 create メソッド @Override public void create () { : // 追加 bgImg = new Texture(\u0026#34;bg.png\u0026#34;); bg = new Sprite(bgImg); bg.setScale(2.0f, 2.0f); bg.setPosition(-400, -240); : render メソッド @Override public void render() { : batch.setProjectionMatrix(camera.combined); batch.begin(); bg.draw(batch); // 追加 sprite.draw(batch); sprite2.draw(batch); : dispose メソッド @Override public void dispose() { : bgImg.dispose(); } これで実行してみます。 \u0026#22259;8: 背景を追加 するとどうでしょう？赤い枠が上下に出現しています。これは、 FitViewPort がウィンドウサイズからビューポートのサイズを自動計算して当初の縦横比を保ってくれるからなのです。 試しにウィンドウサイズを色々マウスでドラッグして変化させてみてください。 \u0026#22259;9: ウィンドウを横長にしてみた \u0026#22259;10: ウィンドウを縦長にしてみた こんな風に画面のサイズに応じて、ビューポートのサイズを動的に変化さてくれます。画面の短い辺に対して最大のサイズを割りあて、長い辺に大してはその比率を調整するようですね。 もちろんNexus7の実機でもうまく表示できています。 \u0026#22259;11: ちにみにこれはNexus7の2012年度版 このように、 FitViewPort クラスを使うことにより、どのような画面サイズであっても、こちらの意図したとおりの画面比率で表示されるようになります。 ViewPort クラスには他にも様々な種類のクラスがあります。いろいろ試してみてください。 https://github.com/libgdx/libgdx/wiki/Viewports ちなみに上記ビューポートの解説は、下記のよう辿るといきつけます。 https://github.com/libgdx/libgdx/wiki → Scene2d → ViewPort カメラの位置調整 以上で、カメラとビューポートの導入を終えたのですが、まだおかしいところがあります。どこでしょうか？ 実はスプライト画像がひとつしか表示されてません。本来は2つ表示されているハズなのですが。最初の時はこうでした。 \u0026#22259;12: PC版の画面(再掲) 何が起きているかというと、カメラの位置がおかしいのです。カメラはスプライトと違って、真ん中が原点となります。なので、ワールド原点を中心とした枠が表示されているのです。 \u0026#22259;13: カメラはワールド原点(0,0)に位置している 左上が(-400,240),右上が(400,240),右下が(400,-240),左下が(-400,-240)の枠となっています。このために2つめのスプライトがちょうど右上の枠の外に位置しており、画面から消えてしまっているのです。 ワールド軸の描画 ここで、見た目をわかりやすくするためにワールドの座標軸を描画してみます。 インポート import com.badlogic.gdx.graphics.glutils.ShapeRenderer; フィールド ShapeRenderer shapeRenderer; // 追加 create メソッド @Override public void create () { : // 追加 shapeRenderer = new ShapeRenderer(); : render メソッド @Override public void render() { : // ワールド座標軸を描画する。 shapeRenderer.setProjectionMatrix(camera.combined); shapeRenderer.begin(ShapeRenderer.ShapeType.Line); shapeRenderer.setColor(1, 0, 0, 1); shapeRenderer.line(-1024, 0, 1024, 0); shapeRenderer.setColor(0, 1, 0, 1); shapeRenderer.line(0, -1024, 0, 1024); shapeRenderer.end(); : dispose メソッド @Override public void dispose() { : shapeRenderer.dispose(); } これで実行してみます。 \u0026#22259;14: カメラをsetToOrthoした結果 X軸を赤、Y軸を緑で描画しています。これで状況がよりわかりやすくなったと思います。 setToOrthメソッド 画面の原点を左下に調整するというのはよくあることなので、専用のメソッドが用意されています。 そこで試しに下記のメソッドを追記してみましょう。 create メソッド @Override public void create () { : camera = new OrthographicCamera(800,480); camera.setToOrtho(false, 800, 480); // 追加 : } Camera#setToOrtho メソッドは、カメラを右上に移動させて、左下に丁度ワールド原点がくるように調整するものです。第1引数は、ydownといって、trueにするとY軸が反転されますが、通常はfalseで良いと思います。第2引数と第3引数は、カメラのの幅と高さです。 setToOrth をコンストラクタに続けて指定する時は、コンストラクタには、サイズ指定はいらないですね(今回は修正が面倒なのでそのまま)。 これを実行すると以下のように表示されます。 \u0026#22259;15: カメラをsetToOrthoした結果 無事カメラが移動されて、2つ目のスプライトも表示されるようになりました。 カメラを動かす こんどはカメラをキーボードで動かしてみましょう。 render メソッドで下記のように追記します。 @Override public void render() { if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) { //pos.x -= 1; // 削除 camera.position.x -= 2; // 追加 } if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) { //pos.x += 1; // 削除 camera.position.x += 2; // 追加 } if (Gdx.input.isKeyPressed(Input.Keys.UP)) { //pos.y += 1; // 削除 camera.position.y += 2; // 追加 } if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) { //pos.y -= 1; // 削除 camera.position.y -= 2; // 追加 } pos ベクトルへの処理を削除し、変わりに camera.position への処理を追加します。これを実行すると以下のように表示されます。 \u0026#22259;16: カメラを動かしている様子 カーソルキーでカメラを動かしてみてください。背景のBG画像があまり大きくないので端にいくと表示が変な見ためになるので注意です。 ここで、カメラが本当に動いているのか数値からも判断するため、カメラの座標を表示してみます。 render メソッドで下記のように追記します。 @Override public void render() { ： // カメラの座標の文字列を作って String info = String.format(\u0026#34;cam pos(%f,%f)\u0026#34;, camera.position.x, camera.position.y); batch.setProjectionMatrix(camera.combined); batch.begin(); ： font.draw(batch, info, 0, 20); // 追加 ： batch.begin(); 座標は大体左したに表示されるように指定しています。 これを実行すると以下のように表示されます。 \u0026#22259;17: カメラの座標を表示してみる 左下に表示されてますね。ではカーソルキーでカメラを動かしてみてください。 \u0026#22259;18: カメラの座標文字がついてこない？! あれ、期待した動きと違ってませんか？ 私は違いました。どう動いて欲しかったというと、画面にひっついて常に左下に表示して欲しいと思いました。 実は、このフォント描画はワールド座標に対して行なわれているのです。フォント文字もワールドに存在するスプライトと同じオブジェクトとして描画されているんですね。 これを画面にひっつかせて描画させるには、ひと工夫必要です。 UI用カメラの導入 答えは簡単です。もうひとつカメラを用意すれば良いのです。 UI専用のカメラを準備して、そのカメラは動かさずにおく。これだけでオッケーです(libGDXのサンプルでもやっている方法です)。 フィールド OrthographicCamera uiCamera; // 追加 create メソッド @Override public void create () { : // 追加 uiCamera = new OrthographicCamera(); uiCamera.setToOrtho(false, 800, 480); : render メソッド @Override public void render() { : //font.draw(batch, info, 0, 20); //font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); : // render の一番最後で描画すること uiCamera.update(); batch.setProjectionMatrix(uiCamera.combined); batch.begin(); font.draw(batch, info, 0, 20); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } 以前の font.draw はコメントアウトもしくは、削除します。注意すべき点は、UIの描画物は render メソッド内の一番最後で描画するということです。これは、画面上の一番上に描画するためです。 実行してみます。 \u0026#22259;19: UIカメラを追加してみた おおお、無事希望どおりの動きになりました! さて、ここで気になることがあります。それは、画面サイズとして 800x480 を指定しているにも関わらず、ウィンドウサイズが 640x480 のままだということです。 Windowサイズの変更 スマホなどの端末は、ハードウェアなので画面サイズを変更できませんが、 Desktop版は、ウィンドウなので、初期サイズを変更できます。 下記のファイルを編集すればオッケーです。 ~/dev/libgdxtest/desktop/src/com/zarudama/libgdxtest/desktop/DesktopLauncher.javapublic class DesktopLauncher { public static void main (String[] arg) { LwjglApplicationConfiguration config = new LwjglApplicationConfiguration(); config.width = 800; // 追加 config.height = 480; // 追加 new LwjglApplication(new LibGdxSample(), config); } } 実行結果です。 \u0026#22259;20: UIカメラを追加してみた 画面サイズと論理サイズが一致したので赤い帯がなくなりましたね! タッチ処理 いよいよ最後のお題です。私も疲れてきました^^。 前回は、キーボード入力の処理方法は学んだもののスマホ特有の処理、タッチ操作の処理方法は先送りにしていました。 指でタッチしているかどうかを検知するには、 Gdx.input.isTouched メソッドを使用します。 if (Gdx.input.isTouched(0)) { : // なにかの処理 : } このメソッドの引数には番号が必要ですが、これはタッチした指の番号です。最初にタッチした指の番号は0, 2番目にタッチした座標の番号は1という具合です。 タッチの座標を得るには、 Gdx.input.getX , Gdx.input.getY メソッドを使用します。 float x0 = Gdx.input.getX(0); float y0 = Gdx.input.getY(0); 番号は先程の説明と同じ意味です。 ただしこの座標、注意が必要で、得られる座標は、画面左上を原点とします。 x座標は左から右、Y座標は上から下に伸びます。 \u0026#22259;21: スクリーン座標系 この座標系は一般的にはスクリーン座標系などと呼ばれ、最終的な絶対座標(物理座標)として使われるものですが、libGDXでは左下を原点とした座標のためこのままでは使用できません。 ただし私たちは今回カメラを導入しています。なのでカメラの便利メソッドで簡単に変換できます。こんな感じです。 Vector3 touchPos = new Vector3(); touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0); camera.unproject(touchPos); // #1 targetPos.set(touchPos.x, touchPos.y); #1 で、スクリーン座標で得た左上を原点とした座標をワールドの座標に変換します。 2013/06/19 追記 上記説明には、誤りがありました。カメラだけを使用している場合は、 Camera#unproject() メソッドで良いのですが、 Viewport クラスを使用している場合は、 Viewport#unproject() メソッドを使用する必要があります。従って今回は、 Viewport#unproject() を使用しなければなりません。説明はこのままにしておきますが、ソースコードの方は訂正してあります。 この処理を if で囲ってあげれば判定処理の出来あがりです。 if (Gdx.input.isTouched(0)) { Vector3 touchPos = new Vector3(); touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0); camera.unproject(touchPos); // #1 targetPos.set(touchPos.x, touchPos.y); } Gdx.input.isTouched メソッドは、タッチし続けてれば、毎フレーム「真」になります。 他にタッチを検出するメソッドとして、 Gdx.input.justTouched メソッドがあります。このメソッドは、ひとつ前のフレームにタッチしていた場合は、偽になります。どういうことかというと、押しっぱなしにしてた場合は、最初の一回しか真にならないということです。 例えば、下記のようなコードで、タッチした時だけ音を鳴らすことができます。 if (Gdx.input.justTouched()) { sound.play(); } ちなみにjustTouchedと同等の機能のキーボード版のメソッドはありません。恐らく、このメソッドの実装には、状態変数の保持が必要になってくるので、そこをライブラリ側で実装してしまうと無駄が多くなるので、ユーザー側に任せたのだと思います。 では、上記の説明をもとに、スプライトをタッチした場所へ移動させるコードを追加します。下記のように修正してみてください。 インポート。 import com.badlogic.gdx.math.Vector3; フィールド。 Vector2 targetPos; render メソッド。キーボード処理の直後に追加します。 @Override public void render() { ： if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) { pos.y -= 1; camera.position.y -= 2; } : // ↓追加 if (Gdx.input.justTouched()) { sound.play(); } if (Gdx.input.isTouched(0)) { Vector3 touchPos = new Vector3(); touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0); camera.unproject(touchPos); targetPos.set(touchPos.x, touchPos.y); } // ↑追加 String info = String.format(\u0026#34;cam pos(%f,%f)\u0026#34;, camera.position.x, camera.position.y); // ↓追加 pos.lerp(targetPos, 0.2f); sprite.setPosition(pos.x, pos.y); // ↑追加 ： } render メソッド内で実行している pos.lerp メソッドは、第一引数の座標へ値を少しずつ近づけていく処理を実施します。「最初早くて後おそく」って感じの動きです。 では、実行してみます。 \u0026#22259;22: マウスでクリックすると、音を鳴らしながら移動します これまでのコードを忠実に入力していれば、音をビヨーンとならしながら移動します。 以上で今回の解説は終了です。お疲れさまでした。 ソース 最後に今回のソースコードを掲載しておきます。 package com.zarudama.libgdxtest; import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.Input; import com.badlogic.gdx.audio.Music; import com.badlogic.gdx.audio.Sound; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.OrthographicCamera; import com.badlogic.gdx.graphics.PerspectiveCamera; import com.badlogic.gdx.graphics.Camera; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.BitmapFont; import com.badlogic.gdx.graphics.g2d.Sprite; import com.badlogic.gdx.graphics.g2d.SpriteBatch; import com.badlogic.gdx.math.Vector2; import com.badlogic.gdx.math.Vector3; import com.badlogic.gdx.utils.viewport.FitViewport; import com.badlogic.gdx.utils.viewport.FillViewport; import com.badlogic.gdx.utils.viewport.StretchViewport; import com.badlogic.gdx.utils.viewport.ScreenViewport; import com.badlogic.gdx.utils.viewport.ExtendViewport; import com.badlogic.gdx.utils.viewport.Viewport; import com.badlogic.gdx.graphics.glutils.ShapeRenderer; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; BitmapFont font; Texture img; Sprite sprite; Sprite sprite2; Vector2 pos; Sound sound; Music music; float angle; OrthographicCamera camera; Viewport viewport; Texture bgImg; Sprite bg; ShapeRenderer shapeRenderer; OrthographicCamera uiCamera; Vector2 targetPos; @Override public void create () { batch = new SpriteBatch(); font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); sprite = new Sprite(img); sprite2 = new Sprite(img); pos = new Vector2(); sound = Gdx.audio.newSound(Gdx.files.internal(\u0026#34;jump.wav\u0026#34;)); music = Gdx.audio.newMusic(Gdx.files.internal(\u0026#34;mixdown.mp3\u0026#34;)); music.setLooping(true); music.setVolume(0.5f); music.play(); bgImg = new Texture(\u0026#34;bg.png\u0026#34;); bg = new Sprite(bgImg); bg.setScale(2.0f, 2.0f); bg.setPosition(-400, -240); camera = new OrthographicCamera(800,480); camera.setToOrtho(false, 800, 480); viewport = new FitViewport(800, 480, camera); uiCamera = new OrthographicCamera(); uiCamera.setToOrtho(false, 800, 480); shapeRenderer = new ShapeRenderer(); targetPos = new Vector2(); } @Override public void resize(int width, int height) { viewport.update(width, height); } @Override public void render() { if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) { camera.position.x -= 2; } if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) { camera.position.x += 2; } if (Gdx.input.isKeyPressed(Input.Keys.UP)) { camera.position.y += 2; } if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) { camera.position.y -= 2; } if (Gdx.input.justTouched()) { sound.play(); } if (Gdx.input.isTouched(0)) { Vector3 touchPos = new Vector3(); touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0); viewport.unproject(touchPos); targetPos.set(touchPos.x, touchPos.y); } String info = String.format(\u0026#34;cam pos(%f,%f)\u0026#34;, camera.position.x, camera.position.y); pos.lerp(targetPos, 0.2f); sprite.setPosition(pos.x, pos.y); sprite.setScale((float) Math.sin(angle)); angle += 0.04; sprite2.setRotation(angle); sprite2.setPosition(200, 300); sprite2.setRotation(angle); Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); camera.update(); // ワールドからスクリーンまでのマトリックスを生成する。 batch.setProjectionMatrix(camera.combined); batch.begin(); bg.draw(batch); sprite.draw(batch); sprite2.draw(batch); batch.end(); // ワールド座標軸を描画する。 shapeRenderer.setProjectionMatrix(camera.combined); shapeRenderer.begin(ShapeRenderer.ShapeType.Line); shapeRenderer.setColor(1, 0, 0, 1); shapeRenderer.line(-1024, 0, 1024, 0); shapeRenderer.setColor(0, 1, 0, 1); shapeRenderer.line(0, -1024, 0, 1024); shapeRenderer.end(); uiCamera.update(); // uiCameraを動かさないのであれば、必要ない。 batch.setProjectionMatrix(uiCamera.combined); batch.begin(); font.draw(batch, info, 0, 20); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } @Override public void dispose() { sound.dispose(); music.dispose(); batch.dispose(); font.dispose(); img.dispose(); bgImg.dispose(); shapeRenderer.dispose(); } } おわりに 面倒だけど重要な説明が終りました。これで、端末の画面サイズを気にせずプログラミングできるようになりました。 次回 は、そろそろゲームっぽいものをつくろうかなと思います。予定している内容は、 アニメーション処理 画面遷移 2DScene などです。 参考URL ビューポートについては下記にも詳しい内容があります。合せて読めば理解も深まると思います。 http://qiita.com/fslasht/items/13dbf31277ad43e50b85 http://qiita.com/fslasht/items/c0830eaf05b7a91b8e85 参考書籍 \"\" \" width=\"1\" height=\"1\" border=\"0\" alt=\"\" style=\"border:none !important; margin:0px !important;\" / libGDXの作者が書いた本です。Androidでゲームを作るための基本を独自のフレームワーク作成を通して解説しています。 libGDXの解説ではないけれど、その思想は当然libGDXにも引き継がれています。もちろんlibGDXの理解もしやすくなります。また、Androidの本ではありますが、スマホに特化した内容ばかりではなく、どんなゲーム開発にも通用しそうな内容ばかりです。実践的かつ基本的で自分は退屈せずに読めました(特にMVCについての言及が良い)。そういう意味でこの本は、すべての初級ゲーム開発者におすすめできる本かと思います。ただし一部内容が古いので注意してください(沢山売れて第2版が翻訳されればいいんですが)。それでもlibGDXをやるなら読んでいて損はないと思います。 変更履歴 2014/06/19 タッチ座標の取得方法に問題があったのを訂正した。"
},
{
url: "https://zarudama.github.io/post/2014/06/libgdx03/",
title: "libGDX入門 その03 ログ出力とアニメーションとバーチャルパッド",
date: "2019-11-08T16:24:00+09:00",
body: "libGDX入門 その03 ログ出力とアニメーションとバーチャルパッド \u0026#30446;\u0026#27425; はじめに ログの出しかた スプライトアニメーション バーチャルパッド テクスチャラップ ソースコード 今回の記事のアセット一覧 テクスチャ 背景 BGM おわりに 参考書籍 変更履歴 2014/6/21 注釈 はじめに tag libGDX libGDX入門 libGDX を勉強するついでに解説記事を書く シリーズ 3回目です。 前回 は、以下のことを学びました。 カメラとビューポート タッチ処理 今回は次のことを学びます。 ログ出力 スプライト表示のアニメーション テクスチャラップ バーチャルパッド 前回までは、最初の雛形コードに徐々にコードを継ぎたして完成させるというチュートリアル形式でしたが、実際にコードを入力しながら実行していくのは少ないんじゃないかという疑問と(自分も含めて)、記事を書くのが大変なので(手抜き)、最初に一気に解説し、最後にコードを載せるスタイルにします。 ログの出しかた プログラムの動作を追うとき、ログ出力はとても重宝しますよね。デバッガもいいですが、私は昔ながらのデバッグプリントで追うのが好きです。 ということで、ログ出力の方法を解説します。 公式から引用します。 Gdx.app.log(\u0026#34;MyTag\u0026#34;, \u0026#34;my informative message\u0026#34;); Gdx.app.error(\u0026#34;MyTag\u0026#34;, \u0026#34;my error message\u0026#34;, exception); Gdx.app.debug(\u0026#34;MyTag\u0026#34;, \u0026#34;my error message\u0026#34;); log メソッドは普通に情報を出力したい場合、 error メソッドは、例外を共なうようなエラー出力(第3引数にはException型)をしたい場合、 debug メソッドは開発時のみ出力したい場合に使用します。 第一引数の MyTag は識別子ですね。一般的にはにはクラス名などが多いようです。自分は下記のようにクラスフィールドを定義しておき、この LOG_TAG を使用します。 public static final String LOG_TAG = GameScreen.class.getSimpleName(); こんな感じです。 Gdx.app.log(LOG_TAG, \u0026#34;my informative message\u0026#34;); 次のように表示されます。 GameScreen: my informative message こうするとログ出力にクラス名も一緒に表示されるので、どこで出力したメッセージか一目でわかるので便利です。 これらのログ出力は、ログのレベルを指定することでメッセージの出力範囲を制御できます。 下記のように指定します。 Gdx.app.setLogLevel(Application.LOG_DEBUG); 上はデバッグレベルを指定しています。 ログレベルには下記の4種類あります。 Application.LOG_NONE 全てのログを無効にします。 Application.LOG_DEBUG 全てのログを出力します。 Application.LOG_ERROR errorメソッドのログだけ出力します。 Application.LOG_INFO logとerrorメソッドのログを出力します。 開発時は、DEBUGレベル、リリース時は、NONEレベルですかね。パフォーマンス重視の場合は、ログメソッドはリリース時に全て削除したほうがいいです。 公式情報は下記にあります。 https://github.com/libgdx/libgdx/wiki/Logging スプライトアニメーション 前回までは静止画を拡縮機能で伸び縮みさせただけでした。今回は、パターンをつくってアニメーションさせて見ます。アニメーションさせるとグっとゲーム感が増します。 完成したプログラムのスクリーンショットです。 \u0026#22259;1: 完成したプログラム 仕様としては、 ターゲット解像度はファミコンライク(16:9の256 x 144ドット) 16x16ドットの猫のキャラを表示 待機モーションあり 走りモーションあり 左右に移動 バーチャルパッド って感じにしました。 そして作ったのがこれ。 \u0026#22259;2: ねこの画像 左から 待機1, 待機2, 走り1, 走り2, 走り3 と計5コマのスプライトアニメとなっております。猫の画像の下には、左右に動かすためのボタンがあります。 画像のサイズは、256x256にしてあります。使用している画像サイズを考えると大きすぎますが、一般的には、画像のサイズは512x512,1024x1024あたりがVRAMへの転送効率が良いと言われており、今回は、単に512だと大きすぎて作業しずらかったので512の半分の256にしました。画像サイズは2のn乗でないと効率的に扱えないことが多いので、512あたりのサイズが無難です。 また、画像の単位を16x16ドットのセル単位で描くようにしています。こうすることによりコード内での単位が統一されプログラミングしやすくなります。 スプライトをアニメーションさせるには、 Animation クラスを使用します。今回は、走りモーションと待機モーションが2種類あり、左右分用意するため、合計4種類のアニメーションが必要になります。 下記のフィールドを準備します。 private Animation animLeft; private Animation animRight; private Animation animIdleLeft; private Animation animIdleRight; private float stateTime = 0; アニメーションの具体的なコードは下記になります。 TextureRegion[] split = new TextureRegion(img).split(16, 16)[0]; // #1 TextureRegion[] mirror = new TextureRegion(img).split(16, 16)[0]; // #2 for (TextureRegion region : mirror) // #3 region.flip(true, false); animRight = new Animation(0.1f, split[2], split[3], split[4]); // #4 animLeft = new Animation(0.1f, mirror[2], mirror[3], mirror[4]); animIdleRight = new Animation(0.5f, split[0], split[1]); animIdleLeft = new Animation(0.5f, mirror[0], mirror[1]); stateTime = 0; // #5 TextureRegion クラスは、ある一枚のテクスチャの一部の矩形情報をもったオブジェクトです。テクスチャにひとつの画像しかない場合は、 Texutre オブジェクトをそのまま利用しますが、今回のように1枚の画像にいろいろな画像を詰めこんである場合は、 TexutreRegion オブジェクトを利用します。 TextureRegion にアニメーションの1コマ1コマを格納し、その TextureRegion を描画することでアニメーションさせます。 #1 では、 TextureRegion#split() メソッドで img テクスチャを16x16(単位はピクセル)のセルで分割し、 TextureRegion の2次元配列を取得します。同時にその2次元配列の1行目を取得することで、テクスチャの最初の行の画像(猫のアニメーションパターン)を取得しています。 (今回は、1行目だけが必要なので、0固定です)。 #2 では、 #1 と同様ですが、左向きのデータを得るために、 #3 でデータを左右反転しています。 TexutreRegion#flip() メソッドの第一引数は、x軸、第二引数は、Y軸の反転指定になります。この場合はX軸のみ指定しています。これで左向きのアニメーションパターンを手に入れることができました。 Animeation クラスは、アニメーション情報を保持するオブジェクトです。アニメーション情報とは、どのコマ(画像)を、何秒間表示させるか、といった情報です。コンストラクタの第一引数に各コマの秒数、第二引数以降には、そのアニメーションを構成する TextureRegin オブジェクトを可変引数として渡します。 #4 の場合は、3コマを0.1秒ごとに切り替えるアニメで、先に生成したsplitからそれぞれのコマを指定します。 stateTime は、アニメーションの進行に必要な経過時間を保持します。 以上で準備できました。あとは、猫の状態に応じて(右を向いてるのか左を向いてるのか、止っているのか、走っているのかなど)、適切な Animation オブジェクトを選択し、そのAnimationオブジェクトが指し示す TextureRegion オブジェクトを描画します。 batch.begin(); bg.draw(batch); boolean loop = true; float width = 16; float height = 16; Animation nekoAnim = currentAnim(); // #1 batch.draw(nekoAnim.getKeyFrame(stateTime, loop), // #2 pos.x, pos.y, // #3 width, height); // #4 batch.end(); stateTime += Gdx.graphics.getDeltaTime(); // #5 #1 では、 currentAnim() メソッド(自前メソッド、後述)から、現在のアニメーションを取得します。 #2 では、 Animation#getKeyFrame() メソッドの第一引数へ現在の経過時間を渡し、適切な TexutreRegion オブジェクトを取得します。第二引数では、アニメーションをループするかどうかを指定します。 #3 、 #4 で描画先の座標と、描画の幅と高さを指定します。 #5 では、 Gdx.graphics.getDeltaTime() メソッドを使って、前回のフレームからの経過時間を取得しています(単位は秒)。 stateTime の値を増加させることでアニメーションのコマを進めることができます。 さて、このプログラムでは次のように直行する2つの状態を扱って、アニメーションを切り替えています。 \u0026#22259;3: アニメーションの状態 この状態をプログラムしたのが上述の currentAnim() メソッドです。 private Animation currentAnim() { Animation anim = null; if (state == STATE_MOVE) { if (dir == DIR_LEFT) { anim = animLeft; } else { anim = animRight; } } else { if (dir == DIR_LEFT) { anim = animIdleLeft; } else { anim = animIdleRight; } } return anim; } state は移動状態、 dir は向きの状態です。中身は、クラスフィールドで定義しておきます。 libGDXには直接関係ありませんが、わかりづらいところかもしれないので解説しました。 ここまでの情報でアニメーションをどう表示させるかがわかったと思います。しかし、どう動かすかはまだ決めていません。 前回までにタッチ処理の方法はわかったので、今回はスプライトでボタンもどきを作ってそのボタンをタッチしている間、左右に動かすようにしてみます。 バーチャルパッド 仕組みは簡単です。左と右を表わすボタンスプライトを用意し、タッチ座標がそのスプライトの矩形に入っているかどうかを判定します。矩形に入っていれば、そのボタンの明度を下げて押されているように見せかけます。 まずスプライトの準備です。次のフィールドを用意します。 private Sprite leftButton; private Sprite rightButton; 初期化は以下のような感じ。 leftButton = new Sprite(img, 0, 16*2, 16*3, 16*2); rightButton = new Sprite(img, 16*3, 16*2, 16*3, 16*2); leftButton.setPosition(8, 0); rightButton.setPosition(8 + 16*3, 0); 左下に表示させるべく、16ドットを1マスとして計算しています。 そしてボタンがタッチされたかどうかの判定です。これはこのプログラムの一番重要なところかもしれません。 leftButton.setColor(Color.WHITE); // #1 rightButton.setColor(Color.WHITE); // #2 if (Gdx.input.isTouched()) { // #3 float x = Gdx.input.getX(); // #4 float y = Gdx.input.getY(); uiViewport.unproject(touchPoint.set(x, y, 0)); // #5 Rectangle leftBounds = leftButton.getBoundingRectangle(); // #6 Rectangle rightBounds = rightButton.getBoundingRectangle(); // #7 if (leftBounds.contains(touchPoint.x, touchPoint.y)) { // #8 leftButton.setColor(Color.GRAY); // #9 left(); } else if (rightBounds.contains(touchPoint.x, touchPoint.y)) { // #10 rightButton.setColor(Color.GRAY); // #11 right(); } } #1 、 #2 では、ボタンスプライトの明度を初期化しています。カラーをホワイトにすることにより、通常のスプライトのテクスチャのカラーをそのまま表示することになります。 #3 は、前回解説しました。タッチさたかどうかを判定するメソッドです。画面をタッチしつづける限り真が返ってきます。 #4 は、タッチされた座標を取得します。この座標は左上を原点とするスクリーン座標が返ってくるのでそのままでは使えません。 #5 の uiViewPort.unproject() メソッドで、 #6 で取得したタッチ座標をビューポート座標経由でワールド座標に変換します。前回の記事でここの解説に誤りがありました( m(_ _)m )。前回の記事では、 Viewport#unproject ではなく、 Camera#unproject メソッドを使用していました。これだとビューポートを考慮しないので、正しい座標が返ってきません。 Viewport クラスを使用している場合は、 Viewport#unproject メソッドを使用してください。 #6 、 #7 では、ボタンスプライトの矩形情報を Rectangle クラスに格納します。 Rectangle クラスは、矩形の左下の位置と、幅と高さの情報を持つクラスです。 #8 、 #10 では、 Rectangle#contains() メソッドにより、タッチ座標が矩形内にあるかどうかを判定します。真であれば、ボタンをタッチしたことになるので、移動処理(right,leftメソッド)を実行します。 #9 、 #11 では、 ボタンが押されていることを視覚的にわからせるために、スプライトの明度を下げています。 Color.GRAY を指定することで、半分位の暗さになり、丁度いい感じになります。 テクスチャラップ 今回、背景には、空の画像を使用していますが、これには「テクスチャラップ」というOpenGLの機能を使用しています。 通常テクスチャの座標を指定するには、テクスチャ座標系を使用します。 テクスチャ座標系とは、左上を原点とし、U軸は右方向、 V軸は下方向に伸びる軸を持つ座標系のことです。1 \u0026#22259;4: テクスチャ座標 テクスチャ座標系では、ピクセル座標ではなく、1.0を最大値とした正規化した座標を指定します。正規化した座標とは、画像のサイズを1.0に丸めたものです。 正規化座標 = ピクセル座標 ÷ テクスチャサイズ で求まります。 例えば、512x512のテクスチャサイズの(256,256)のUV座標を得る場合は、 256/512=0.5 となり、正規化座標は、0.5となります。 通常は、この1.0内のなかで座標を指定すれば良いのですが、 1.0より大きい値を指定することもできます。ただしその場合は、1.0を超えたときの挙動を予め指定しておく必要があります。 今回は、背景の画像に対して、1.0以上の値を指定し、その挙動として、テクスチャの画像を繰り返す指定をしました。 テクスチャラップのコードは以下になります。 bgImg.setWrap(TextureWrap.Repeat, TextureWrap.Repeat); // #1 bg = new Sprite(bgImg, 0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT); // #2 bg.setU(0); // #3 bg.setU2(5); bg.setV(0); bg.setV2(5); #1 で、1.0を超えたUV指定をしたとき、テクスチャを繰り返す指定をしています。 #2 で、背景のスプライトサイズを指定しています。これはターゲット解像度と同じ大きさにしています。 #3 で、UV座標として、0.0 〜 5.0 の値を指定しています。 setU(), setV() が左上の座標、 setU2(), setV2() が右下の座標になります。 あとは、実際の描画ですが、今回の背景の場合、画面に固定で表示したかったため UIカメラを使って描画しています。 private void draw() { // BGカメラセットアップ uiCamera.update(); batch.setProjectionMatrix(uiCamera.combined); batch.begin(); bg.draw(batch); batch.end(); : } 背景として描画するため、drawメソッドの開始直後に描画しています。 今回は詳しく解説しませんが、UV座標を毎フレームずらすことでスクロール処理することができます。 これを一般的にUVスクロールといいます。 一昔まえのゲームのタイトルやプレーヤーセレクト画面などで多様されていました。 update メソッドの最後にコメントアウトしておきましたので、興味のある人は、コメントを外してみてください。おもしろい効果だと思いますのでおすすめです。 以上で、今回の肝となる部分の解説を終えました。ぜひ、次章のソースコードをコピペし、アセット一覧をダウンロードしてプログラムを実行してみてください。生意気げなクロネコがリズムを取りながら待機し、ボタンを押すことで走りまわります。 隠れデバッグ機能として、Rキーでネコの位置をリセットします。 ソースコード 今回解説したプログラムの全ソースです。 package com.zarudama.libgdxtest; import com.badlogic.gdx.Application; import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.Input; import com.badlogic.gdx.audio.Music; import com.badlogic.gdx.graphics.Color; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.OrthographicCamera; import com.badlogic.gdx.graphics.Camera; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.Texture.TextureWrap; import com.badlogic.gdx.graphics.g2d.Animation; import com.badlogic.gdx.graphics.g2d.BitmapFont; import com.badlogic.gdx.graphics.g2d.Sprite; import com.badlogic.gdx.graphics.g2d.SpriteBatch; import com.badlogic.gdx.graphics.g2d.TextureRegion; import com.badlogic.gdx.math.Rectangle; import com.badlogic.gdx.math.Vector2; import com.badlogic.gdx.math.Vector3; import com.badlogic.gdx.utils.viewport.FitViewport; import com.badlogic.gdx.utils.viewport.Viewport; import com.badlogic.gdx.graphics.glutils.ShapeRenderer; public class LibGdxSample extends ApplicationAdapter { public static final String LOG_TAG = LibGdxSample.class.getSimpleName(); // 16:9 public static int LOGICAL_WIDTH = 256; public static int LOGICAL_HEIGHT = 144; // 1秒間に16x3ドット進む private static final float MOVE_SPEED = 16*3.0f/60; // 移動状態 private static final int STATE_IDLE = 0; private static final int STATE_MOVE = 1; // 向き状態 private static final int DIR_RIGHT = 1; private static final int DIR_LEFT = 2; // ゲームに使用するテクスチャ private Texture img; private SpriteBatch batch; // BGM private Music music; // 画面フォント用 private BitmapFont font; // ゲームカメラとビュポート private OrthographicCamera camera; private Viewport viewport; // UIカメラとビュポート private OrthographicCamera uiCamera; private Viewport uiViewport; // タッチ座標変換用ウケザラ private Vector3 touchPoint; // 左右のボタン private Sprite leftButton; private Sprite rightButton; // 背景用 private Texture bgImg; private Sprite bg; // デバッグ用ワールド座標軸 private ShapeRenderer shapeRenderer; // ねこアニメーション private Animation animLeft; private Animation animRight; private Animation animIdleLeft; private Animation animIdleRight; private float stateTime = 0; // 猫座標 private Vector2 pos; // 状態 private int state; private int dir; // UVスクロール用 private float scrollCounter; @Override public void create() { touchPoint = new Vector3(); batch = new SpriteBatch(); font = new BitmapFont(); img = new Texture(Gdx.files.internal(\u0026#34;neko.png\u0026#34;)); pos = new Vector2(); music = Gdx.audio.newMusic(Gdx.files.internal(\u0026#34;mixdown.mp3\u0026#34;)); music.setLooping(true); music.setVolume(0.3f); music.play(); bgImg = new Texture(\u0026#34;bg.png\u0026#34;); bgImg.setWrap(TextureWrap.Repeat, TextureWrap.Repeat); bg = new Sprite(bgImg, 0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT); bg.setU(0); bg.setU2(5); bg.setV(0); bg.setV2(5); scrollCounter = 0.0f; camera = new OrthographicCamera(); camera.position.x = 0; camera.position.y = LOGICAL_HEIGHT/2 - 16*2; viewport = new FitViewport(LOGICAL_WIDTH, LOGICAL_HEIGHT, camera); uiCamera = new OrthographicCamera(); uiCamera.setToOrtho(false, LOGICAL_WIDTH, LOGICAL_HEIGHT); uiViewport = new FitViewport(LOGICAL_WIDTH, LOGICAL_HEIGHT, uiCamera); shapeRenderer = new ShapeRenderer(); // アニメーション情報構築 TextureRegion[] split = new TextureRegion(img).split(16, 16)[0]; TextureRegion[] mirror = new TextureRegion(img).split(16, 16)[0]; for (TextureRegion region : mirror) region.flip(true, false); animRight = new Animation(0.1f, split[2], split[3], split[4]); animLeft = new Animation(0.1f, mirror[2], mirror[3], mirror[4]); animIdleRight = new Animation(0.5f, split[0], split[1]); animIdleLeft = new Animation(0.5f, mirror[0], mirror[1]); stateTime = 0; // 移動ボタン leftButton = new Sprite(img, 0, 16*2, 16*3, 16*2); rightButton = new Sprite(img, 16*3, 16*2, 16*3, 16*2); leftButton.setPosition(8, 0); rightButton.setPosition(8 + 16*3, 0); // ログ情報取得 Gdx.app.setLogLevel(Application.LOG_DEBUG); } @Override public void resize(int width, int height) { Gdx.app.log(LOG_TAG, \u0026#34;risize\u0026#34;); viewport.update(width, height); uiViewport.update(width, height); } private void reset() { pos.set(0, 0); } private void left() { dir = DIR_LEFT; state = STATE_MOVE; pos.x -= MOVE_SPEED; } private void right() { dir = DIR_RIGHT; state = STATE_MOVE; pos.x += MOVE_SPEED; } private Animation currentAnim() { Animation anim = null; if (state == STATE_MOVE) { if (dir == DIR_LEFT) { anim = animLeft; } else { anim = animRight; } } else { if (dir == DIR_LEFT) { anim = animIdleLeft; } else { anim = animIdleRight; } } return anim; } private void update() { float deltaTime = Gdx.graphics.getDeltaTime(); if (Gdx.input.isKeyPressed(Input.Keys.R)) { reset(); } state = STATE_IDLE; leftButton.setColor(Color.WHITE); rightButton.setColor(Color.WHITE); if (Gdx.input.isTouched()) { float x = Gdx.input.getX(); float y = Gdx.input.getY(); uiViewport.unproject(touchPoint.set(x, y, 0)); Rectangle leftBounds = leftButton.getBoundingRectangle(); Rectangle rightBounds = rightButton.getBoundingRectangle(); // コメントを外せば、ボタンの矩形情報、タッチ座標などが得られる。 // String s0 = String.format(\u0026#34;rawTouch(%f,%f)\u0026#34;, x, y ); // String s1 = String.format(\u0026#34;leftBoudns(%f,%f,%f,%f)\u0026#34;, // leftBounds.x, // leftBounds.y, // leftBounds.width, // leftBounds.height); // Gdx.app.log(LOG_TAG, s0); // Gdx.app.log(LOG_TAG, s1); // Gdx.app.log(LOG_TAG, \u0026#34;touchPoint(\u0026#34; + touchPoint.x + \u0026#34;,\u0026#34; + touchPoint.y + \u0026#34;)\u0026#34;); if (leftBounds.contains(touchPoint.x, touchPoint.y)) { left(); //Gdx.app.log(LOG_TAG, \u0026#34;left!\u0026#34;); leftButton.setColor(Color.GRAY); } else if (rightBounds.contains(touchPoint.x, touchPoint.y)) { right(); //Gdx.app.log(LOG_TAG, \u0026#34;right!\u0026#34;); rightButton.setColor(Color.GRAY); } } //String info = String.format(\u0026#34;fish pos(%f,%f)\u0026#34;, fishpos.x, fishpos.y); stateTime += deltaTime; // コメントを外すと、UVスクロールが見れる。 // bg.setU(scrollCounter); // bg.setV(scrollCounter); // bg.setU2(scrollCounter + 5.0f); // bg.setV2(scrollCounter + 5.0f); // scrollCounter += 0.05f; // if (scrollCounter \u0026gt; 5.0f) // scrollCounter = 0.0f; } private void draw() { Gdx.gl.glClearColor(0, 0, 1, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); // BGカメラセットアップ uiCamera.update(); batch.setProjectionMatrix(uiCamera.combined); batch.begin(); bg.draw(batch); batch.end(); // ゲームカメラセットアップ camera.update(); batch.setProjectionMatrix(camera.combined); batch.begin(); // ネコの描画 boolean loop = true; float width = 16; float height = 16; Animation nekoAnim = currentAnim(); batch.draw(nekoAnim.getKeyFrame(stateTime, loop), pos.x, pos.y, width, height); batch.end(); // ワールド座標軸を描画する。 shapeRenderer.setProjectionMatrix(camera.combined); shapeRenderer.begin(ShapeRenderer.ShapeType.Line); shapeRenderer.setColor(1, 0, 0, 1); shapeRenderer.line(-1024, 0, 1024, 0); shapeRenderer.setColor(0, 1, 0, 1); shapeRenderer.line(0, -1024, 0, 1024); shapeRenderer.end(); // UIカメラセットアップ uiCamera.update(); batch.setProjectionMatrix(uiCamera.combined); // UIの描画 batch.begin(); leftButton.draw(batch); rightButton.draw(batch); //font.draw(batch, info, 0, 40); batch.end(); } @Override public void render () { update(); draw(); } @Override public void dispose() { music.dispose(); batch.dispose(); font.dispose(); img.dispose(); bgImg.dispose(); shapeRenderer.dispose(); } } 今回の記事のアセット一覧 プログラムを動かす前に、テクスチャやBGMをダウンロードして、下記に配置してください。 ${PROJECT_ROOT}/android/assets/ テクスチャ \u0026#22259;5: ねこの画像 背景 \u0026#22259;6: 背景 BGM http://mikio.github.com/demo/sound/mixdown.mp3 おわりに 今回は、「 ログ出力」と「スプライトアニメーション」、そして「バーチャルパッドの作り方」を学びました。 次回 は、画面遷移について解説します。もしかしたら、ゲームっぽいものに仕上げるかも知れないです。 参考書籍 \"\" \" width=\"1\" height=\"1\" border=\"0\" alt=\"\" style=\"border:none !important; margin:0px !important;\" / libGDXの作者が書いた本です。Androidでゲームを作るための基本を独自のフレームワーク作成を通して解説しています。 libGDXの解説ではないけれど、その思想は当然libGDXにも引き継がれています。もちろんlibGDXの理解もしやすくなります。また、Androidの本ではありますが、スマホに特化した内容ばかりではなく、どんなゲーム開発にも通用しそうな内容ばかりです。実践的かつ基本的で自分は退屈せずに読めました(特にMVCについての言及が良い)。そういう意味でこの本は、すべての初級ゲーム開発者におすすめできる本かと思います。ただし一部内容が古いので注意してください(沢山売れて第2版が翻訳されればいいんですが)。それでもlibGDXをやるなら読んでいて損はないと思います。 変更履歴 2014/6/21 ターゲット解像度を変更(256x192 =\u0026gt; 256x144) 背景の画像を変更し、テクスチャラップ導入 ボタンの画像を変更し、よりボタンらしい挙動をするようにした 注釈 libGDXが使用しているOpenGLでは、すべての2次元座標系は左下が原点となるのが原則のようです。 libGDXが左下が原点なのものこの仕様に影響されているものと思われます。 UVも実は左下が原点なのですが、VRAMへ転送する際に上下が反転されるらしく、結果的に左上が原点となるようです。\r[return]"
},
{
url: "https://zarudama.github.io/post/2014/06/libgdx04/",
title: "libGDX入門 その04 画面遷移",
date: "2019-11-08T16:24:00+09:00",
body: "libGDX入門 その04 画面遷移 \u0026#30446;\u0026#27425; はじめに ライフサイクルについて 画面遷移 Screenインタフェイス show()とhide() dispose() dispose()の方法 その1 hide() で解放する その2 Game#dispose() で全て解放する その3 Game クラスを拡張する ゲームっぽい何か ソースコードについて アセットの管理について ゲーム中のフォントについて おわりに 参考書籍 はじめに libGDX を勉強するついでに解説記事を書く シリーズ 4回目です。 前回 は、以下のことを学びました。 ログ出力 スプライト表示のアニメーション テクスチャラップ バーチャルパッド 今回は、簡単なゲームを作ったので、その中の画面遷移を解説します。 ライフサイクルについて 今まであえて説明を避けてきたのですが(面倒そうなので←)、 Screenインタフェイスを扱うにあたり避けられそうもなかったので調査しました。 libGDXのライフサイクルと呼びだしメソッドの関係は以下のようになっています。 \u0026#22259;1: libgdxのライフサイクル メソッドは、 ApplicationListener のものです。 注意して欲しいのは、PC版とAndroidで微妙に挙動が違うということです。特にPC版は、待機状態のときもrenderメソッドが呼ばれ続けるので注意が必要です。私はMacを持っていないのでわかりませんが、iOSも考慮したら更に違いがあるかもしれません。 create() アプリケーションが新しく生成された時に呼ばれます。 resize() アプリケーションが新しく起動されたとき、PC版でウィンドウサイズが変化したとき、スマホ版で、端末の向きが変わったときなどに呼ばれます。 pause() スマホで電話が鳴った時やHome画面にした時、PC版でフォーカスが外れたときなどに呼ばれます。 resume() 待機状態から、ウィンドウがアクティブになった時に呼ばれます。 dispose() アプリケーションが破棄される時に呼ばれます。 ライフサイクルに関する情報は下記が非常に詳しいです。一読をお勧めします。 clan libGDXメモ 上記サイトの説明にもありますが、ゲームの情報を保存するときは、 pause() が良いようです。 公式ドキュメントは下記にあります。 https://github.com/libgdx/libgdx/wiki/The-life-cycle 画面遷移 今回作成したゲームでは、次のような遷移があります。 \u0026#22259;2: 今回の画面遷移 まず「メインメニュー」が表示され、「START」をタップすると「ゲーム」画面になり、「QUIT」をタップすると「メインメニュー」画面に戻ります。非常にシンプルですね。 その1でも紹介しましたが、関連するクラス図を再掲します。 \u0026#22259;3: Screenのクラス図 ApplicationAdapter クラスは、 ApplicationListener インタフェイスを空実装したデフォルトクラスでしたね。 ScreenAdapter クラスも同様に、 Screen インタフェイスを空実装したデフォルトクラスです。 今までは、 ApplicationAdapter クラスを継承していましたが、今回からは、 Game クラスを継承します。 Game クラスは、 ApplicationListener を実装したクラスで、画面遷移を担当する Screen インタフェイスのインスタンスを保持します。今まで ApplicationAdapter を継承していたクラスはこのGameクラスを継承します。 Screenインタフェイスについては、ライフサイクルを確認したいため、 MyScreenAdapter クラスというデフォルト実装クラスを用意し、各メソッドでログを出力することにします。 public abstract class MyScreenAdapter implements Screen { : @Override public void show () { Gdx.app.log(LOG_TAG, \u0026#34;show\u0026#34;); } : } 今回のゲームで実装するクラスは以下のとおりです。 \u0026#22259;4: 今回準備するクラスたち LibGdxSample クラスは、処理の起点となるクラスです。この図からは省いていますが、Screen系のクラスは先程紹介した MyScreenAdapter クラスを継承します。 MainManuScreen クラスは、最初に表示されるメニュー(タイトル)画面です。 GameScreen クラスは、実際のゲームを担当するクラスです。ほとんどの処理はこのクラスに集中します。 Screenインタフェイス 画面遷移がある場合は、画面ごとに Screen インタフェイスを実装します。実装すべきメソッドのほとんどは ApplicationListener と共通です。ライフサイクルについても、 ApplicationListener とほぼ同じです。 Screen では、 create() メソッドがなくなり、変わりに show() メソッドと hide() メソッドが追加されました。ただし、 dispose() メソッドは、名前は同じでも扱いが少し違うので注意が必要です(後述します)。ここでは、下記3つのメソッドについて解説します。 show() hide() dispose() show()とhide() show() メソッドは、画面切り替え開始時に1度だけ呼ばれます。 hide() メソッドは、画面切り替え終了時に1度だけ呼ばれます。画面切り替え時とは、 Game#setScreen() メソッド呼び出した時のことです。 例えば現在「メニュー画面」を表示していた場合、「ゲーム画面」に切り替えたくなったら、下記のようなコードを実行します。 game.setScreen(new GameScreen(this)); この setScreen() メソッドの中で、現在表示中の「メニュー画面」の MainMenu#hide() メソッドが呼ばれ、次に表示予定の「ゲーム画面」の GameScreen#show() メソッドが呼ばれます。 Game#setScreen() のソースコードです。短かいので全部載せておきます。 public void setScreen (Screen screen) { if (this.screen != null) this.screen.hide(); this.screen = screen; if (this.screen != null) { this.screen.show(); this.screen.resize(Gdx.graphics.getWidth(), Gdx.graphics.getHeight()); } } setScreen() した時は、hide,show,resizeが即実行されるということを頭に叩きこんでおいたほうが良さそうですね。 現在の画面の Screen#hide() 次の画面の Screen#show() 次の画面の Screen#resize() 以上から、 show() メソッドは初期化処理、 hide() メソッドは終了処理を実装すれば良いと思います。 ただし、 hide() メソッドには、リソース解放処理を記述してはいけません。リソース解放処理とは、 Texture#dipose() や、 SpriteBatch#dispose() などのことです。理由は後述します。 dispose() dispose() メソッドには、注意すべき重要なことがあります。それは何かというと、 Screen#dispose() はシステムから自動的に呼びだされないということです。 ApplicationListener#dispose() とは扱いが違いますね。 APIマニュアルにも記述されています。 Screens are not disposed automatically. You must handle whether you want to keep screens around or dispose of them when another screen is set. http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/Game.html ゲームによって、リソースの解放タイミングは様々なので、このようにクライアントまかせになっているのかもしれません。 (そうすると、Screenインタフェイスを使わずに全部自分で作ったほうがいいんじゃないかという気もしてきますが。) ということで、 dispose() は自分で呼びだす必要があります。 AplicationLisner 利用時は、特になにも考えずに ApplicationListener#dispose() にリソース解放処理を記述しておけばよかったのですが、 Screen を利用する場合は、解放のタイミングを自分で制御しなくてはなりません。 dispose()の方法 サンプルやドキュメントを呼んでもいまいちこの辺の方法がわかりません。とはいえ何もしないわけにもいきませんので、現時点での解放方法について、私なりのやりかたを考えました。他にも良い方法あるよ？って方がいたら教えてください。 その1 hide() で解放する 例えば、下記のように Screen#render() メソッドから setScreen() メソッドを呼びだすとします。 public void render (float deltaTime) { : game.setScreen(new MainMenuScreen(game)); : leftButton.draw(batch); : } このとき、現在実行中の Screen インスタンスの hide() メソッドが呼ばれます。 hide() メソッドは下記のようにテクスチャの開放処理を実装していたとします。 public void hide() { img.dispose(); } 結論をいうとこの書き方ではうまくいきません。なぜなら、 hide() でテクスチャを解放したにもかかわらず、その後に、テクスチャの描画処理を呼んでしまっているからです。 hide() にリソースの解放処理を入れるならば、 redner() メソッドを下記のように書かなければなりません。 public void render (float deltaTime) { : : leftButton.draw(batch); : game.setScreen(new MainMenuScreen(game)); // ここには何も処理を書かない。 } つまり、 setScreen() を render() の一番最後に持ってこなければなりません。しかしながら、最後に呼びだすなどのルールは忘れやすそうですし、強制性がないので個人的にはお勧めしません。 その2 Game#dispose() で全て解放する 扱うリソースが少ないシンプルなゲームの場合に利用できる方法です。 Game#create() でそのゲームの全リソースをロードし、 Game#dispose() で全リソースを解放します。 Screen クラスでは、リソース管理を一切しません。 (スクリーンからこれらのリソースにアクセスするには、 Game のインスンタンス経由でアクセスします)。 こうすれば、 Screen 毎にリソースの管理を気にせずにすむので楽ですね。 その3 Game クラスを拡張する 今回採用した方法です。その1の方法を改良しました。 Gameクラスを継承したクラスを少し改造します。 public class LibGdxSample extends Game { private Screen nextScreen; : @Override public void render() { super.render(); if (nextScreen != null) { super.setScreen(nextScreen); nextScreen = null; } } : @Override public void setScreen (Screen screen) { Gdx.app.log(LOG_TAG, \u0026#34;setScreen\u0026#34;); nextScreen = screen; } : } まず、 nextScreen というフィールドを新設します。そして setScreen メソッドをオーバライドし、 nextScreen フィールドに screen をセットするだけの処理にします。更に render() メソッドの最後で、 nextScreen フィールドがセットされたときのみ setScreen() を呼びだすようにします。 このような仕組みを持つことで、 game.setScreen() をいつでも呼びだすことが可能になります。なぜなら、 Screen#hide() の呼びだされるタイミングが必ず render() の一番最後になるからです。 以上で、 Screen#hide() の実行されるタイミングに気を使うことなく、 dispose() 処理を実装できるようになりました。 後は次のように、 hide() から dispose() 処理を呼びだせば良いですね。 @Override public void hide() { dispose(); } @Override public void dispose() { music.dispose(); seGet.dispose(); seMiss.dispose(); batch.dispose(); font.dispose(); img.dispose(); bgImg.dispose(); shapeRenderer.dispose(); } 最後に注意というか知っていたほうが良い知識として、 Screen#hide() は、 Game#dispose() からも自動で呼びだされるということを述べておきます。 public abstract class Game implements ApplicationListener { : public void dispose () { if (screen != null) screen.hide(); } : } なので、 Game#dispose() 内でわざわざ自分で Screen#dispose() を呼びだす必要はありません。 public void dispose() { super.dispose(); Screen screen = getScreen(); if (screen != null) screen.dispose(); } ゲームっぽい何か さて、長い説明が終わってやっとゲームの説明です(といっても非常に単純なものですが)。内容は、上から落ちてくる魚を取るだけのゲームです。 仕様は、 最初にメニュー画面を表示。「START」タップでゲーム開始 魚をキャッチすると、1点 3回取り損ねると、ゲームオーバー ポーズあり ポーズ中に「QUIT」タップでメニュー画面へ戻る といった感じです。 画像データは下記のツールを利用して作成しました。 http://takabosoft.com/edge 効果音は下記のサイトで作成しました。 http://www.bfxr.net/ BGMは下記のサイトで作成しました。 http://soundation.com/ プログラムの骨組みは、前回のものを踏襲しています。 \u0026#22259;5: タイトル画面 \u0026#22259;6: ゲーム画面 ゲームのプログラムは、ほとんどが今まで説明してきたlibGDXの内容でつくられてます。なので詳しく説明しませんが、一点だけ解説するとすれば、当たり判定のところでしょうか。魚と猫の当り判定のコードは以下のようになっています。 if (nekoBounds.overlaps(fishBounds)) { resetFish(); seGet.play(); score += 1; } nekoBoudns と fishBounds は、 Rectangle クラスで、それぞれキャラクタの矩形情報です。 Rectangle#overlaps() メソッドを呼ぶことで、2つの矩形が重なりあっているかを判定できます。 ソースコードについて 今回は、ソースコードが4ファイルになってしまったため、githubに載せることにしました。 https://github.com/mikio/fishcatch 思いのほかコード量が多くなってしまったのが反省点です。いろいろ工夫の余地はあると思うので、今後改善していきたいと思います。 アセットの管理について 今回実装したゲームのアセットファイルは数えるほどしかありませんので、画像やサウンドの読み込みは、単純に読み込むだけでした。 ゲームの種類によっては、沢山のアセットを駆使しなければならない場合もあるでしょう。そんなときは、libGDXの AssetManager クラスを使うのが良さそうです。 https://github.com/libgdx/libgdx/wiki/Managing-your-assets 非同期読み込みや依存管理、キャッシュの管理など便利な機能を多く実装しているようですね。 Screen 利用時の解放処理の煩雑さも、このクラスを利用すれば解決するのかもしれません。 ゲーム中のフォントについて ゲーム中のフォントは、gebsite様の「Fantasy Gezone」フォントを利用させていただきました。ありがとうございます。 http://www.gebsite.org/ http://www.gebsite.org/font/fantasygezone.html おわりに 次回 予定している内容は、 ゲームデータの保存 です。 参考書籍 \"\" \" width=\"1\" height=\"1\" border=\"0\" alt=\"\" style=\"border:none !important; margin:0px !important;\" / libGDXの作者が書いた本です。Androidでゲームを作るための基本を独自のフレームワーク作成を通して解説しています。 libGDXの解説ではないけれど、その思想は当然libGDXにも引き継がれています。もちろんlibGDXの理解もしやすくなります。また、Androidの本ではありますが、スマホに特化した内容ばかりではなく、どんなゲーム開発にも通用しそうな内容ばかりです。実践的かつ基本的で自分は退屈せずに読めました(特にMVCについての言及が良い)。そういう意味でこの本は、すべての初級ゲーム開発者におすすめできる本かと思います。ただし一部内容が古いので注意してください(沢山売れて第2版が翻訳されればいいんですが)。それでもlibGDXをやるなら読んでいて損はないと思います。"
},
{
url: "https://zarudama.github.io/post/2014/07/libgdx05/",
title: "libGDX入門 その05 ゲームデータの保存",
date: "2019-11-08T16:24:00+09:00",
body: "libGDX入門 その05 ゲームデータの保存 \u0026#30446;\u0026#27425; はじめに 注意 インスタンスの取得方法 値の書込みと読込み データを保存するタイミング 保存される場所 実際の実装例 ソースコード おわりに 参考書籍 注釈 はじめに libGDX を勉強するついでに解説記事を書く シリーズ 5回目です。 前回 は、以下のことを学びました。 Screenインタフェイスを使った画面遷移 今回は、前回作ったゲームに以下の機能を追加します。 BGMのON/OFF機能 SEのON/OFF機能 HiScoreの表示 これらの情報は、ゲームを再開したときも保持していて欲しいですね。 そこで今回は、これら3つの情報を com.badlogic.gdx.Preferences というクラスを利用して保存していきます。 公式情報は下記にあります。 https://github.com/libgdx/libgdx/wiki/Preferences http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/Preferences.html 注意 今回「ゲームデータの保存」というタイトルにしてしまいましたが、扱えるのはごく小さなデータのみです1。また、データはテキストとして保存されるので、ユーザーに改竄されて困るようなものは暗号化するなどの処置が必要です。 さらに、ゲーム中の複雑なデータを扱う場合は、データをシリアライズしたりして保存する必要があるかと思います。これらについては、今回は扱いません。 インスタンスの取得方法 下記で取得できます(公式からの引用)。 Preferences prefs = Gdx.app.getPreferences(\u0026#34;My Preferences\u0026#34;); 文字列の部分が名前になります。名前を変えればひとつのアプリで複数のインスタンスを扱えるようです。個人的にこの名前は、javaのパッケージ名が良いかと思います。 (ただしそれがユニークであるという保証がある場合のみ) というのものPreferenceというのは、対象の端末全アプリの中でユニークである方が安全だからです。今回の例でいうと下記の名前になります。 Preferences prefs = Gdx.app.getPreferences(\u0026#34;com.zarudama.fishcatch\u0026#34;); この辺の考察は下記が詳しいので、一読をおすすめします。 doc.tir.ne.jp/devel/clan/libgdx preferencesについて 値の書込みと読込み libGDXの Preferences は、Javaの標準クラスの java.util.prefs.Preferences や java.util.Map クラスに少し似ています。 公式から引用します。 prefs.putString(\u0026#34;name\u0026#34;, \u0026#34;Donald Duck\u0026#34;); String name = prefs.getString(\u0026#34;name\u0026#34;, \u0026#34;No name stored\u0026#34;); prefs.putBoolean(\u0026#34;soundOn\u0026#34;, true); prefs.putInteger(\u0026#34;highscore\u0026#34;, 10); 下記のようなメソッドの仕様になっています。 Preferences#put型名 (キー文字列, 型に応じた値); 保存できるデータ型は、int、long、float、boolean、Stringになります。 getterは第2引数にデフォルト値を指定できます。これは値が存在しなかった場合に返却する値です。 String name = prefs.getString(\u0026#34;name\u0026#34;, \u0026#34;No name stored\u0026#34;); この場合、 name というキーの値が存在しないときは、 No name stored が返却されます。 データを保存するタイミング Preferences のインスタンスに値をセットしただけでは、それはメモリ上の操作に過ぎませんので、これをストレージに書きだす必要があります2。 Preferences#fluash() メソッドを呼びだしてください。 prefs.flush(); データを保存するタイミングですが、基本的にはデータを変更する都度 flush() するのが良いと思います。都度アクセスするのは少々冗長ですが確実です。 しかしアプリによっては、データ量が多い場合やタイミングが不特定の場合、保存するタイミングが頻発するのは望ましくないなどの状況があると思います。そんな時は、 ApplicationLisnter#pause() に保存するのが良いと思います。 理由は pause() はアプリが消滅する寸前および、フォーカースが外れたときに必ず呼ばれるメソッドだからです。これまた下記が詳しいです。 doc.tir.ne.jp/devel/clan/libgdx#データのセーブとロード ライフサイクルの図をもう一度掲載します。 \u0026#22259;1: libgdxのライフサイクル 保存される場所 公式からのそのまま転用ですが、下記に保存されます。 OS 場所 Windows %UserProfile%/.prefs/My Preferences Linux and OS X ~/.prefs/My Preferences Androidでは、SharedPreferences を使用するとのこですが、アプリを削除すると保存データも同時に削除されるようです。 Androidの保存場所は機種依存が大きいため一概にどこと言えません。下記を参考にしてください。 http://techbooster.org/android/application/16004/ iOSの場合はどこにどんな状態で保存されるかわかりません(公式にも載っておらず、私もMacを持っていないため) 。 参考までにUbuntuの場合は、下記のようなXMLデータが保存されます。 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE properties SYSTEM \u0026#34;http://java.sun.com/dtd/properties.dtd\u0026#34;\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;entry key=\u0026#34;bgmOn\u0026#34;\u0026gt;true\u0026lt;/entry\u0026gt; \u0026lt;entry key=\u0026#34;seOn\u0026#34;\u0026gt;false\u0026lt;/entry\u0026gt; \u0026lt;entry key=\u0026#34;hiscore\u0026#34;\u0026gt;9\u0026lt;/entry\u0026gt; \u0026lt;/properties\u0026gt; 実際の実装例 前回実装したショボゲーに、下記のような感じで実装してみました。 \u0026#22259;2: 改造したタイトル画面 左下にハイスコア表示、右側にそれぞれ「BGM」「SE」のオンオフボタンを配置してあります。 これらは下記の Settings クラスを通して操作します。 package com.zarudama.fishcatch; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.Preferences; public class Settings { private static final String NAME = \u0026#34;com.zarudama.fishcatch\u0026#34;; private static final String KEY_SE_ON = \u0026#34;seOn\u0026#34;; private static final String KEY_BGM_ON = \u0026#34;bgmOn\u0026#34;; private static final String KEY_HISCORE = \u0026#34;hiscore\u0026#34;; private static final boolean DEFAULT_SE_ON = true; private static final boolean DEFAULT_BGM_ON = true; private static final int DEFAULT_HISCORE = 0; private Preferences mPrefs; public Settings() { mPrefs = Gdx.app.getPreferences(NAME); } public boolean seOn() { return mPrefs.getBoolean(KEY_SE_ON, DEFAULT_SE_ON); } public boolean bgmOn() { return mPrefs.getBoolean(KEY_BGM_ON, DEFAULT_BGM_ON); } public int hiscore() { return mPrefs.getInteger(KEY_HISCORE, DEFAULT_HISCORE); } public void toggleSeOn() { mPrefs.putBoolean(KEY_SE_ON, !seOn()); mPrefs.flush(); } public void toggleBgmOn() { mPrefs.putBoolean(KEY_BGM_ON, !bgmOn()); mPrefs.flush(); } public void hiscore(final int aScore) { mPrefs.putInteger(KEY_HISCORE, aScore); mPrefs.flush(); } } Settings クラスは、 FishcatchGame クラスを通してアクセスします。ただし自分はドットが二つ以上つづく文があまり好きではないので (メソッドチェーンとか流れるようなインターフェイスというやつ3)、外部からアクセスするときは Settings クラスへアクセスするのではなく、専用のメソッドを FishcatchGame クラスに設けています。 public class FishcatchGame extends Game { : private Settings settings; public boolean seOn() { return settings.seOn(); } public boolean bgmOn() { return settings.bgmOn(); } public int hiscore() { return settings.hiscore(); } public void toggleSeOn() { settings.toggleSeOn(); } public void toggleBgmOn() { settings.toggleBgmOn(); } public void hiscore(int score) { settings.hiscore(score); } : } ちなみに現在の自分コーディングスタイルは原則下記の影響を受けています。 http://www.slideshare.net/MoriharuOhzu/ss-14083300 「オブジェクト指向エクササイズ」を解説したもので、オブジェクト指向言語を普段使い全ての人に読んで欲しい内容です。このlibGDXシリーズではほぼ無視してコーディングしてますが…。 ソースコード 今回実装したサンプルコードは、下記にあります。 https://github.com/mikio/fishcatch おわりに 今回までの内容で最低限必要な機能は網羅できたのではないかなと思います。 次回からは、 Scene2d 、 広告の実装、 Googleの「Google Play ゲーム」あたりを扱っていきたいなと思います。 参考書籍 \"\" \" width=\"1\" height=\"1\" border=\"0\" alt=\"\" style=\"border:none !important; margin:0px !important;\" / libGDXの作者が書いた本です。Androidでゲームを作るための基本を独自のフレームワーク作成を通して解説しています。 libGDXの解説ではないけれど、その思想は当然libGDXにも引き継がれています。もちろんlibGDXの理解もしやすくなります。また、Androidの本ではありますが、スマホに特化した内容ばかりではなく、どんなゲーム開発にも通用しそうな内容ばかりです。実践的かつ基本的で自分は退屈せずに読めました(特にMVCについての言及が良い)。そういう意味でこの本は、すべての初級ゲーム開発者におすすめできる本かと思います。ただし一部内容が古いので注意してください(沢山売れて第2版が翻訳されればいいんですが)。それでもlibGDXをやるなら読んでいて損はないと思います。 注釈 最大2kとのこと(/doc.tir.ne.jp/devel/clan/libgdx#データのセーブとロード)\r[return] libGDXの実装によっては、非同期で書き出している可能性もありますが、意識しないほうがいいと思います。\r[return] http://d.hatena.ne.jp/higayasuo/20071025/1193319054\r[return]"
},
{
url: "https://zarudama.github.io/search/data.js",
title: "",
date: "0001-01-01T00:00:00Z",
body: ""
},
{
url: "https://zarudama.github.io/categories/",
title: "Categories",
date: "0001-01-01T00:00:00Z",
body: "Categories"
},
{
url: "https://zarudama.github.io/search/",
title: "Searches",
date: "0001-01-01T00:00:00Z",
body: "Searches"
},
];
