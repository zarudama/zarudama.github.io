


var data = [
{
url: "https://zarudama.github.io/post/",
title: "Posts",
date: "2018-12-17T00:00:00+09:00",
body: "Posts"
},
{
url: "https://zarudama.github.io/post/2018/12/libgdx/",
title: "libgdx",
date: "2018-12-17T00:00:00+09:00",
body: "libgdx はじめに libGDX は、Javaでゲームを作るためのライブラリです。マルチプラットフォーム対応で、PC(Windows,Linux,Mac), Android, iOS, HTMLに対応しています。 libGDXは、日本での知名度はイマイチのようですが、海外ではかなり人気があるようです。実際、ググってみると、英語のドキュメントは沢山みかけますが、日本語のドキュメントはまだまだ少数です。 また、公式ドキュメントも大変充実しています(英語のみ)。 https://github.com/libgdx/libgdx/wiki 実のところこのドキュメントを読めば大抵の事は解決します。 ただ、私もそうなんですが、日本語情報がないってだけで、重い腰が上がらないって人も多いと思います。そんな人向けに(というより自分の勉強ついでに)、そして少しでもlibGDXを使用する人が増えることを願い、少しずつ記事を書いていこうと思います。 この記事が、libGDXを学ぶためのきっかけになって頂ければ幸いです。 その2は こちら。 このシリーズの目次は こちら 。 プロジェクトを作る libGDXでは、専用のプロジェクト生成アプリが用意されています。マルチプラットフォームの性質上、プロジェクトの構成が複雑なので素直にこのアプリを使用したほうが良いかと思います。 http://libgdx.badlogicgames.com/download.html 起動は、以下のような感じです。Windowsならばダブルクリックで起動できるでしょう。 $ java -jar gdx-setup.jar Usage: GdxSetup --dir \u0026lt;dir-name\u0026gt; --name \u0026lt;app-name\u0026gt; --package \u0026lt;package\u0026gt; --mainClass \u0026lt;mainClass\u0026gt; --sdkLocation \u0026lt;SDKLocation\u0026gt; dir ... the directory to write the project files to name ... the name of the application package ... the Java package name of the application mainClass ... the name of your main ApplicationListener sdkLocation ... the location of your android SDK. Uses ANDROID_HOME if not specified Figure 1: 起動したところ 入力値は見たままですが、 Name プロジェクトの名前(設定ファイルでアプリ名として利用される) Package プロジェクトのパッケージ Game class 起点となるクラス Destination プロジェクトの出力ディレクトリ(ディレクトリは存在しなくても自動作成してくれる) Android SDK AndroidSDKへのパス となります。 Generateボタンをクリックすれば、プロジェクトが生成されます。必要なライブラリ(gradle、dllやsoなど)も全部まるっとダウンロードしてくれるので楽チンです。 以降、プロジェクトを ~/dev/libgdxtest/ に生成した前提で話をすすめます。 注意点 今後プロジェクトを実行する際、挙動がおかしいなと思ったら、下記のデイレクトリを(バックアップしたうえで)削除して再実行してみてください。 $ rm -rf ~/.m2 $ rm -rf ~/.gradle ともにjarファイルなどの依存ファイルを保存するディレクトリですが、稀に状態がおかしくなるようです。 IntelliJで使う Eclipseに比べて軽いと評判の IntelliJ IDEA での扱い方です。 プロジェクトのインポート まずは、IntelliJを起動し、Import Projectを選択します。既に別のプロジェクトを起動していた場合は、「close Project」を選択します。 Figure 2: IntelliJの最初のダイアログ gdx-setup.jar で生成したディレクトリを選択します。 Figure 3: プロジェクトディレクトリを選択 Gradleを選択し、「next」ボタンを押下します。 Figure 4: Gradle選択 「Use default gradle wrapper」を選択します。 Figure 5: defaultを選択 最後にFinishボタンを押下します。最初のインポートには時間がかかります。最終的に下記のエラー(HTML関係)が表示されますが、HTMLはひとまず使用しないので気にしないでおきます。 Figure 6: HTMLのエラー PC版を動かす インポートが終わったら、早速実行してみます。 メニュー → Run → Edit Configrationsを選択。 Figure 7: 実行の際の設定ダイアログ 入力内容は以下のとおり。 Name Desktop Use class path of module desktop Main class DesktopLauncher クラスを選択 Working directory android/assetsディレクトリを選択 最後にOKを選択します。 実行環境が作成できたら、右上にあるIntelliJのセレクトボックスからDesktopを選択して再生ボタンを押下します。最初の実行は、インポート以上に時間がかかりますので心してください。 Figure 8: 右上にあるセレクトボックス 下記の画面が表示されたら成功です!おめでとうございます!! Figure 9: 実行画面 Android版を動かす デバイスを接続します。 予めOSがきちんと認識していることを確かめておいて下さい。 右上のセレクトボックスから「android」を選択し、再生ボタンを押下します。 認識しているデバイスが表示されるので、選択して実行します。 HTML版を動かす ターミナルを開きます。 メニュー → View → Tool Windows → Terminal ターミナルでプロジェクトルートに移動します。 $ cd ~/dev/libtext 下記のコマンドを実行します。 $ ./gradlew html:superDev いろいろ出力が表示され、最終的に The code server is ready. の表示がされたら、下記にアクセスします。 http://localhost:8080/html/ Figure 10: Terminal HTML版は、 String.format メソッドが使えなかったり、 BitmapFontが表示できなかったり制限があるので注意してください。 Figure 11: HTML版を起動している様子 Eclipseで使う Juno4.2、日本語版で解説します。 Gradleプラグインのインストール メニュー → ヘルプ → 新規ソフトウェアのインストール 作業対象欄に下記を入力し、追加ボタンを押下 http://dist.springsource.com/release/TOOLS/gradle ダイアログの名前欄に「Gradle」と入力し、OKボタンを押下 「Extensions / Gradle Integration」をチェックし、「次へ」ボタンを押下 「次へ」ボタンを押下 「使用条件の条項に同意します」をチェックし、「完了」ボタンを押下 プロジェクトのインポート メニュー → ファイル → インポート → Gradel Project → 次へボタンを押下 ルートフォルダー欄に、生成したプロジェクトディレクトリを入力、BuiildModeボタンを押下 プロジェクト欄の最上意プロジェクトを選択して、完了ボタンを押下 PC版を動かす 下記の手順です。 パッケージエクスプローラから、desktopプロジェクトを選択、右クリック 実行 → Javaアプリケーション を選択 型選択欄で、desktopと入力 一致する項目からDesktopLauncherクラスを選択し、OKボタンを押下 以上で実行されます。 Android版を動かす 下記の手順です。 事前にデバイスをOSが認識していることを確認してください。 パッケージエクスプローラから、androidプロジェクトを選択、右クリック 実行 → Android アプリケーション を選択 以上で実行されます。 HTML版を動かす 下記の手順です。 パッケージエクスプローラから、gwtプロジェクトを選択、右クリック 実行 → 外部ツールの構成 左ペインの「プログラム」をダブルクリック 名前欄に「GWT SuperDev」と入力 ローション欄：ファイルシステムの参照ボタンから「gradlew(windowsの場合は、gradlew.bat)」を選択 作業ディレクトリ欄：ファイルシステムの参照ボタンから、プロジェクトルートを選択 引数欄に「html:superDev」と入力 適用ボタンを押下 実行ボタンを押下 するとコンソールビューが表示され、いろいろ出力されます。最終的に The code server is ready. の表示がされたら、下記にアクセスします。 http://localhost:8080/html/ コマンドラインで使う コマンドラインで実行する場合は特に準備は不要で、最初のプロジェクト生成で既に準備は整っています。 Emacserの自分は、この方法が一番好きです。 基本的には、gradlewコマンドでタスクを実行するだけです。 Windowsの場合は、gradlewに、拡張子 .bat を追加して実行してください。 gradlewコマンドは、プロジェクトルートで実行する必要があります。 $ cd ~/dev/libgdxtest PC版を動かす 下記のように実行します。 $ ./gradlew desktop:run Android版を動かす 予め ANDROID_HOME を定義しておく必要があります。 .bashrc などに記述しておきます。 export ANDROID_HOME=~/opt/adt-bundle-linux-x86_64-20130717/sdk 下記のように実行します。 $ gradlew android:installDebug android:run HTML版を動かす 下記のように実行します。 $ ./gradlew html:superDev : : The code server is ready. Next, visit: http://localhost:9876/ いろいろ出力が表示され、最終的に The code server is ready. の表示がされたら、下記にアクセスします。 http://localhost:8080/html/ HTML版は、 String.format メソッドが使えなかったり、 BitmapFontが表示できなかったり制限があるので注意してください。 基本的なクラスについて gdx-setup.jarで作成される雛形は下記のとおりです。 PROJECT_ROOT + android + core + desktop + gradle + html + ios 環境別にディレクトリが切られ、ゲームロジックそのものは core ディレクトリに記述していきます。環境ごとのディレクトリにはそれぞれその環境専用の起動クラス(*Launcher.java)が定義されています。環境に依存するコード(例えば広告表示など)は、この環境別のディレクトリ内に記述してきます。 さて core/src ディレクトリには下記のようなクラスがあります。 package com.zarudama.libgdxtest; import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.SpriteBatch; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; Texture img; @Override public void create () { batch = new SpriteBatch(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); } @Override public void render () { Gdx.gl.glClearColor(1, 0, 0, 1); //画面を赤で塗りつぶし Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); // カラーバッファをクリア batch.begin(); // 描画の開始 batch.draw(img, 0, 0); // テクスチャーを描画 batch.end(); // 描画の終了 } } これは、 gdx-setup.jar で最初に作られる画像を表示するだけのクラスです。 createメソッドは、アプリ内で一度だけ実行される処理を記述し、 renderは毎フレーム呼びだす処理を記述します。renderはつまりメインループとなります。 ApplicationAdapterクラスは、ApplicationListenerインターフェイスを実装したクラスです。 ApplicationListenerインターフェイスは、libGDXでは必ず実装する必要があるため、 ApplicationAdapterクラスが基本的な実装として用意してあります。単純なゲームやテストプログラムであれば、このクラスを継承するだけで良いのですが、実際のゲーム開発では、画面遷移を伴うことが多いはずです。なのでApplicationAdapterクラスに代わり Gameクラスを継承することが多くなります。 Gameクラスは、画面遷移を担当するScreenクラスを扱い、 GameクラスもまたApplicationListenerインターフェイスを実装しています。 Figure 12: ApplicationListenerクラス SpriteBatchクラスは、libGDXで描画を担当するクラスでこれもまた必ず必要なクラスです。 batch.beginメソッドとbatch.endメソッドの間のdrawメソッドで様々な描画を行ないます。 Textureクラスは名前そのままの画像を扱うクラスです。この例では最もシンプルな画像表示なので、 Textureクラスをそのまま描画していますが、実際には後述するSpriteクラスを介して使用することが多くなるはずです。 文字表示 いろいろテストプログラムを書きたいところですが、まずは文字が表示できないと状態を把握できません。 libGDXはデフォルトで文字描画をサポートしていますので、それを利用します。 下記のように変更してください。diff形式で表示しています。\u0026rdquo;+\u0026ldquo;は追加した行、\u0026rdquo;-\u0026ldquo;は削除した行です。 mikio@gnudam:~/dev/libgdxtest$ git diff diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.java index ad39967..3c84c72 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -4,17 +4,20 @@ import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; +import com.badlogic.gdx.graphics.g2d.BitmapFont; import com.badlogic.gdx.graphics.g2d.SpriteBatch; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; - Texture img; + BitmapFont font; + Texture img; @Override public void create () { batch = new SpriteBatch(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); - } + font = new BitmapFont(); + } @Override public void render () { @@ -22,6 +25,7 @@ public class LibGdxSample extends ApplicationAdapter { Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); batch.draw(img, 0, 0); + font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } + @Override + public void dispose() { + font.dispose(); + batch.dispose(); + img.dispose(); + } } サンプルでは、なぜかリソースを解放する処理が抜けていたので、 disposeメソッドに追加してあります。disposeはアプリケーションの終了処理を記述します。 Figure 13: 実行画面 スプライトクラスを使用する。 サンプルでは、Textureクラスを直接描画していましたが、 Textureクラスはあくまで画像そのもののクラスであり、ゲーム内で直接扱うのには向いていません。 ゆくゆくは拡大縮小したりアニメーションしたりする必要がでてきますので、そのような操作が扱いやすいSpriteクラスを使用します。 diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.java index 3c84c72..5ab4749 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -5,18 +5,22 @@ import com.badlogic.gdx.Gdx; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.BitmapFont; +import com.badlogic.gdx.graphics.g2d.Sprite; import com.badlogic.gdx.graphics.g2d.SpriteBatch; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; BitmapFont font; Texture img; + Sprite sprite; @Override public void create () { batch = new SpriteBatch(); font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); + sprite = new Sprite(img); } @@ -24,7 +28,7 @@ public class LibGdxSample extends ApplicationAdapter { Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); - batch.draw(img, 0, 0); + sprite.draw(batch); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } このプログラムを実行しても、見た目の変化はありません。 座標系 サンプルプログラムの表示で気づいた方もいるかもしれませんが、libGDXでは座標の原点は左下になります。 座標系に関しては、下記の記事が詳しいです。 http://qiita.com/fslasht/items/d5798516bdbeea49a5d3 要点をまとめると 画面の座標系は左下が原点 スプライトの座標系も左下が原点 スプライトの拡縮時はまんなかが原点 スプライトの回転はまんなかが原点 ただしSprite#setOriginを使えば、中心を変更できる BitMapフォントはなぜか左上が原点(注意!) また、デフォルトで表示されるウィンドウサイズは PC版 640 x 480 Android版 物理画面サイズ Html版 480 x 320 となります。 数値の根拠は以下のソースになります。 https://github.com/libgdx/libgdx/blob/master/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java https://github.com/libgdx/libgdx/blob/master/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidApplicationConfiguration.java /dev/libgdxtest/html/src/com/zarudama/libgdxtest/client/HtmlLauncher.java 画像を動かす 画像の表示ができたのでさっそく動かしてみます。 diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.java index 5ab4749..e97625e 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -2,18 +2,20 @@ package com.zarudama.libgdxtest; import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; +import com.badlogic.gdx.Input; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.BitmapFont; import com.badlogic.gdx.graphics.g2d.Sprite; import com.badlogic.gdx.graphics.g2d.SpriteBatch; +import com.badlogic.gdx.math.Vector2; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; BitmapFont font; Texture img; Sprite sprite; + Vector2 pos; @Override public void create () { @@ -21,14 +23,30 @@ public class LibGdxSample extends ApplicationAdapter { font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); sprite = new Sprite(img); + pos = new Vector2(); } @Override public void render () { + if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) { + pos.x -= 1; + } + if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) { + pos.x += 1; + } + if (Gdx.input.isKeyPressed(Input.Keys.UP)) { + pos.y += 1; + } + if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) { + pos.y -= 1; + } + String info = String.format(\u0026#34;pos(%f,%f)\u0026#34;, pos.x, pos.y); + + sprite.setPosition(pos.x, pos.y); + dx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); sprite.draw(batch); batch.draw(sprite, 0, 0); font.draw(batch, info, 0, 420); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } @Override public void dispose() { font.dispose(); batch.dispose(); img.dispose(); } 座標を扱うのはベクトルクラスが便利なので、posフィールドを追加しています。 また、今自分がいる場所も把握したいので、info変数にposフィールドの値を設定して描画しています。 Figure 14: spriteを動かす キーボードの入力を得るには、Gdx.input.isKeyPressedメソッドを利用します。どのキーかどうかは、Input.Keysの定数で判定できます。 http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/Input.Keys.html 今回は、キーボードだけの例ですが、Androidで入力を扱うには、タッチされた座標を取得する必要があります。タッチ処理は少し複雑なのでここでは割愛します。 効果音を鳴らす 下記のサイトで適当に音を作りました。 http://www.bfxr.net/ 次からダウンロードできます。 http://mikio.github.com/demo/sound/jump.wav ダウンロードしたファイルを下記に追加してください。 ~/dev/libgdxtest/android/assets/ 下記のように変更します。 mikio@gnudam:~/dev/libgdxtest$ git diff diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.j ava index 5ab4749..cf11ba1 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -2,18 +2,22 @@ package com.zarudama.libgdxtest; import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.Input; +import com.badlogic.gdx.audio.Sound; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.BitmapFont; import com.badlogic.gdx.graphics.g2d.Sprite; import com.badlogic.gdx.graphics.g2d.SpriteBatch; +import com.badlogic.gdx.math.Vector2; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; BitmapFont font; Texture img; Sprite sprite; Vector2 pos; + Sound sound; @Override public void create () { @@ -21,14 +25,35 @@ public class LibGdxSample extends ApplicationAdapter { font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); sprite = new Sprite(img); pos = new Vector2(); + sound = Gdx.audio.newSound(Gdx.files.internal(\u0026#34;jump.wav\u0026#34;)); } @Override public void render () { if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) { pos.x -= 1; } if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) { pos.x += 1; } if (Gdx.input.isKeyPressed(Input.Keys.UP)) { pos.y += 1; } if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) { pos.y -= 1; } String info = String.format(\u0026#34;pos(%f,%f)\u0026#34;, pos.x, pos.y); + if (Gdx.input.isKeyPressed(Input.Keys.SPACE)) { + sound.play(); + } Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); batch.draw(sprite, pos.x, pos.y); font.draw(batch, info, 0, 420); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } @Override public void dispose() { font.dispose(); + sound.dispose(); batch.dispose(); img.dispose(); } soundクラスを使いして、playメソッドを呼ぶだけです。スペースキー押下でジャンプしたような効果音が鳴ります。最後にリソースを解放するのを忘れずに。 BGMを鳴らす 下記のサイトで適当に曲を作りました。 http://soundation.com/ 次からダウンロードできます。 http://mikio.github.com/demo/sound/mixdown.mp3 ダウンロードしたファイルを下記に追加してください。 ~/dev/libgdxtest/android/assets/ 下記のように変更します。 diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.java index 5ab4749..c345ac8 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -2,18 +2,24 @@ package com.zarudama.libgdxtest; import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.Input; +import com.badlogic.gdx.audio.Music; import com.badlogic.gdx.audio.Sound; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.BitmapFont; import com.badlogic.gdx.graphics.g2d.Sprite; import com.badlogic.gdx.graphics.g2d.SpriteBatch; import com.badlogic.gdx.math.Vector2; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; BitmapFont font; Texture img; Sprite sprite; Vector2 pos; Sound sound; + Music music; @Override public void create () { @@ -21,15 +27,48 @@ public class LibGdxSample extends ApplicationAdapter { font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); sprite = new Sprite(img); pos = new Vector2(); sound = Gdx.audio.newSound(Gdx.files.internal(\u0026#34;jump.wav\u0026#34;)); + music = Gdx.audio.newMusic(Gdx.files.internal(\u0026#34;mixdown.mp3\u0026#34;)); + music.setLooping(true); + music.setVolume(0.5f); + music.play(); } @Override public void dispose() { font.dispose(); sound.dispose(); + music.dispose(); batch.dispose(); img.dispose(); } } これもMusicクラスを使用して、playメソッドを呼ぶだけです。ただしBGMなので、ループフラグを有効にし、ボリュームを控えめにしています。簡単ですね。最後にリソースを解放するのを忘れずに。 画像を拡大・縮小・回転してみる 最後に、せっかくスプライトクラスを使っているので、拡縮を試してみます。 下記のように変更してください。 diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.java index e52752e..1c12907 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -20,6 +20,7 @@ public class LibGdxSample extends ApplicationAdapter { Vector2 pos; Sound sound; Music music; + float angle; @Override public void create () { @@ -55,11 +56,15 @@ public class LibGdxSample extends ApplicationAdapter { if (Gdx.input.isKeyPressed(Input.Keys.SPACE)) { sound.play(); } sprite.setPosition(pos.x, pos.y); + sprite.setScale((float) Math.sin(angle)); + angle += 0.04; Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); sprite.draw(batch); font.draw(batch, info, 0, 420); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); angle フィールドを追加し、 Sprite#setScale メソッドで拡縮しています。 sclae値としてマイナスを与えると、画像が反転するようです。 Figure 15: spriteを拡縮 ついでに回転させてみます。 diff --git a/core/src/com/zarudama/libgdxtest/LibGdxSample.java b/core/src/com/zarudama/libgdxtest/LibGdxSample.java index 1c12907..696c158 100644 --- a/core/src/com/zarudama/libgdxtest/LibGdxSample.java +++ b/core/src/com/zarudama/libgdxtest/LibGdxSample.java @@ -17,6 +17,7 @@ public class LibGdxSample extends ApplicationAdapter { BitmapFont font; Texture img; Sprite sprite; + Sprite sprite2; Vector2 pos; Sound sound; Music music; @@ -28,6 +29,7 @@ public class LibGdxSample extends ApplicationAdapter { font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); sprite = new Sprite(img); + sprite2 = new Sprite(img); pos = new Vector2(); sound = Gdx.audio.newSound(Gdx.files.internal(\u0026#34;jump.wav\u0026#34;)); music = Gdx.audio.newMusic(Gdx.files.internal(\u0026#34;mixdown.mp3\u0026#34;)); @@ -60,11 +62,14 @@ public class LibGdxSample extends ApplicationAdapter { sprite.setScale((float) Math.sin(angle)); angle += 0.04; + sprite2.setPosition(200, 300); + sprite2.setRotation(angle); + Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); sprite.draw(batch); + sprite2.draw(batch); font.draw(batch, info, 0, 420); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); 効果がわかりにくいので、sprite2フィールドを追加し、スプライトを2つにしました。このようにスプライトを追加しても画像は共有できます。回転は、Sprite#setRotationメソッドで実施しています。 Figure 16: spriteを回転 これ以上の詳しいSpriteクラスの操作は下記のAPIマニュアルを参照してください。 http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g2d/Sprite.html ソース 最後にソースの全体を載せておきます。 package com.zarudama.libgdxtest; import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.Input; import com.badlogic.gdx.audio.Music; import com.badlogic.gdx.audio.Sound; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.BitmapFont; import com.badlogic.gdx.graphics.g2d.Sprite; import com.badlogic.gdx.graphics.g2d.SpriteBatch; import com.badlogic.gdx.math.Vector2; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; BitmapFont font; Texture img; Sprite sprite; Sprite sprite2; Vector2 pos; Sound sound; Music music; float angle; @Override public void create () { batch = new SpriteBatch(); font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); sprite = new Sprite(img); sprite2 = new Sprite(img); pos = new Vector2(); sound = Gdx.audio.newSound(Gdx.files.internal(\u0026#34;jump.wav\u0026#34;)); music = Gdx.audio.newMusic(Gdx.files.internal(\u0026#34;mixdown.mp3\u0026#34;)); music.setLooping(true); music.setVolume(0.5f); music.play(); } @Override public void render () { if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) { pos.x -= 1; } if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) { pos.x += 1; } if (Gdx.input.isKeyPressed(Input.Keys.UP)) { pos.y += 1; } if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) { pos.y -= 1; } //String info = String.format(\u0026#34;pos(%f,%f)\u0026#34;, pos.x, pos.y); String info = \u0026#34;\u0026#34;; //html版ではコンパイルできない。 if (Gdx.input.isKeyPressed(Input.Keys.SPACE)) { sound.play(); } sprite.setPosition(pos.x, pos.y); sprite.setScale((float) Math.sin(angle)); angle += 0.04; sprite2.setPosition(200, 300); sprite2.setRotation(angle); Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); batch.begin(); sprite.draw(batch); sprite2.draw(batch); font.draw(batch, info, 0, 420); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } @Override public void dispose() { sound.dispose(); music.dispose(); batch.dispose(); font.dispose(); img.dispose(); } } おわりに この記事ではゲームプログラミングに最低限必要な以下の方法を学びました。 画像の表示 キーボードの入力 サウンド・BGMの再生 これで一応ゲームは開発できるはずです。でもこれは最低限の方法なので、まだまだいろいろ考慮しなくてはなりません。例えば、 タッチ処理 アニメーション 物理画面に依存しない画面表示 画面遷移 などなどです。 次回 は、これらの処理を学んでいきます。 参考書籍 \"\" \" width=\"1\" height=\"1\" border=\"0\" alt=\"\" style=\"border:none !important; margin:0px !important;\" / libGDXの作者が書いた本。Androidでゲームを作るための基本を独自のフレームワーク作成を通して解説しています。 libGDXの解説ではないけれど、その思想は当然libGDXにも引き継がれています。もちろんlibGDXの理解もしやすくなります。また、Androidの本ではありますが、スマホに特化したわけでもなく、どんなゲーム開発にも通用しそうな内容ばかりです。実践的かつ基本的で自分は退屈せずに読めました(特にMVCについての言及が良い)。そういう意味でこの本は、すべての初級ゲーム開発者におすすめできる本かと思います。ただし一部内容が古いので注意してください(沢山売れて第2版が翻訳されればいいんですが)。それでもlibGDXをやるなら読んでいて損はないと思います。"
},
{
url: "https://zarudama.github.io/post/2018/12/libgdx2/",
title: "libgdx2",
date: "2018-12-17T00:00:00+09:00",
body: "libgdx2 はじめに libGDX を勉強するついでに解説記事を書く シリーズ 2回目です。 前回 は、プロジェクトを作って、以下のことを学びました。 画像の表示 キーボードによる操作 BGMの再生 効果音の再生 今回は次のことを学びます。 物理画面に依存しない画面表示 タッチ処理 物理画面に依存しない画面表示 物理画面とは何でしょうか？ここでは次のように定義します。 スマホやタブレット画面解像度 デスクトップのウィンドウサイズ Androidには様々な画面サイズがありますし、 iPhoneもモデルチェンジ毎に画面サイズが変化しています。これら様々な画面サイズのことを考慮しないと、意図した通りの画面が表示できません。 ゲームを作るときの基本として、物理画面でプログラムしないというのがあります。物理的なディスプレイのサイズに依存した座標管理をすると、移植性が下がり仕様変更に弱くなったり、端末毎の画面サイズの違いを吸収できないプログラムになってしまいます。 例えば横スクロールアクションを作ったときに、 Aさんの画面は小さいから敵の動きがところ狭しとなるところが、 Bさんの端末だと画面が大きいからフィールドが遠くまで見わたせて楽々プレイできる、なんてことが発生します。端末によって難易度が変わってくるのです。 Figure 1: 端末の小さいAさんは、端末の大きいBさんより不利になる 実は既にこの問題は、私の手元で発生しています。下記は、Nexus7(2013)で表示したサンプルの画面です。 Figure 2: nexus7の画面 Figure 3: PC版の画面 Nexus7版は、PCの画面と全然違いますね。キャラクターや文字が非常に小さくなってます。これはPC版が640x480の解像度なのに対して、Nexus7版は1920x1200の解像度で表示しているからです。この状態でゲームを作ってしまったら全然別ものになってしまいますよね。ちなみにMac持ってないのでiOS系ではどうなるかわかりません。 というわけで、どの端末でも公平に画面表示できるようにひと工夫必要になってきます (こういう処理は、ゲームづくりの序盤でやっておかないと、あとから変更するのは大変なのでさっさと済ませておきたいことのひとつですね)。 カメラとビューポート ではどうやってこの問題を解決するか。それにはカメラとビューポートを使用します。 カメラとは、ゲームの世界を現実世界のディスプレイに届けるためのオブジェクトです。 ビューポートとは、カメラの捉えたゲームの世界を、ディスプレイのどこに表示するかを決める枠(矩形領域)のことです。 Figure 4: カメラとビューポート ビューポートは、ディスプレイサイズと一致しているわけではないことに注意してください。ゲームのサンプルなどだと一致していることが多いですが、今回のように様々なディスプレイサイズに対応させる場合は、一致しなくなることの方が多くなるはずです。また、他の使い方としては、カメラを2つ用意して一方はゲーム画面、一方は小さな枠で別のシーンを表示するなんてこともできるかもしれません(やったことないですが)。 カメラを使うことにより、カメラとして定義した論理空間でゲームを制御できます。この空間でやりとりすれば、あとはlibGDXがよろしく画面に表示してくれるわけです。カメラでできることを列挙してみます。 物理的な画面サイズを気にせず、自分の定義した画面サイズでゲームを構築できる ズームイン、ズームアウト、画面を回転させたり、揺らしたりなど、画面全体にかかるエフェクトが簡単にできる カメラを動かすことで、スクロール処理が簡単に実装できる カメラを導入することでこのような自由が手に入るわけですが、その代償として操作が複雑になってしまうのも事実です。コーディング中は、今自分がどこの座標系で何を操作しているかを常に意識する必要があります。ちょっと大袈裟ですが、慣れれば大したことありません。またこの考えはそのまま3Dプログラミングにも繋がります。 座標系には、以下の種類があります。 ワールド座標系。ゲームオブジェクトを置く論理空間。画面サイズは気にしなくて良い。 カメラ座標系。ワールドのゲームオブジェクトをカメラの枠での座標系で測りなおした座標系。真ん中が原点となる。 ビューポート座標系。左下を原点とした座標系。 スクリーン座標系。Android左上を原点とした最終的な座標系。タッチ座標などはOSからこの座標系の値が得られる。 ビューポート座標系とスクリーン座標系は他では別の呼びかたかもしれません。座標系を意識する例を示します。 たとえば、画面をタッチして、その座標にキャラクターが向って行くのであれば、タッチ操作で得られた座標(スクリーン座標系)をワールド座標系に変換する必要があります。 逆にワールドに落ちているコインなどのアイテムを画面UIのスコア表示に吸いこまれるようなエフェクトをかけるときは、ワールドからスクリーンへの変換が必要になるでしょう。 カメラを使用しなくてもゲームは作れますが、いろいろと応用が効くので、パズルゲームのような固定画面のゲームしか使わない予定であっても、使いかたに慣れておいたほうが良いと思います。 実際のコーディング 講釈が多くなってしまいました。実際のコーディングに進みます。まずゲームに使用する画面解像度を決定します。これは、物理的なサイズではなく、論理的なものです。今回は下記のように定義しました。 横800 x 縦480 横長の割と無難なサイズです。 カメラの導入 では早速カメラを導入してみましょう。前回のソースコードに手を入れていきます。前回のサンプルでは、画面サイズはデフォルトのままでしたが、今回はターゲットサイズを横800 x 縦480に設定したので、 createメソッド内でカメラを下記のように定義します。 OrthographicCamera camera; @Override public void create () { ： camera = new OrthographicCamera(800, 480); ： } フィールドに camera を追加しています。ちなみになぜこんな長たらしい名前がついてるのかわかりませんが、 2D用のカメラは、 OrthographicCamera クラスといいます。 libGDXのソースコードを見渡しましたが、他に2D用のカメラは見当たらなかったので OrthographicCamera は2D専用と思って問題ないでしょう。 続いて、描画にカメラを反映させるため、 render メソッドを変更します。 @Override public void render() { : Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); camera.update(); // 追加 #1 batch.setProjectionMatrix(camera.combined); // 追加 #2 batch.begin(); sprite.draw(batch); : } #1 でカメラ自身の座標計算(行列演算)をし、 #2 でその結果をスプライトに適用させる準備をします。この処理は定型処理なので、最初のうちは決めごとと思って問題ありません。 ここまでの実行結果は下記のとおりです。 Figure 5: とりあえずカメラ導入 なにか変です。画像のサイズが以前に比べて縦長になっています。なぜでしょうか？ ビューポートの導入 原因はビューポートの設定にあります。libGDXは、デフォルトのビューポート設定だと、物理画面いっぱいに最終画像を引き伸ばします。今回の場合、カメラの設定を 800x480 に設定したのに対し、実際のウィンドウサイズが 640 x 480 のため歪みがでてしまったのです(横方向に潰れている)。 では、ビューポートはどのように設定すれば良いのでしょうか？ libGDXは、OpenGLを直接操作する低レイヤのメソッドも用意してますので、自分で直接ビューポートをやりくりすることもできます。しかし、libGDXには、このような面倒な作業を請け負ってくれる、高レイヤの ViewPort クラスがあります。今回は、この便利クラスを使うことにしましょう。 フィールドに viewport を追加し、createメソッド内でビューポートを定義します。 OrthographicCamera camera; Viewport viewport; // 追加 @Override public void create () { ： camera = new OrthographicCamera(800, 480); viewport = new FitViewport(800, 480, camera); // 追加 ： } ViewPort はスーパークラスであり、このクラスを継承した様々なクラスがあります。インスンタンスを設定する際には、用途に応じたViewPort継承クラスを指定する必要があります。今回は、 FitViewport クラスを利用します。 続いて resize メソッドを追加します。 resize メソッドは、 ApplicationListener クラスのメソッドであり、画面の向きが変わったり、アプリケーションが起動したタイミングなどで呼ばれます。 @Override public void resize(int width, int height) { viewport.update(width, height); } ビューポートは画面の大きさが変化した時だけ設定すれば良いため、 resize メソッドから呼びだすだけでよく、 render メソッドなどで呼びだす必要はありません。 ここまでの実行結果は下記のとおりです。 Figure 6: とりあえずビューポートも導入 やった、歪みがなくなりました! しかし、ここでひとつおかしいことに気づかないでしょうか？カメラとビューポートのサイズには 800x480 を設定しました。でも、このサンプルのウィンドウサイズは 640x480 です。なぜ表示できるんでしょうか？ このままでは、背景となる塗りつぶし色の赤と、ビューポートの枠の区別がつきにくため、ビューポートの働きがわかりつらくなっています。そこで、 FitViewPort の動きを分かりやすくするために、大きなサイズの画像を背景として表示してみます。 背景の追加 背景用に次の画像を「右クリ→名前をつけて保存」で保存してください。 Figure 7: 背景 保存したファイルを下記に追加してください。 ~/dev/libgdxtest/android/assets/ 下記のように変更します。 フィールド Texture bgImg; // 追加 Sprite bg; // 追加 create メソッド @Override public void create () { : // 追加 bgImg = new Texture(\u0026#34;bg.png\u0026#34;); bg = new Sprite(bgImg); bg.setScale(2.0f, 2.0f); bg.setPosition(-400, -240); : render メソッド @Override public void render() { : batch.setProjectionMatrix(camera.combined); batch.begin(); bg.draw(batch); // 追加 sprite.draw(batch); sprite2.draw(batch); : dispose メソッド @Override public void dispose() { : bgImg.dispose(); } これで実行してみます。 Figure 8: 背景を追加 するとどうでしょう？赤い枠が上下に出現しています。これは、 FitViewPort がウィンドウサイズからビューポートのサイズを自動計算して当初の縦横比を保ってくれるからなのです。 試しにウィンドウサイズを色々マウスでドラッグして変化させてみてください。 Figure 9: ウィンドウを横長にしてみた Figure 10: ウィンドウを縦長にしてみた こんな風に画面のサイズに応じて、ビューポートのサイズを動的に変化さてくれます。画面の短い辺に対して最大のサイズを割りあて、長い辺に大してはその比率を調整するようですね。 もちろんNexus7の実機でもうまく表示できています。 Figure 11: ちにみにこれはNexus7の2012年度版 このように、 FitViewPort クラスを使うことにより、どのような画面サイズであっても、こちらの意図したとおりの画面比率で表示されるようになります。 ViewPort クラスには他にも様々な種類のクラスがあります。いろいろ試してみてください。 https://github.com/libgdx/libgdx/wiki/Viewports ちなみに上記ビューポートの解説は、下記のよう辿るといきつけます。 https://github.com/libgdx/libgdx/wiki → Scene2d → ViewPort カメラの位置調整 以上で、カメラとビューポートの導入を終えたのですが、まだおかしいところがあります。どこでしょうか？ 実はスプライト画像がひとつしか表示されてません。本来は2つ表示されているハズなのですが。最初の時はこうでした。 Figure 12: PC版の画面(再掲) 何が起きているかというと、カメラの位置がおかしいのです。カメラはスプライトと違って、真ん中が原点となります。なので、ワールド原点を中心とした枠が表示されているのです。 Figure 13: カメラはワールド原点(0,0)に位置している 左上が(-400,240),右上が(400,240),右下が(400,-240),左下が(-400,-240)の枠となっています。このために2つめのスプライトがちょうど右上の枠の外に位置しており、画面から消えてしまっているのです。 ワールド軸の描画 ここで、見た目をわかりやすくするためにワールドの座標軸を描画してみます。 インポート import com.badlogic.gdx.graphics.glutils.ShapeRenderer; フィールド ShapeRenderer shapeRenderer; // 追加 create メソッド @Override public void create () { : // 追加 shapeRenderer = new ShapeRenderer(); : render メソッド @Override public void render() { : // ワールド座標軸を描画する。 shapeRenderer.setProjectionMatrix(camera.combined); shapeRenderer.begin(ShapeRenderer.ShapeType.Line); shapeRenderer.setColor(1, 0, 0, 1); shapeRenderer.line(-1024, 0, 1024, 0); shapeRenderer.setColor(0, 1, 0, 1); shapeRenderer.line(0, -1024, 0, 1024); shapeRenderer.end(); : dispose メソッド @Override public void dispose() { : shapeRenderer.dispose(); } これで実行してみます。 Figure 14: カメラをsetToOrthoした結果 X軸を赤、Y軸を緑で描画しています。これで状況がよりわかりやすくなったと思います。 setToOrthメソッド 画面の原点を左下に調整するというのはよくあることなので、専用のメソッドが用意されています。 そこで試しに下記のメソッドを追記してみましょう。 create メソッド @Override public void create () { : camera = new OrthographicCamera(800,480); camera.setToOrtho(false, 800, 480); // 追加 : } Camera#setToOrtho メソッドは、カメラを右上に移動させて、左下に丁度ワールド原点がくるように調整するものです。第1引数は、ydownといって、trueにするとY軸が反転されますが、通常はfalseで良いと思います。第2引数と第3引数は、カメラのの幅と高さです。 setToOrth をコンストラクタに続けて指定する時は、コンストラクタには、サイズ指定はいらないですね(今回は修正が面倒なのでそのまま)。 これを実行すると以下のように表示されます。 Figure 15: カメラをsetToOrthoした結果 無事カメラが移動されて、2つ目のスプライトも表示されるようになりました。 カメラを動かす こんどはカメラをキーボードで動かしてみましょう。 render メソッドで下記のように追記します。 @Override public void render() { if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) { //pos.x -= 1; // 削除 camera.position.x -= 2; // 追加 } if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) { //pos.x += 1; // 削除 camera.position.x += 2; // 追加 } if (Gdx.input.isKeyPressed(Input.Keys.UP)) { //pos.y += 1; // 削除 camera.position.y += 2; // 追加 } if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) { //pos.y -= 1; // 削除 camera.position.y -= 2; // 追加 } pos ベクトルへの処理を削除し、変わりに camera.position への処理を追加します。これを実行すると以下のように表示されます。 Figure 16: カメラを動かしている様子 カーソルキーでカメラを動かしてみてください。背景のBG画像があまり大きくないので端にいくと表示が変な見ためになるので注意です。 ここで、カメラが本当に動いているのか数値からも判断するため、カメラの座標を表示してみます。 render メソッドで下記のように追記します。 @Override public void render() { ： // カメラの座標の文字列を作って String info = String.format(\u0026#34;cam pos(%f,%f)\u0026#34;, camera.position.x, camera.position.y); batch.setProjectionMatrix(camera.combined); batch.begin(); ： font.draw(batch, info, 0, 20); // 追加 ： batch.begin(); 座標は大体左したに表示されるように指定しています。 これを実行すると以下のように表示されます。 Figure 17: カメラの座標を表示してみる 左下に表示されてますね。ではカーソルキーでカメラを動かしてみてください。 Figure 18: カメラの座標文字がついてこない？! あれ、期待した動きと違ってませんか？ 私は違いました。どう動いて欲しかったというと、画面にひっついて常に左下に表示して欲しいと思いました。 実は、このフォント描画はワールド座標に対して行なわれているのです。フォント文字もワールドに存在するスプライトと同じオブジェクトとして描画されているんですね。 これを画面にひっつかせて描画させるには、ひと工夫必要です。 UI用カメラの導入 答えは簡単です。もうひとつカメラを用意すれば良いのです。 UI専用のカメラを準備して、そのカメラは動かさずにおく。これだけでオッケーです(libGDXのサンプルでもやっている方法です)。 フィールド OrthographicCamera uiCamera; // 追加 create メソッド @Override public void create () { : // 追加 uiCamera = new OrthographicCamera(); uiCamera.setToOrtho(false, 800, 480); : render メソッド @Override public void render() { : //font.draw(batch, info, 0, 20); //font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); : // render の一番最後で描画すること uiCamera.update(); batch.setProjectionMatrix(uiCamera.combined); batch.begin(); font.draw(batch, info, 0, 20); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } 以前の font.draw はコメントアウトもしくは、削除します。注意すべき点は、UIの描画物は render メソッド内の一番最後で描画するということです。これは、画面上の一番上に描画するためです。 実行してみます。 Figure 19: UIカメラを追加してみた おおお、無事希望どおりの動きになりました! さて、ここで気になることがあります。それは、画面サイズとして 800x480 を指定しているにも関わらず、ウィンドウサイズが 640x480 のままだということです。 Windowサイズの変更 スマホなどの端末は、ハードウェアなので画面サイズを変更できませんが、 Desktop版は、ウィンドウなので、初期サイズを変更できます。 下記のファイルを編集すればオッケーです。 ~/dev/libgdxtest/desktop/src/com/zarudama/libgdxtest/desktop/DesktopLauncher.javapublic class DesktopLauncher { public static void main (String[] arg) { LwjglApplicationConfiguration config = new LwjglApplicationConfiguration(); config.width = 800; // 追加 config.height = 480; // 追加 new LwjglApplication(new LibGdxSample(), config); } } 実行結果です。 Figure 20: UIカメラを追加してみた 画面サイズと論理サイズが一致したので赤い帯がなくなりましたね! タッチ処理 いよいよ最後のお題です。私も疲れてきました^^。 前回は、キーボード入力の処理方法は学んだもののスマホ特有の処理、タッチ操作の処理方法は先送りにしていました。 指でタッチしているかどうかを検知するには、 Gdx.input.isTouched メソッドを使用します。 if (Gdx.input.isTouched(0)) { : // なにかの処理 : } このメソッドの引数には番号が必要ですが、これはタッチした指の番号です。最初にタッチした指の番号は0, 2番目にタッチした座標の番号は1という具合です。 タッチの座標を得るには、 Gdx.input.getX , Gdx.input.getY メソッドを使用します。 float x0 = Gdx.input.getX(0); float y0 = Gdx.input.getY(0); 番号は先程の説明と同じ意味です。 ただしこの座標、注意が必要で、得られる座標は、画面左上を原点とします。 x座標は左から右、Y座標は上から下に伸びます。 Figure 21: スクリーン座標系 この座標系は一般的にはスクリーン座標系などと呼ばれ、最終的な絶対座標(物理座標)として使われるものですが、libGDXでは左下を原点とした座標のためこのままでは使用できません。 ただし私たちは今回カメラを導入しています。なのでカメラの便利メソッドで簡単に変換できます。こんな感じです。 Vector3 touchPos = new Vector3(); touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0); camera.unproject(touchPos); // #1 targetPos.set(touchPos.x, touchPos.y); #1 で、スクリーン座標で得た左上を原点とした座標をワールドの座標に変換します。 2013/06/19 追記 上記説明には、誤りがありました。カメラだけを使用している場合は、 Camera#unproject() メソッドで良いのですが、 Viewport クラスを使用している場合は、 Viewport#unproject() メソッドを使用する必要があります。従って今回は、 Viewport#unproject() を使用しなければなりません。説明はこのままにしておきますが、ソースコードの方は訂正してあります。 この処理を if で囲ってあげれば判定処理の出来あがりです。 if (Gdx.input.isTouched(0)) { Vector3 touchPos = new Vector3(); touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0); camera.unproject(touchPos); // #1 targetPos.set(touchPos.x, touchPos.y); } Gdx.input.isTouched メソッドは、タッチし続けてれば、毎フレーム「真」になります。 他にタッチを検出するメソッドとして、 Gdx.input.justTouched メソッドがあります。このメソッドは、ひとつ前のフレームにタッチしていた場合は、偽になります。どういうことかというと、押しっぱなしにしてた場合は、最初の一回しか真にならないということです。 例えば、下記のようなコードで、タッチした時だけ音を鳴らすことができます。 if (Gdx.input.justTouched()) { sound.play(); } ちなみにjustTouchedと同等の機能のキーボード版のメソッドはありません。恐らく、このメソッドの実装には、状態変数の保持が必要になってくるので、そこをライブラリ側で実装してしまうと無駄が多くなるので、ユーザー側に任せたのだと思います。 では、上記の説明をもとに、スプライトをタッチした場所へ移動させるコードを追加します。下記のように修正してみてください。 インポート。 import com.badlogic.gdx.math.Vector3; フィールド。 Vector2 targetPos; render メソッド。キーボード処理の直後に追加します。 @Override public void render() { ： if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) { pos.y -= 1; camera.position.y -= 2; } : // ↓追加 if (Gdx.input.justTouched()) { sound.play(); } if (Gdx.input.isTouched(0)) { Vector3 touchPos = new Vector3(); touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0); camera.unproject(touchPos); targetPos.set(touchPos.x, touchPos.y); } // ↑追加 String info = String.format(\u0026#34;cam pos(%f,%f)\u0026#34;, camera.position.x, camera.position.y); // ↓追加 pos.lerp(targetPos, 0.2f); sprite.setPosition(pos.x, pos.y); // ↑追加 ： } render メソッド内で実行している pos.lerp メソッドは、第一引数の座標へ値を少しずつ近づけていく処理を実施します。「最初早くて後おそく」って感じの動きです。 では、実行してみます。 Figure 22: マウスでクリックすると、音を鳴らしながら移動します これまでのコードを忠実に入力していれば、音をビヨーンとならしながら移動します。 以上で今回の解説は終了です。お疲れさまでした。 ソース 最後に今回のソースコードを掲載しておきます。 package com.zarudama.libgdxtest; import com.badlogic.gdx.ApplicationAdapter; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.Input; import com.badlogic.gdx.audio.Music; import com.badlogic.gdx.audio.Sound; import com.badlogic.gdx.graphics.GL20; import com.badlogic.gdx.graphics.OrthographicCamera; import com.badlogic.gdx.graphics.PerspectiveCamera; import com.badlogic.gdx.graphics.Camera; import com.badlogic.gdx.graphics.Texture; import com.badlogic.gdx.graphics.g2d.BitmapFont; import com.badlogic.gdx.graphics.g2d.Sprite; import com.badlogic.gdx.graphics.g2d.SpriteBatch; import com.badlogic.gdx.math.Vector2; import com.badlogic.gdx.math.Vector3; import com.badlogic.gdx.utils.viewport.FitViewport; import com.badlogic.gdx.utils.viewport.FillViewport; import com.badlogic.gdx.utils.viewport.StretchViewport; import com.badlogic.gdx.utils.viewport.ScreenViewport; import com.badlogic.gdx.utils.viewport.ExtendViewport; import com.badlogic.gdx.utils.viewport.Viewport; import com.badlogic.gdx.graphics.glutils.ShapeRenderer; public class LibGdxSample extends ApplicationAdapter { SpriteBatch batch; BitmapFont font; Texture img; Sprite sprite; Sprite sprite2; Vector2 pos; Sound sound; Music music; float angle; OrthographicCamera camera; Viewport viewport; Texture bgImg; Sprite bg; ShapeRenderer shapeRenderer; OrthographicCamera uiCamera; Vector2 targetPos; @Override public void create () { batch = new SpriteBatch(); font = new BitmapFont(); img = new Texture(\u0026#34;badlogic.jpg\u0026#34;); sprite = new Sprite(img); sprite2 = new Sprite(img); pos = new Vector2(); sound = Gdx.audio.newSound(Gdx.files.internal(\u0026#34;jump.wav\u0026#34;)); music = Gdx.audio.newMusic(Gdx.files.internal(\u0026#34;mixdown.mp3\u0026#34;)); music.setLooping(true); music.setVolume(0.5f); music.play(); bgImg = new Texture(\u0026#34;bg.png\u0026#34;); bg = new Sprite(bgImg); bg.setScale(2.0f, 2.0f); bg.setPosition(-400, -240); camera = new OrthographicCamera(800,480); camera.setToOrtho(false, 800, 480); viewport = new FitViewport(800, 480, camera); uiCamera = new OrthographicCamera(); uiCamera.setToOrtho(false, 800, 480); shapeRenderer = new ShapeRenderer(); targetPos = new Vector2(); } @Override public void resize(int width, int height) { viewport.update(width, height); } @Override public void render() { if (Gdx.input.isKeyPressed(Input.Keys.LEFT)) { camera.position.x -= 2; } if (Gdx.input.isKeyPressed(Input.Keys.RIGHT)) { camera.position.x += 2; } if (Gdx.input.isKeyPressed(Input.Keys.UP)) { camera.position.y += 2; } if (Gdx.input.isKeyPressed(Input.Keys.DOWN)) { camera.position.y -= 2; } if (Gdx.input.justTouched()) { sound.play(); } if (Gdx.input.isTouched(0)) { Vector3 touchPos = new Vector3(); touchPos.set(Gdx.input.getX(), Gdx.input.getY(), 0); viewport.unproject(touchPos); targetPos.set(touchPos.x, touchPos.y); } String info = String.format(\u0026#34;cam pos(%f,%f)\u0026#34;, camera.position.x, camera.position.y); pos.lerp(targetPos, 0.2f); sprite.setPosition(pos.x, pos.y); sprite.setScale((float) Math.sin(angle)); angle += 0.04; sprite2.setRotation(angle); sprite2.setPosition(200, 300); sprite2.setRotation(angle); Gdx.gl.glClearColor(1, 0, 0, 1); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); camera.update(); // ワールドからスクリーンまでのマトリックスを生成する。 batch.setProjectionMatrix(camera.combined); batch.begin(); bg.draw(batch); sprite.draw(batch); sprite2.draw(batch); batch.end(); // ワールド座標軸を描画する。 shapeRenderer.setProjectionMatrix(camera.combined); shapeRenderer.begin(ShapeRenderer.ShapeType.Line); shapeRenderer.setColor(1, 0, 0, 1); shapeRenderer.line(-1024, 0, 1024, 0); shapeRenderer.setColor(0, 1, 0, 1); shapeRenderer.line(0, -1024, 0, 1024); shapeRenderer.end(); uiCamera.update(); // uiCameraを動かさないのであれば、必要ない。 batch.setProjectionMatrix(uiCamera.combined); batch.begin(); font.draw(batch, info, 0, 20); font.draw(batch, \u0026#34;Hello libGDX\u0026#34;, 200, 400); batch.end(); } @Override public void dispose() { sound.dispose(); music.dispose(); batch.dispose(); font.dispose(); img.dispose(); bgImg.dispose(); shapeRenderer.dispose(); } } おわりに 面倒だけど重要な説明が終りました。これで、端末の画面サイズを気にせずプログラミングできるようになりました。 次回 は、そろそろゲームっぽいものをつくろうかなと思います。予定している内容は、 アニメーション処理 画面遷移 2DScene などです。 参考URL ビューポートについては下記にも詳しい内容があります。合せて読めば理解も深まると思います。 http://qiita.com/fslasht/items/13dbf31277ad43e50b85 http://qiita.com/fslasht/items/c0830eaf05b7a91b8e85 参考書籍 \"\" \" width=\"1\" height=\"1\" border=\"0\" alt=\"\" style=\"border:none !important; margin:0px !important;\" / libGDXの作者が書いた本です。Androidでゲームを作るための基本を独自のフレームワーク作成を通して解説しています。 libGDXの解説ではないけれど、その思想は当然libGDXにも引き継がれています。もちろんlibGDXの理解もしやすくなります。また、Androidの本ではありますが、スマホに特化した内容ばかりではなく、どんなゲーム開発にも通用しそうな内容ばかりです。実践的かつ基本的で自分は退屈せずに読めました(特にMVCについての言及が良い)。そういう意味でこの本は、すべての初級ゲーム開発者におすすめできる本かと思います。ただし一部内容が古いので注意してください(沢山売れて第2版が翻訳されればいいんですが)。それでもlibGDXをやるなら読んでいて損はないと思います。 変更履歴 2014/06/19 タッチ座標の取得方法に問題があったのを訂正した。"
},
{
url: "https://zarudama.github.io/",
title: "ざる魂",
date: "2018-12-17T00:00:00+09:00",
body: "ざる魂"
},
{
url: "https://zarudama.github.io/search/data.js",
title: "",
date: "0001-01-01T00:00:00Z",
body: ""
},
{
url: "https://zarudama.github.io/categories/",
title: "Categories",
date: "0001-01-01T00:00:00Z",
body: "Categories"
},
{
url: "https://zarudama.github.io/search/",
title: "Searches",
date: "0001-01-01T00:00:00Z",
body: "Searches"
},
{
url: "https://zarudama.github.io/tags/",
title: "Tags",
date: "0001-01-01T00:00:00Z",
body: "Tags"
},
];
