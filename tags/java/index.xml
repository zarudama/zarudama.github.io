<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on ざる魂</title>
    <link>https://zarudama.github.io/tags/java/</link>
    <description>Recent content in java on ざる魂</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sat, 08 Jun 2019 14:01:39 +0900</lastBuildDate>
    <atom:link href="https://zarudama.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>javaまとめ</title>
      <link>https://zarudama.github.io/posts/java-matome/</link>
      <pubDate>Sat, 08 Jun 2019 14:01:39 +0900</pubDate>
      <guid>https://zarudama.github.io/posts/java-matome/</guid>
      <description>メッセージのUS化 日本語だとコンパイルエラーメッセージが化けるので -Duser.language=en メモリー・リークの予防 http://www.ibm.com/developerworks/jp/java/library/j-leaks/ メモリー・リークは、いくつかの一般的な問題に注意することにより防ぐことができます。 しばしばメモリー・リークの原因となるのは、ハッシュ・テーブルやベクトルなどのコレクション・クラスです。 そのクラスが static と宣言されていて、アプリケーションの存続期間全体にわたって存在する場合、その可能性が特に大きくなります。 よくある別の問題は、あるクラスをイベント・リスナーとして登録しておきながら、そのクラスがもう使用されなくなった時点で登録削除するのを忘れている場合です。 また、クラスのメンバー変数が別のクラスを指す場合、適当なタイミングでその変数をヌルにセットする必要があります。&#xA;自作CRUDアプリ createメソッド実装時に下記の例外でハマる java.lang.reflect.InvocationTargetException commons-configurationではまる。 JavaDB javaDBのスタンドアロン版では、ijを起動中、サーブレットアプリからアクセスできないので注意。&#xA;connect &amp;#39;jdbc:derby:c:\Temp\dbname;create=true&amp;#39;; create table articles ( id integer primary key generated by default as identity, title varchar(256), body long varchar, updated_at timestamp ); insert into articles values (default, &amp;#39;title1&amp;#39;, &amp;#39;body1&amp;#39;, current_timestamp); tomcat context.xml&#xA;&amp;lt;Context reloadable=&amp;#34;true&amp;#34;&amp;gt; &amp;lt;Resurce name=&amp;#34;jdbc/crud&amp;#34; auth=&amp;#34;container&amp;#34; type=&amp;#34;javax.sql.DataSource&amp;#34; driverClassName=&amp;#34;org.apache.derby.jdbc.EmbeddedDriver&amp;#34; url=&amp;#34;jdbc:derby:c:\Temp\dbname&amp;#34;/&amp;gt; &amp;lt;/Context&amp;gt; web.xml&#xA;&amp;lt;resource-ref&amp;gt; &amp;lt;res-ref-name&amp;gt;jdbc/crud&amp;lt;/res-ref-name&amp;gt; &amp;lt;res-type&amp;gt;javax.sql.DataSource&amp;lt;/res-type&amp;gt; &amp;lt;res-auth&amp;gt;Container&amp;lt;/res-auth&amp;gt; &amp;lt;/resource-ref&amp;gt; Servlet&#xA;private DataSource ds; @Override public void init() throws ServletException { try { ds = (DataSource) (new InitialContext()).</description>
    </item>
    <item>
      <title>GCの発生頻度などの調査</title>
      <link>https://zarudama.github.io/posts/jvm_gcutil/</link>
      <pubDate>Tue, 25 Mar 2014 14:01:39 +0900</pubDate>
      <guid>https://zarudama.github.io/posts/jvm_gcutil/</guid>
      <description>GCの発生頻度を調査するためのカンペ。gclogを使用せずにお手軽に実施できる。&#xA;まずはプロセスIDを調べる。例としてtomcatの場合。&#xA;$ sudo -u tomcat jps -v tomcatユーザの起動したJavaプロセスのIDを付加情報付きで表示する。&#xA;javaプロセスがひとつしかない場合などは、下記のほうが楽かもしれない。&#xA;$ pgrep -lf java PIDが123456だった場合、3秒ごとにgcの発生状況をチェックするコマンドの例。&#xA;jstat -gcutil -t 123456 3000 意味は以下のとおり。&#xA;jstat &amp;lt;出力オプション&amp;gt; &amp;lt;プロセスID&amp;gt; &amp;lt;データ取得間隔(ms)&amp;gt; -t タイムスタンプを出力 -gcutil GCの統計情報 jstatのマニュアルは以下。&#xA;http://docs.oracle.com/javase/jp/6/technotes/tools/share/jstat.html gcutilの見出し&#xA;Timestamp S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT gcutilの見出しは以下のルールになる&#xA;S* Suviver E* Eden Y Young O* Old P* Permenet Permanent領域は、JVMにロードされたクラスの置き場所 F* Full *C comitted javaが確保したメモリサイズ *U used 使用済みメモリ *GC GCの回数 *GCT GCの時間 GCについては、下記が詳しい。</description>
    </item>
    <item>
      <title>JVMのヒープサイズと変更方法</title>
      <link>https://zarudama.github.io/posts/jvm_mem/</link>
      <pubDate>Tue, 25 Mar 2014 14:01:39 +0900</pubDate>
      <guid>https://zarudama.github.io/posts/jvm_mem/</guid>
      <description>稼動中のJVMのヒープサイズを知りたくなることは良くあるのでその方法。1&#xA;JVMの初期ヒープサイズ JVMは、サーバーモードで起動しているのか、クライアントモードで起動しているかで、 初期割り当てのヒープサイズが異なる。&#xA;サーバーモードなのかクライアントモードなのかは、実行ユーザにて、下記コマンドで確認できる。&#xA;$ java -version java version &amp;#34;*****&amp;#34; Java(TM) SE Runtime Environment (build ******) Java HotSpot(TM) Server VM (build ******) Severモードの場合は、 Server の表記があるはず。&#xA;サーバーモード&#xA;初期ヒープサイズ マシンの物理メモリーの 1/64 か、妥当な最小サイズかの大きい方。 最大ヒープサイズ 物理メモリーの 1/4 か、1GB かの小さい方。 http://docs.oracle.com/javase/jp/6/technotes/guides/vm/gc-ergonomics.html JVMの稼動時のヒープサイズ JVMの使用しているヒープの量を調べる(以降、すべてOracleJava)。&#xA;$ sudo jstat -gc 28905 S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT 127552.0 137152.0 0.0 68410.3 224000.0 107742.6 996736.0 113947.3 61440.0 61324.8 7 1.</description>
    </item>
    <item>
      <title>Emacs中毒者に贈るJDEEによるJava開発環境の構築</title>
      <link>https://zarudama.github.io/posts/emacsjdeejava/</link>
      <pubDate>Sun, 23 Dec 2012 14:01:39 +0900</pubDate>
      <guid>https://zarudama.github.io/posts/emacsjdeejava/</guid>
      <description>この投稿は Emacs Advent Calendar 2012 の23日目の記事です。 追記(2013/08/01) いつの間にか本家JDEEがCEDET2.0に対応していました。 emacs24.3にはCEDET2.0が最初から導入されているため、CEDETを別途導入する必要はなくなります。 これによりJDEEの導入がグッっと簡単になりました。&#xA;そこで最新のemacs24.3対応ということでもう一度記事の内容を整理しました。 特に理由のない限り、最新のemacsとJDEEを利用するのが良いかと思います。&#xA;また嬉しいことにJDEE(に代わるJavaの開発環境)の開発(議論)がスタートしているみたいです。 今後に期待しましょう。&#xA;http://sourceforge.net/mailarchive/message.php?msg_id=30783951 はじめに Java開発といえばEclipse一択なこの時代、どれだけ需要があるかわかりませんが、 Emacs中毒な皆さんはできればEclipseなんか使いたくないですよね？ 私は使いたくないです(笑)。私もご多分にもれず、なんでもEmacsで済ましたい人になってしまったので、 当然JavaもEmacsで開発したくなります。そこでJDEEの環境を構築しようとしたのですが、 JDEEの開発は停止しているせいか、最新のEmacs23や24だとすんなり動きません。&#xA;ならばと、malabar-modeも試したのですが、Maven環境を要求してきますし、 なんだか動作がもっさりな上に(JDEEより重い印象)ところどころエラーがでたりしてうまく動きません。&#xA;で、やっぱりJDEEがいいということで、苦労の末、 最近やっとemacsによるJava開発環境(JDEE)が構築できたのでその方法をメモしておきます。&#xA;今回は、JDEEの導入方法しか解説しませんが、最終的な私のJava開発環境は以下のとおりです。 今ところantベースのプロジェクトでしか使用しておらず、 Mavenベースのプロジェクトでは動作確認してません。&#xA;インポート文の自動生成 JDEE Javadoc表示 JDEE + w3m ビルド JDEE + ant デバッガ JDEE + jdb REPLぽいもの JDEE(BeanShell) コードスニペット Yasnippet タグジャンプ gtags(global) メソッド補完 helm-jdee-method(拙作) まだ導入したばかりで検証してないものもあります。 JDEEは「BeanShell(JavaInterpreter) + 大作Elisp拡張」という、 「重い + 重い」の強力タッグです。動作速度については期待しないほうが良いです。 メソッド補完については、Helmで補完するelispを自作しました。&#xA;必要なもの JDEEのビルドには下記のものが必要になります。&#xA;emacs24.3 emacsは執筆時点の最新のemacs24.3を使用しています。 JDEE-2.4.2 githubに ミラー がありますのでそちらを利用します。 CEDET CEDETは、24.3同梱のものを使用するので別途用意する必要はありません。 ant-contrib-0.6 ant-contribは、 ant側のライブラリとしてビルド時に必要です。</description>
    </item>
    <item>
      <title>javapコマンドを使ってみた。</title>
      <link>https://zarudama.github.io/posts/javap/</link>
      <pubDate>Sat, 02 Jun 2012 14:01:39 +0900</pubDate>
      <guid>https://zarudama.github.io/posts/javap/</guid>
      <description>Javaは *.java から *.class を生成するが、これはテキストエディタで閲覧できないバイナリファイルだ。 これをエディタで閲覧できる状態にするには、jdkに標準搭載されているjavapコマンドを使用しすれば良い。&#xA;例えばhogeというパッケージにあるFuga.javaがあるとする。&#xA;package hoge; public class Fuga { public static void main(String[] args) { System.out.println(&amp;#34;Hello Javap!&amp;#34;); } } これをコンパイルした結果をjavapで見たい時は、以下のようなコマンドを叩けばいい。 このときhoge.Fugaクラスはhoge/Fuga.lcassというディレクトリ構造になければならない。&#xA;javap -c hoge.Fuga &amp;gt; Fuga.code Fuga.codeは以下のようになる。&#xA;Compiled from &amp;#34;Fuga.java&amp;#34; public class hoge.Fuga { public hoge.Fuga(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V 4: return public static void main(java.lang.String[]); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello Javap! 5: invokevirtual #4 // Method java/io/PrintStream.</description>
    </item>
    <item>
      <title>Javaでカンマ区切りの数字を出力する。</title>
      <link>https://zarudama.github.io/posts/java-printf/</link>
      <pubDate>Wed, 02 May 2012 14:01:39 +0900</pubDate>
      <guid>https://zarudama.github.io/posts/java-printf/</guid>
      <description> 下記のとおり。&#xA;int value = 99999999; String.format(&amp;#34;%1$,3d円&amp;#34;, value); // =&amp;gt; 99,999,999円; この場合「%1$,3d」が書式になる。&#xA;%は書式の開始を示す。 1$は引数のインデックスを示す。ひとつの引数を使い回すときなどに必要。今回の場合はひとつなので無くても良い。 ,は区切りたい文字 3 は区切りたい桁 d は引数が数字(デシマル)を示す。 </description>
    </item>
  </channel>
</rss>
